C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/18/2020 01:36:24 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE C8051F12X_FIR_DEMO
OBJECT MODULE PLACED IN C8051F12x_FIR_Demo.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE C8051F12x_FIR_Demo.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // Includes
   3          //-----------------------------------------------------------------------------
   4          
   5          #include "si_toolchain.h"             // Compiler-specific declarations
   6                                                 // (Keil/SDCC)
   7          #include "C8051F120_defs.h"            // SFR declarations
   8          #include <stdio.h>
   9          #include <math.h>
  10          #include "fir.h"
  11          #include "modbus.h"
  12          
  13          //-------------------------- BIPOLIAR SELECTOR --------------------------------
  14          //#define BIPOLIAR_ADC
  15          //-----------------------------------------------------------------------------
  16          
  17          //-----------------------------------------------------------------------------
  18          // Global Constants
  19          //-----------------------------------------------------------------------------
  20          
  21          #define BAUDRATE     115200            // Baud rate of UART in bps
  22          
  23          #define INTCLK       24500000          // Internal oscillator frequency in Hz    
  24          
  25          #define SYSCLK       98000000          // Output of PLL derived from (INTCLK*2)
  26          
  27          #define SAMPLE_RATE  11000             // Sample frequency in Hz
  28          
  29          #define N            500               // Number of samples to capture at
  30                                                 // each DAC frequency
  31          
  32          #define PHASE_PRECISION  65536         // Range of phase accumulator
  33          
  34          #define OUTPUT_RATE_DAC  20000L        // DAC output rate in Hz
  35          
  36          #define START_FREQUENCY  10            // Define the starting frequency
  37          #define STOP_FREQUENCY   4999          // Define the ending frequency
  38          #define FREQ_STEP        10            // Define the number of Hz the frequency
  39                                                 // will step for the frequency sweep
  40          #define DAC1_VALUE       0x8000        // value for DAC1
  41          #define SECOND_INTERVAL  1024
  42          //-----------------------------------------------------------------------------
  43          // Commands
  44          //-----------------------------------------------------------------------------
  45          const uint8_t CMD_1     =0x22;
  46          const uint8_t CMD_2     =0x05;
  47          const uint8_t CMD_3     =0x09;
  48          const uint8_t CMD_4     =0x06;
  49          const uint8_t CMD_5     =0x11;
  50          const uint8_t CMD_6     =0x12;
  51          //-----------------------------------------------------------------------------
  52          // Macros
  53          //-----------------------------------------------------------------------------
  54          
  55          #if defined __C51__
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/18/2020 01:36:24 PAGE 2   

  56          #include <intrins.h>
  57          #define NOP() \
*** WARNING C317 IN LINE 58 OF C8051F12x_FIR_Demo.c: attempt to redefine macro 'NOP'
  58             _nop_();
  59          #elif defined SDCC
              #define NOP() \
                 _asm \
                 nop \
                 _endasm;
              #endif // defined SDCC
  65          
  66          // Single FIR_TAP macro takes advantage of mirroring
  67          // (i.e. the FIR coefficients are mirrored, so the coefficient only needs to be
  68          // loaded into the MAC registers once).
  69          #define FIR_TAP_MIRROR(X,Y,Z) \
  70             MAC0A = X; \
  71             MAC0BH = Y.u8[MSB]; \
  72             MAC0BL = Y.u8[LSB]; \
  73             MAC0BH = Z.u8[MSB]; \
  74             MAC0BL = Z.u8[LSB];
  75          
  76          // Single FIR_TAP macro
  77          #define FIR_TAP(X,Y) \
  78             MAC0A = X; \
  79             MAC0BH = Y.u8[MSB]; \
  80             MAC0BL = Y.u8[LSB];
  81          
  82          #define BREAK_MACRO \
  83             SFRPAGE = UART0_PAGE; \
  84             if(TI0 == 1 || RI0 == 1){ \
  85               break; \
  86             } \
  87             SFRPAGE = SFRPAGE_save;
  88          
  89          //-----------------------------------------------------------------------------
  90          // Global Variables
  91          //-----------------------------------------------------------------------------
  92          // For the FIR filter
  93          // 'x' holds the 'delay line' of input samples
  94          //idata SI_UU16_t x[TAPS];
  95          SI_SEGMENT_VARIABLE(x[FILTER_MAX_ORDER], SI_UU16_t, xdata);
  96          SI_SEGMENT_VARIABLE(B_FIR[FILTER_MAX_ORDER], SI_UU16_t, xdata);
  97          SI_SEGMENT_VARIABLE(TAPS, uint8_t, xdata);
  98          SI_SEGMENT_VARIABLE(data_for_filter[N], SI_UU16_t, xdata);
  99          SI_SEGMENT_VARIABLE(data_for_filter_counter, int, xdata);
 100          SI_SEGMENT_VARIABLE(filtered_samples[N], int, xdata);
 101          SI_SEGMENT_VARIABLE(freq_number, unsigned char, xdata);
 102          SI_SEGMENT_VARIABLE(phase_acc[12], SI_UU16_t, xdata) = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
 103          SI_SEGMENT_VARIABLE(FREQS[12], unsigned long, xdata) = {1343, 1445, 1547, 1649, 1751, 1853, 1955, 2057, 21
             -59, 2261, 2363, 2465};
 104          SI_SEGMENT_VARIABLE(frequency, unsigned long, xdata);
 105          SI_SEGMENT_VARIABLE(delay_index_arr[12], unsigned char, xdata) = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
 106          SI_SEGMENT_VARIABLE(freq_divider, unsigned char, xdata);
 107          SI_SEGMENT_VARIABLE(freq_dac_flags[12], unsigned char, xdata);
 108          
 109          sbit LED = P1^6;                                         // LED='1' means ON
 110          sbit LED485 = P7^7;                                      // LED for 485
 111          sbit DC24OUTPUT = P4^2;
 112          sbit DC24INPUT = P4^3;
 113          
 114          SI_SEGMENT_VARIABLE(Sample, SI_UU16_t, xdata);           // Filter output
 115          SI_SEGMENT_VARIABLE(Phase_Add[12], unsigned int, xdata); // For the frequency sweep
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/18/2020 01:36:24 PAGE 3   

 116          SI_SEGMENT_VARIABLE(TimerForDC24Output, unsigned int, xdata);
 117          SI_SEGMENT_VARIABLE(DividerForDC24Output, unsigned int, xdata);
 118          //-----------------------------------------------------------------------------
 119          // Function Prototypes
 120          //-----------------------------------------------------------------------------
 121          
 122          void SYSCLK_Init (void);               // Configure system clock
 123          void PORT_Init (void);                 // Configure port output
 124          void UART0_Init (void);                // Configure UART operation
 125          void Timer0_Init(void);                // Configure Timer0
 126          void ADC0_Init (void);                 // Configure ADC
 127          void DAC0_Init(void);                  // Configure DAC0
 128          void DAC1_Init(void);                  // Configure DAC1
 129          void Timer3_Init (int counts);         // Configure Timer 3
 130          void Timer4_Init (int counts);         // Configure Timer 4
 131          void Set_DAC_Frequency (unsigned long frequency);
 132          void init_after_flash_reload();
 133          
 134          // Define the UART printing functions
 135          #if defined __C51__
 136          char putchar (char c);                 // Define putchar for Keil
 137          #elif defined SDCC
              void putchar (char c);
              #endif // defined SDCC
 140          
 141          SI_INTERRUPT_PROTO(UART0_ISR, INTERRUPT_UART0);
 142          SI_INTERRUPT_PROTO(TIMER0_ISR, INTERRUPT_TIMER0);
 143          SI_INTERRUPT_PROTO(ADC0_ISR, INTERRUPT_ADC0_EOC);
 144          // A full cycle, 16-bit, 2's complement sine wave lookup table
 145          //int code SINE_TABLE[256] = {
 146          SI_SEGMENT_VARIABLE(SINE_TABLE[256], int, code) = {
 147             0x0000, 0x0324, 0x0647, 0x096a, 0x0c8b, 0x0fab, 0x12c8, 0x15e2,
 148             0x18f8, 0x1c0b, 0x1f19, 0x2223, 0x2528, 0x2826, 0x2b1f, 0x2e11,
 149             0x30fb, 0x33de, 0x36ba, 0x398c, 0x3c56, 0x3f17, 0x41ce, 0x447a,
 150             0x471c, 0x49b4, 0x4c3f, 0x4ebf, 0x5133, 0x539b, 0x55f5, 0x5842,
 151             0x5a82, 0x5cb4, 0x5ed7, 0x60ec, 0x62f2, 0x64e8, 0x66cf, 0x68a6,
 152             0x6a6d, 0x6c24, 0x6dca, 0x6f5f, 0x70e2, 0x7255, 0x73b5, 0x7504,
 153             0x7641, 0x776c, 0x7884, 0x798a, 0x7a7d, 0x7b5d, 0x7c29, 0x7ce3,
 154             0x7d8a, 0x7e1d, 0x7e9d, 0x7f09, 0x7f62, 0x7fa7, 0x7fd8, 0x7ff6,
 155             0x7fff, 0x7ff6, 0x7fd8, 0x7fa7, 0x7f62, 0x7f09, 0x7e9d, 0x7e1d,
 156             0x7d8a, 0x7ce3, 0x7c29, 0x7b5d, 0x7a7d, 0x798a, 0x7884, 0x776c,
 157             0x7641, 0x7504, 0x73b5, 0x7255, 0x70e2, 0x6f5f, 0x6dca, 0x6c24,
 158             0x6a6d, 0x68a6, 0x66cf, 0x64e8, 0x62f2, 0x60ec, 0x5ed7, 0x5cb4,
 159             0x5a82, 0x5842, 0x55f5, 0x539b, 0x5133, 0x4ebf, 0x4c3f, 0x49b4,
 160             0x471c, 0x447a, 0x41ce, 0x3f17, 0x3c56, 0x398c, 0x36ba, 0x33de,
 161             0x30fb, 0x2e11, 0x2b1f, 0x2826, 0x2528, 0x2223, 0x1f19, 0x1c0b,
 162             0x18f8, 0x15e2, 0x12c8, 0x0fab, 0x0c8b, 0x096a, 0x0647, 0x0324,
 163             0x0000, 0xfcdc, 0xf9b9, 0xf696, 0xf375, 0xf055, 0xed38, 0xea1e,
 164             0xe708, 0xe3f5, 0xe0e7, 0xdddd, 0xdad8, 0xd7da, 0xd4e1, 0xd1ef,
 165             0xcf05, 0xcc22, 0xc946, 0xc674, 0xc3aa, 0xc0e9, 0xbe32, 0xbb86,
 166             0xb8e4, 0xb64c, 0xb3c1, 0xb141, 0xaecd, 0xac65, 0xaa0b, 0xa7be,
 167             0xa57e, 0xa34c, 0xa129, 0x9f14, 0x9d0e, 0x9b18, 0x9931, 0x975a,
 168             0x9593, 0x93dc, 0x9236, 0x90a1, 0x8f1e, 0x8dab, 0x8c4b, 0x8afc,
 169             0x89bf, 0x8894, 0x877c, 0x8676, 0x8583, 0x84a3, 0x83d7, 0x831d,
 170             0x8276, 0x81e3, 0x8163, 0x80f7, 0x809e, 0x8059, 0x8028, 0x800a,
 171             0x8000, 0x800a, 0x8028, 0x8059, 0x809e, 0x80f7, 0x8163, 0x81e3,
 172             0x8276, 0x831d, 0x83d7, 0x84a3, 0x8583, 0x8676, 0x877c, 0x8894,
 173             0x89bf, 0x8afc, 0x8c4b, 0x8dab, 0x8f1e, 0x90a1, 0x9236, 0x93dc,
 174             0x9593, 0x975a, 0x9931, 0x9b18, 0x9d0e, 0x9f14, 0xa129, 0xa34c,
 175             0xa57e, 0xa7be, 0xaa0b, 0xac65, 0xaecd, 0xb141, 0xb3c1, 0xb64c,
 176             0xb8e4, 0xbb86, 0xbe32, 0xc0e9, 0xc3aa, 0xc674, 0xc946, 0xcc22,
 177             0xcf05, 0xd1ef, 0xd4e1, 0xd7da, 0xdad8, 0xdddd, 0xe0e7, 0xe3f5,
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/18/2020 01:36:24 PAGE 4   

 178             0xe708, 0xea1e, 0xed38, 0xf055, 0xf375, 0xf696, 0xf9b9, 0xfcdc,
 179          };
 180          
 181          // Similar to STARTUP.A51 for Keil, this function stub for SDCC allows us to
 182          // disable the WDT before memory is initialized.
 183          #if defined SDCC
              void _sdcc_external_startup (void);
              
              void _sdcc_external_startup (void)
              {
                 WDTCN = 0xDE;                       // Disable watchdog timer
                 WDTCN = 0xAD;
              }
              #endif // defined SDCC
 192          
 193          //-----------------------------------------------------------------------------
 194          // MAIN Routine
 195          //-----------------------------------------------------------------------------
 196          
 197          void main (void)
 198          {
 199   1         //-----------------------------------------------------------------------------
 200   1         // FIR VARIABLES
 201   1         //-----------------------------------------------------------------------------
 202   1         static unsigned char delay_index = 0;
 203   1         SI_SEGMENT_VARIABLE(coeff_index, unsigned char, xdata);
 204   1         SI_SEGMENT_VARIABLE(sample_index, unsigned char, xdata);
 205   1         SI_SEGMENT_VARIABLE(opposite_sample_index, unsigned char, xdata);
 206   1         SI_SEGMENT_VARIABLE(i, int, xdata);
 207   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 208   1         unsigned int RMS_Value = 0;
 209   1        //------------------------------------------------------------------------------
 210   1         void (*init_func_pointer)(void) = init_after_flash_reload;
 211   1         //-----------------------------------------------------------------------------
 212   1         WDTCN = 0xDE;                       // Disable watchdog timer
 213   1         WDTCN = 0xAD;
 214   1      
 215   1         SYSCLK_Init ();                     // Initialize oscillator
 216   1         PORT_Init ();                       // Initialize crossbar and GPIO
 217   1         UART0_Init ();                      // Initialize UART0
 218   1         Timer0_Init ();
 219   1        
 220   1         // Initialize Timer3 to overflow at the ADC sample rate
 221   1         Timer3_Init (SYSCLK/SAMPLE_RATE);
 222   1        
 223   1         // Initialize Timer4 to overflow at the DAC sample rate
 224   1         Timer4_Init (SYSCLK/OUTPUT_RATE_DAC);  
 225   1        
 226   1         DAC0_Init ();                       // Initialize the DAC0
 227   1         DAC1_Init ();                       // Initialize the DAC1
 228   1         ADC0_Init ();                       // Initialize the ADC  
 229   1        
 230   1         SFRPAGE = ADC0_PAGE;
 231   1      
 232   1         AD0EN = 1;                          // Enable ADC
 233   1      
 234   1         SFRPAGE = MAC0_PAGE;
 235   1      
 236   1         MAC0CF = 0x06;                      // Fractional mode; Saturate
 237   1                                             // enabled
 238   1         data_for_filter_counter = 0;
 239   1         
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/18/2020 01:36:24 PAGE 5   

 240   1         //
 241   1         freq_number = 0;
 242   1         
 243   1         frequency = START_FREQUENCY;
 244   1         
 245   1         EA = 1;
 246   1        
 247   1         modbus_init_from_flash(init_func_pointer);
 248   1         
 249   1      //-----------------------------------------------------------------------------  
 250   1         while (1) {
 251   2            //-----------------------------------------------------------------------
 252   2            SFRPAGE_SAVE = SFRPAGE;
 253   2            SFRPAGE = CONFIG_PAGE;
 254   2            if (DC24INPUT == 0) {
 255   3              setDC24InputRegister(1);
 256   3            } else {
 257   3              setDC24InputRegister(0);
 258   3            }
 259   2            SFRPAGE = SFRPAGE_SAVE;
 260   2            //------------------------------------------------------------------------
 261   2            if (data_for_filter_counter == N) {
 262   3               for (freq_number=0; freq_number<12; freq_number++) {
 263   4                  delay_index = delay_index_arr [freq_number];
 264   4                  // Initialize the delay line for the FIR filter
 265   4                  for (i = 0; i < FILTER_MAX_ORDER; i++)
 266   4                  {
 267   5                     x[i].s16 = 0;
 268   5                  }
 269   4                  // Initialize the sample array
 270   4                  for (i = 0; i < N; i ++)
 271   4                  {
 272   5                     filtered_samples[i] = 0;
 273   5                     //printf("%d\n", data_for_filter[i].u16); 
 274   5                  }
 275   4                  //printf("--");
 276   4                  //printf("--");
 277   4                  //TI0 = 1;          
 278   4                  TAPS = populateFirCoefficients(B_FIR, freq_number);
 279   4                  if (TAPS != 61) {
 280   5                     NOP();
 281   5                  }
 282   4                  if (TAPS == 61) {
 283   5                    for (i=0; i<N; i++) {         
 284   6                       // Store ADC result in the delay line
 285   6                       x[delay_index].u16 = data_for_filter[i].u16;
 286   6                       // Sample_index points to newest data
 287   6                       sample_index = delay_index;         
 288   6                       // Update delay index
 289   6                       if (delay_index == (TAPS - 1))
 290   6                       {
 291   7                          delay_index = 0;
 292   7                       }
 293   6                       else
 294   6                       {
 295   7                          delay_index++;
 296   7                       }
 297   6      
 298   6                       MAC0CF |= 0x08;                  // Clear accumulator
 299   6                  
 300   6                       // Mirror algorithm
 301   6                       if (sample_index == TAPS - 1)
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/18/2020 01:36:24 PAGE 6   

 302   6                       {
 303   7                          opposite_sample_index = 0;
 304   7                       }
 305   6                       else
 306   6                       {
 307   7                          opposite_sample_index = sample_index + 1;
 308   7                       }
 309   6                       for (coeff_index = 0; coeff_index < (TAPS / 2); coeff_index++)
 310   6                       {
 311   7                          FIR_TAP_MIRROR (B_FIR[coeff_index].u16, x[sample_index],
 312   7                          x[opposite_sample_index]);
 313   7                         
 314   7                          if (sample_index == 0)
 315   7                          {
 316   8                             sample_index = TAPS - 1;
 317   8                          }
 318   7                          else
 319   7                          {
 320   8                             sample_index--;
 321   8                          }
 322   7      
 323   7                          if (opposite_sample_index == TAPS - 1)
 324   7                          {
 325   8                             opposite_sample_index = 0;
 326   8                          }
 327   7                          else
 328   7                          {
 329   8                             opposite_sample_index++;
 330   8                          }
 331   7                       }
 332   6                       if ((TAPS % 2) == 1)             // Handle middle tap of odd order filter
 333   6                       {
 334   7                          FIR_TAP (B_FIR[coeff_index].u16, x[sample_index]);
 335   7                          NOP ();
 336   7                          NOP ();
 337   7                          NOP ();
 338   7                       }
 339   6                       Sample.u16 = MAC0RND;
 340   6                       filtered_samples[i] = Sample.u16;
 341   6                    }
 342   5                    RMS_Value = RMS_Calc(filtered_samples, N, TAPS);
 343   5                    putRms2Modbus(RMS_Value, freq_number);
 344   5                    delay_index_arr [freq_number] = delay_index;
 345   5                  }
 346   4               }
 347   3               LED = !LED;
 348   3               data_for_filter_counter = 0;
 349   3            }
 350   2         }
 351   1      //-----------------------------------------------------------------------------  
 352   1      }
 353          
 354          //-----------------------------------------------------------------------------
 355          // Initialization Subroutines
 356          //-----------------------------------------------------------------------------
 357          
 358          //-----------------------------------------------------------------------------
 359          // SYSCLK_Init
 360          //-----------------------------------------------------------------------------
 361          //
 362          // Return Value:  None
 363          // Parameters:    None
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/18/2020 01:36:24 PAGE 7   

 364          //
 365          // This routine initializes the system clock to use the internal 24.5MHz*4
 366          // oscillator as its clock source.
 367          //
 368          //-----------------------------------------------------------------------------
 369          void SYSCLK_Init (void)
 370          {
 371   1         SI_SEGMENT_VARIABLE(i, char, xdata);
 372   1        
 373   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 374   1        
 375   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 376   1      
 377   1         SFRPAGE = CONFIG_PAGE;              // Switch to the necessary SFRPAGE
 378   1      
 379   1         OSCICN = 0x83;
 380   1      
 381   1         // Step 2. Set the PLLSRC bit (PLL0CN.2) to select the desired
 382   1         // clock source for the PLL.
 383   1         PLL0CN &= ~0x04;                    // Internal oscillator
 384   1      
 385   1         // Step 3. Program the Flash read timing bits, FLRT (FLSCL.5-4) to the
 386   1         // appropriate value for the new clock rate (see Section 15. Flash Memory
 387   1         // on page 199).
 388   1         SFRPAGE = LEGACY_PAGE;
 389   1         FLSCL |= 0x30;                      // >= 100 MHz
 390   1         SFRPAGE = CONFIG_PAGE;
 391   1      
 392   1         // Step 4. Enable power to the PLL by setting PLLPWR (PLL0CN.0) to ‘1’.
 393   1         PLL0CN |= 0x01;
 394   1      
 395   1         // Step 5. Program the PLL0DIV register to produce the divided reference
 396   1         // frequency to the PLL.
 397   1         PLL0DIV = 0x01;
 398   1      
 399   1         // Step 6. Program the PLLLP3-0 bits (PLL0FLT.3-0) to the appropriate
 400   1         // range for the divided reference frequency.
 401   1         PLL0FLT |= 0x01;
 402   1      
 403   1         // Step 7. Program the PLLICO1-0 bits (PLL0FLT.5-4) to the appropriate
 404   1         // range for the PLL output frequency.
 405   1         PLL0FLT &= ~0x30;
 406   1      
 407   1         // Step 8. Program the PLL0MUL register to the desired clock multiplication
 408   1         // factor.
 409   1         PLL0MUL = 0x04;
 410   1      
 411   1         // Step 9. Wait at least 5 µs, to provide a fast frequency lock.
 412   1         for (i = 100; i > 0; i--);
 413   1      
 414   1         // Step 10. Enable the PLL by setting PLLEN (PLL0CN.1) to ‘1’.
 415   1         PLL0CN |= 0x02;
 416   1      
 417   1         // Step 11. Poll PLLLCK (PLL0CN.4) until it changes from ‘0’ to ‘1’.
 418   1         while ((PLL0CN & 0x10) != 0x10);
 419   1      
 420   1         // Step 12. Switch the System Clock source to the PLL using the CLKSEL
 421   1         // register.
 422   1         CLKSEL = 0x02;
 423   1      
 424   1         SFRPAGE = SFRPAGE_SAVE;             // Restore the SFRPAGE
 425   1      }
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/18/2020 01:36:24 PAGE 8   

 426          
 427          //-----------------------------------------------------------------------------
 428          // PORT_Init
 429          //-----------------------------------------------------------------------------
 430          //
 431          // Return Value:  None
 432          // Parameters:    None
 433          //
 434          // Configure the Crossbar and GPIO ports.
 435          //
 436          // Pinout:
 437          //
 438          // P0.0 - UART TX1 (push-pull)
 439          // P0.1 - UART RX1
 440          //
 441          // P1.6 - LED (push-pull)
 442          //
 443          // DAC0 - DAC0 output
 444          //
 445          // AIN0.0 - ADC0 analog input
 446          //
 447          // Note: DAC0 and AIN0.0 must be tied together.
 448          //
 449          //-----------------------------------------------------------------------------
 450          void PORT_Init (void)
 451          {
 452   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata);
 453   1         SFRPAGE_save = SFRPAGE;             // Save the current SFRPAGE
 454   1      
 455   1         SFRPAGE = CONFIG_PAGE;              // Switch to the necessary SFRPAGE
 456   1      
 457   1         XBR0     = 0x04;
 458   1         XBR1     = 0x00;
 459   1         XBR2     = 0x40;                    // Enable crossbar and weak pull-up
 460   1                                             // Enable UART0
 461   1      
 462   1         P0MDOUT |= 0x01;                    // Set TX1 pin to push-pull
 463   1         P1MDOUT |= 0x40;                    // Set P1.6(LED) to push-pull
 464   1         
 465   1         P4MDOUT |= 0x04;                    // Set P4.2 to push-pull
 466   1         P4MDOUT &= ~0x08;                   // Set P4.3 to input
 467   1        
 468   1         P5MDOUT |= 0xFF;
 469   1         P6MDOUT |= 0xFF;
 470   1         P7MDOUT |= 0xFF;
 471   1         P5 =  0x00;
 472   1         P6 |= 0x0F;
 473   1         P7 =  0xFF;
 474   1         DC24OUTPUT = 1;
 475   1         DC24INPUT = 1;
 476   1        
 477   1         SFRPAGE = SFRPAGE_save;             // Restore the SFRPAGE
 478   1      }
 479          
 480          //-----------------------------------------------------------------------------
 481          // UART0_Init
 482          //-----------------------------------------------------------------------------
 483          void Timer0_Init(void)
 484          {
 485   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata);
 486   1        SFRPAGE_save = SFRPAGE;
 487   1        
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/18/2020 01:36:24 PAGE 9   

 488   1        SFRPAGE = TIMER01_PAGE;
 489   1        
 490   1        TMOD   &= 0xFD;
 491   1        TMOD   |= 0x01;
 492   1        TH0     = 0x00;
 493   1        TL0     = 0x00;
 494   1        ET0     = 1;
 495   1        TR0     = 1;
 496   1        CKCON  |= 0x08;
 497   1        SFRPAGE = SFRPAGE_save;
 498   1      }
 499          //-----------------------------------------------------------------------------
 500          // UART0_Init
 501          //-----------------------------------------------------------------------------
 502          //
 503          // Return Value:  None
 504          // Parameters:    None
 505          //
 506          // Configure the UART0 using Timer1, for <BAUDRATE> and 8-N-1.
 507          //
 508          //-----------------------------------------------------------------------------
 509          void UART0_Init (void)
 510          {
 511   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata); 
 512   1         SFRPAGE_save = SFRPAGE; // Save the current SFRPAGE
 513   1      
 514   1         SFRPAGE = UART0_PAGE;               // Switch to the necessary SFRPAGE
 515   1          
 516   1         SCON0  = 0x70;
 517   1         TMOD   = 0x20;
 518   1         TH1    = 0x5D;///0xE5;///0x5D;////0xE5;// - 115200;
 519   1         TR1    = 1;
 520   1         CKCON |= 0x10;
 521   1         PCON  |= 0x80;//SMOD0 = 1 
 522   1        
 523   1         TI0    = 0;                         // Indicate TX0 ready
 524   1         
 525   1         PS0    = 1;
 526   1        
 527   1         ES0    = 1; 
 528   1        
 529   1         SFRPAGE = SFRPAGE_save;             // Restore the SFRPAGE
 530   1      }
 531          //-----------------------------------------------------------------------------
 532          // DAC0_Init
 533          //-----------------------------------------------------------------------------
 534          //
 535          // Return Value:  None
 536          // Parameters:    None
 537          //
 538          // Configure DAC1 to update on Timer4 overflows.  VREF is already enabled by
 539          // the ADC initialization code.
 540          //
 541          //-----------------------------------------------------------------------------
 542          void DAC0_Init(void){
 543   1      
 544   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 545   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 546   1      
 547   1         SFRPAGE = DAC0_PAGE;
 548   1      
 549   1         DAC0CN = 0x94;                      // Enable DAC0 in left-justified mode
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/18/2020 01:36:24 PAGE 10  

 550   1                                             // managed by Timer4 overflows
 551   1      
 552   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 553   1      }
 554          
 555          //-----------------------------------------------------------------------------
 556          // DAC1_Init
 557          //-----------------------------------------------------------------------------
 558          //
 559          // Return Value:  None
 560          // Parameters:    None
 561          //
 562          // Configure DAC1 to update on write to DAC1H.  VREF is already enabled by
 563          // the ADC initialization code.
 564          //
 565          //-----------------------------------------------------------------------------
 566          void DAC1_Init(void){
 567   1      
 568   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 569   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 570   1      
 571   1         SFRPAGE = DAC1_PAGE;
 572   1      
 573   1         DAC1CN = 0x84;                      // Enable DAC1 in left-justified mode
 574   1                                             // managed by write data to DAC1H
 575   1         
 576   1         DAC1 = DAC1_VALUE;                  // Write to DAC1
 577   1      
 578   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 579   1      }
 580          
 581          //-----------------------------------------------------------------------------
 582          // ADC0_Init
 583          //-----------------------------------------------------------------------------
 584          //
 585          // Return Value:  None
 586          // Parameters:    None
 587          //
 588          // Configures ADC0 to make single-ended analog measurements on pin AIN0.0 for
 589          // the FIR filter.  Timer3 overflows are the conversion source and the data is
 590          // left-justified.  This function also enables the ADC end-of-conversion
 591          // interrupt and leaves the ADC disabled.
 592          //
 593          //-----------------------------------------------------------------------------
 594          void ADC0_Init (void)
 595          {
 596   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 597   1        
 598   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 599   1      
 600   1         SFRPAGE = ADC0_PAGE;
 601   1      
 602   1         ADC0CN = 0x05;                      // ADC0 disabled; normal tracking
 603   1                                             // mode; ADC0 conversions are initiated
 604   1                                             // on overflow of Timer3; ADC0 data is
 605   1                                             // left-justified
 606   1      
 607   1         REF0CN = 0x03;                      // Enable on-chip VREF and VREF output
 608   1                                             // buffer
 609   1      #ifndef BIPOLIAR_ADC
 610   1         AMX0SL = 0x00;                      // Select AIN0.0 as ADC mux input
 611   1      #else 
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/18/2020 01:36:24 PAGE 11  

                 AMX0CF = 0x01;
                 AMX0SL = 0x00;
              #endif
 615   1        
 616   1         ADC0CF = (SYSCLK/2500000) << 3;     // ADC conversion clock = 2.5MHz
 617   1      
 618   1         EIE2 |= 0x02;                       // Enable ADC interrupts
 619   1      
 620   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 621   1      }
 622          
 623          //-----------------------------------------------------------------------------
 624          // Timer3_Init
 625          //-----------------------------------------------------------------------------
 626          //
 627          // Return Value:  None
 628          // Parameters:    None
 629          //
 630          // Configure Timer3 to auto-reload at interval specified by <counts> (no
 631          // interrupt generated) using SYSCLK as its time base.
 632          //
 633          // Timer 3 overflow automatically triggers ADC0 conversion.
 634          //
 635          //-----------------------------------------------------------------------------
 636          void Timer3_Init (int counts)
 637          {
 638   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 639   1        
 640   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 641   1      
 642   1         SFRPAGE = TMR3_PAGE;
 643   1      
 644   1         TMR3CN = 0x00;                      // Stop Timer3; Clear TF3;
 645   1         TMR3CF = 0x08;                      // use SYSCLK as timebase
 646   1      
 647   1         RCAP3   = -counts;                  // Init reload values
 648   1         TMR3    = RCAP3;                    // set to reload immediately
 649   1         EIE2   &= ~0x01;                    // Disable Timer3 interrupts
 650   1         TR3 = 1;                            // Start Timer3
 651   1      
 652   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 653   1      }
 654          //-----------------------------------------------------------------------------
 655          // Timer4_Init
 656          //-----------------------------------------------------------------------------
 657          //
 658          // Return Value:  None
 659          // Parameters:
 660          //   1) counts - the number of timer clocks to count before a timer interrupt
 661          //           should occur
 662          //
 663          // Configure Timer4 to auto-reload mode and to generate interrupts
 664          // at intervals specified in <counts> using SYSCLK as its time base.
 665          //
 666          // Timer 4 overflow controls the DAC update rate.
 667          //
 668          //-----------------------------------------------------------------------------
 669          void Timer4_Init (int counts)
 670          {
 671   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 672   1        
 673   1         SFRPAGE_SAVE = SFRPAGE;          // Save Current SFR page
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/18/2020 01:36:24 PAGE 12  

 674   1      
 675   1         SFRPAGE = TMR4_PAGE;
 676   1      
 677   1         TMR4CN = 0x00;                   // Stop Timer4; Clear overflow flag (TF4);
 678   1                                          // Set to Auto-Reload Mode
 679   1      
 680   1         TMR4CF = 0x08;                   // Configure Timer4 to increment;
 681   1                                          // Timer4 counts SYSCLKs
 682   1      
 683   1         RCAP4 = -counts;                 // Set reload value
 684   1         TMR4 = RCAP4;                    // Initialzie Timer4 to reload value
 685   1        
 686   1         EIE2 |= 0x04;                    // Enable Timer4 interrupts
 687   1         TR4 = 1;                         // Start Timer4
 688   1      
 689   1         SFRPAGE = SFRPAGE_SAVE;          // Restore SFR page
 690   1      }
 691          //-----------------------------------------------------------------------------
 692          // ADC0_ISR
 693          //-----------------------------------------------------------------------------
 694          //
 695          // ADC0 end-of-conversion ISR
 696          //
 697          // This interrupt service routine is called on ADC0 conversion complete.
 698          // The ADC result is converted to signed and stored in the FIR delay line.
 699          //
 700          // If the global <FIR_On> bit is set to a '1', then the FIR output is computed
 701          // and stored in the global variable 'Sample'.  The 'Sample_Ready' indicator
 702          // bit is set to indicate the value is ready.
 703          //
 704          // If <FIR_On> is set to '0', then the ADC sample is copied to the global
 705          // 'Sample' variable.  The 'Sample_Ready' indicator bit is set to indicate
 706          // that the value is ready.
 707          //
 708          //-----------------------------------------------------------------------------
 709          //void ADC0_ISR (void) interrupt 15
 710          #pragma NOAREGS
 711          SI_INTERRUPT(ADC0_ISR, INTERRUPT_ADC0_EOC)
 712          {
 713   1         volatile SI_UU16_t input;
 714   1        
 715   1         AD0INT = 0;                         // Clear ADC conversion complete
 716   1                                             // indicator
 717   1      
 718   1         input.s16 = ADC0^0x8000;            // Convert to bipolar value
 719   1         
 720   1         
 721   1         if (data_for_filter_counter < N) {
 722   2            data_for_filter [data_for_filter_counter++].u16 = input.u16;
 723   2         }
 724   1      }
 725          
 726          #pragma NOAREGS
 727          SI_INTERRUPT(TIMER0_ISR, INTERRUPT_TIMER0)
 728          {
 729   1        unsigned char SFRPAGE_save = SFRPAGE;
 730   1        SFRPAGE = TIMER01_PAGE;
 731   1        TH0     = 0x00;
 732   1        TL0     = 0x00;
 733   1        TF0     = 0;
 734   1        SFRPAGE = SFRPAGE_save;
 735   1        if(modbus_was_sendind_received()) {
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/18/2020 01:36:24 PAGE 13  

 736   2          modbus_command_received();
 737   2          SFRPAGE = CONFIG_PAGE;
 738   2          LED485  = !LED485;
 739   2        }
 740   1        SFRPAGE = CONFIG_PAGE;
 741   1        if (DC24OUTPUT == 0) {
 742   2          if (TimerForDC24Output++ % DividerForDC24Output == 0) {
 743   3            DC24OUTPUT = 1;
 744   3          }
 745   2        }
 746   1        SFRPAGE = SFRPAGE_save;
 747   1      }
 748          
 749          #pragma NOAREGS
 750          SI_INTERRUPT(UART0_ISR, INTERRUPT_UART0)
 751          {
 752   1        unsigned char SFRPAGE_save = SFRPAGE; // Save the current SFRPAGE
 753   1        SFRPAGE = UART0_PAGE;
 754   1        if(RI0 == 1) {
 755   2          modbus_byte_receive(SBUF0);
 756   2          RI0 = 0;
 757   2        }
 758   1        if(TI0 == 1) {
 759   2          TI0 = 0;
 760   2          if (modbus_transmit_buffer_is_empty()) {
 761   3          }
 762   2          else {
 763   3            modbus_transmit_byte();
 764   3          }
 765   2        }
 766   1        SFRPAGE = SFRPAGE_save;               // Restore the SFRPAGE  
 767   1      }
 768          //-----------------------------------------------------------------------------
 769          // Timer4_ISR
 770          //-----------------------------------------------------------------------------
 771          //
 772          // This ISR is called on Timer4 overflows.  Timer4 is set to auto-reload mode
 773          // and is used to schedule the DAC output sample rate in this example.
 774          // Note that the value that is written to DAC1 during this ISR call is
 775          // actually transferred to DAC1 at the next Timer4 overflow.
 776          //
 777          //-----------------------------------------------------------------------------
 778          //void Timer4_ISR (void) interrupt 16
 779          #pragma NOAREGS
 780          SI_INTERRUPT(Timer4_ISR, INTERRUPT_TIMER4)
 781          { 
 782   1         char number = 0;
 783   1         int temp1 = 0;                      // The temporary value that passes
 784   1                                             // through 3 stages before being written
 785   1                                             // to the IDAC
 786   1         TMR3CN &= ~0x80;                    // Clear Timer3 overflow flag
 787   1        
 788   1         for (number=0; number<12; number++) {
 789   2            if (freq_dac_flags [number] == 1) {
 790   3              phase_acc[number].u16 += Phase_Add [number];
 791   3              temp1 += (SINE_TABLE[phase_acc[number].u8[MSB]] / freq_divider);
 792   3            }
 793   2         }
 794   1           
 795   1         SFRPAGE = DAC0_PAGE;
 796   1      
 797   1         // Add a DC bias to make the rails 0 to 65535
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/18/2020 01:36:24 PAGE 14  

 798   1         // Note: the XOR with 0x8000 translates the bipolar quantity into
 799   1         // a unipolar quantity.
 800   1      
 801   1         DAC0 = 0x8000 ^ temp1;              // Write to DAC0
 802   1      }
 803          
 804          #pragma NOAREGS
 805          void init_after_flash_reload() {
 806   1         //-----------------------------------------------------------------------
 807   1         SI_SEGMENT_VARIABLE(i, uint8_t, xdata);
 808   1         SI_SEGMENT_VARIABLE(d, uint8_t, xdata);
 809   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 810   1         //-----------------------------------------------------------------------
 811   1         SFRPAGE_save = SFRPAGE;
 812   1         d = 0;
 813   1         //----------------------- FREQ DIVIDER INIT -----------------------------
 814   1         freq_divider = modbus_get_freq_divider();
 815   1         if (freq_divider == 0) {
 816   2            freq_divider = 1;
 817   2         }
 818   1         //--------------------------- FREQ INIT ---------------------------------
 819   1         modbus_init_freqs(FREQS);
 820   1         for (i=0; i<12; i++) {
 821   2            Phase_Add [i] = (unsigned int)((unsigned long)((FREQS [i] *
 822   2                      PHASE_PRECISION) / OUTPUT_RATE_DAC));
 823   2            if (getFreqFromModbusForDAC(i) != 0) {
 824   3               freq_dac_flags [i] = 1;
 825   3               if (i < 8) {
 826   4                  d = bit_set(d, i);
 827   4               }
 828   3            } else {
 829   3               freq_dac_flags [i] = 0;
 830   3            }
 831   2         }
 832   1         SFRPAGE = CONFIG_PAGE;
 833   1         //-----------------------------------------------------------------------
 834   1         // CLEAR - INVERSE LOGIC
 835   1         P7 =  0xFF;
 836   1         if ((d & CMD_1) == (uint8_t)CMD_1) {
 837   2            bit_clear_P7(0);
 838   2         }
 839   1         if ((d & CMD_2) == CMD_2) {
 840   2            bit_clear_P7(1);
 841   2         }
 842   1         if ((d & CMD_3) == CMD_3) {
 843   2            bit_clear_P7(2);
 844   2         }
 845   1         if ((d & CMD_4) == CMD_4) {
 846   2            bit_clear_P7(3);
 847   2         }
 848   1         if ((d & CMD_5) == CMD_5) {
 849   2            bit_clear_P7(4);
 850   2         }
 851   1         if ((d & CMD_6) == CMD_6) {
 852   2            bit_clear_P7(5);
 853   2         }
 854   1         //--------------------------------------------------------------------------
 855   1         d = getDC24DurationTimeIfEnabed();
 856   1         if (d != 0) {
 857   2           DC24OUTPUT = 0;
 858   2           DividerForDC24Output = d * SECOND_INTERVAL;
 859   2           TimerForDC24Output = 1;
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/18/2020 01:36:24 PAGE 15  

 860   2         }
 861   1         SFRPAGE = SFRPAGE_save;
 862   1         //--------------------------------------------------------------------------
 863   1      }
 864          //-----------------------------------------------------------------------------
 865          // putchar
 866          //-----------------------------------------------------------------------------
 867          //
 868          // Return Value:
 869          //   1) char c - returns the char c that was passed as a parameter
 870          // Parameters:
 871          //   1) char c - the character to be printed
 872          //
 873          // Print the character <c> using UART0 at <BAUDRATE>.
 874          //
 875          //-----------------------------------------------------------------------------
 876          #if defined __C51__
 877          char putchar (char c)
 878          #elif defined SDCC
              void putchar (char c)
              #endif
 881          {
 882   1         modbus_push_transmit_buffer(c);
 883   1      #if defined __C51__
 884   1         return c;                           // Print the character
 885   1      #endif
 886   1      }
 887          //-----------------------------------------------------------------------------
 888          // End Of File
 889          //-----------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2015    ----
   CONSTANT SIZE    =    512    ----
   XDATA SIZE       =   2379      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
