C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/04/2020 02:22:24 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE C8051F12X_FIR_DEMO
OBJECT MODULE PLACED IN C8051F12x_FIR_Demo.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE C8051F12x_FIR_Demo.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // Includes
   3          //-----------------------------------------------------------------------------
   4          
   5          #include "si_toolchain.h"             // Compiler-specific declarations
   6                                                 // (Keil/SDCC)
   7          #include "C8051F120_defs.h"            // SFR declarations
   8          #include <stdio.h>
   9          #include <math.h>
  10          #include "fir.h"
  11          #include "modbus.h"
  12          
  13          //-------------------------- BIPOLIAR SELECTOR --------------------------------
  14          //#define BIPOLIAR_ADC
  15          //-----------------------------------------------------------------------------
  16          
  17          //-----------------------------------------------------------------------------
  18          // Global Constants
  19          //-----------------------------------------------------------------------------
  20          
  21          #define BAUDRATE     115200            // Baud rate of UART in bps
  22          
  23          #define INTCLK       24500000          // Internal oscillator frequency in Hz    
  24          
  25          #define SYSCLK       98000000          // Output of PLL derived from (INTCLK*2)
  26          
  27          #define SAMPLE_RATE  11000             // Sample frequency in Hz
  28          
  29          #define N            500               // Number of samples to capture at
  30                                                 // each DAC frequency
  31          
  32          #define PHASE_PRECISION  65536         // Range of phase accumulator
  33          
  34          #define OUTPUT_RATE_DAC  20000L        // DAC output rate in Hz
  35          
  36          #define START_FREQUENCY  10            // Define the starting frequency
  37          #define STOP_FREQUENCY   4999          // Define the ending frequency
  38          #define FREQ_STEP        10            // Define the number of Hz the frequency
  39                                                 // will step for the frequency sweep
  40          #define DAC1_VALUE       0x8000        // value for DAC1                                       
  41                                                 
  42          //-----------------------------------------------------------------------------
  43          // Macros
  44          //-----------------------------------------------------------------------------
  45          
  46          #if defined __C51__
  47          #include <intrins.h>
  48          #define NOP() \
*** WARNING C317 IN LINE 49 OF C8051F12x_FIR_Demo.c: attempt to redefine macro 'NOP'
  49             _nop_();
  50          #elif defined SDCC
              #define NOP() \
                 _asm \
                 nop \
                 _endasm;
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/04/2020 02:22:24 PAGE 2   

              #endif // defined SDCC
  56          
  57          // Single FIR_TAP macro takes advantage of mirroring
  58          // (i.e. the FIR coefficients are mirrored, so the coefficient only needs to be
  59          // loaded into the MAC registers once).
  60          #define FIR_TAP_MIRROR(X,Y,Z) \
  61             MAC0A = X; \
  62             MAC0BH = Y.u8[MSB]; \
  63             MAC0BL = Y.u8[LSB]; \
  64             MAC0BH = Z.u8[MSB]; \
  65             MAC0BL = Z.u8[LSB];
  66          
  67          // Single FIR_TAP macro
  68          #define FIR_TAP(X,Y) \
  69             MAC0A = X; \
  70             MAC0BH = Y.u8[MSB]; \
  71             MAC0BL = Y.u8[LSB];
  72          
  73          #define BREAK_MACRO \
  74             SFRPAGE = UART0_PAGE; \
  75             if(TI0 == 1 || RI0 == 1){ \
  76               break; \
  77             } \
  78             SFRPAGE = SFRPAGE_save;
  79          
  80          //-----------------------------------------------------------------------------
  81          // Global Variables
  82          //-----------------------------------------------------------------------------
  83          // For the FIR filter
  84          // 'x' holds the 'delay line' of input samples
  85          //idata SI_UU16_t x[TAPS];
  86          SI_SEGMENT_VARIABLE(x[FILTER_MAX_ORDER], SI_UU16_t, xdata);
  87          SI_SEGMENT_VARIABLE(B_FIR[FILTER_MAX_ORDER], SI_UU16_t, xdata);
  88          SI_SEGMENT_VARIABLE(TAPS, unsigned int, xdata);
  89          SI_SEGMENT_VARIABLE(data_for_filter[N], SI_UU16_t, xdata);
  90          SI_SEGMENT_VARIABLE(data_for_filter_counter, int, xdata);
  91          SI_SEGMENT_VARIABLE(filtered_samples[N], int, xdata);
  92          SI_SEGMENT_VARIABLE(freq_number, unsigned char, xdata);
  93          SI_SEGMENT_VARIABLE(phase_acc[12], SI_UU16_t, xdata) = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  94          SI_SEGMENT_VARIABLE(FREQS[12], unsigned long, xdata) = {1343, 1445, 1547, 1649, 1751, 1853, 1955, 2057, 21
             -59, 2261, 2363, 2465};
  95          SI_SEGMENT_VARIABLE(frequency, unsigned long, xdata);
  96          SI_SEGMENT_VARIABLE(delay_index_arr[12], unsigned char, xdata) = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  97          SI_SEGMENT_VARIABLE(freq_divider, unsigned char, xdata);
  98          SI_SEGMENT_VARIABLE(freq_dac_flags[12], unsigned char, xdata);
  99          
 100          sbit LED = P1^6;                                     // LED='1' means ON
 101          
 102          SI_SEGMENT_VARIABLE(Sample, SI_UU16_t, xdata);       // Filter output
 103          SI_SEGMENT_VARIABLE(Phase_Add[12], unsigned int, xdata); // For the frequency sweep
 104          //-----------------------------------------------------------------------------
 105          // Function Prototypes
 106          //-----------------------------------------------------------------------------
 107          
 108          void SYSCLK_Init (void);               // Configure system clock
 109          void PORT_Init (void);                 // Configure port output
 110          void UART0_Init (void);                // Configure UART operation
 111          void Timer0_Init(void);                // Configure Timer0
 112          void ADC0_Init (void);                 // Configure ADC
 113          void DAC0_Init(void);                  // Configure DAC0
 114          void DAC1_Init(void);                  // Configure DAC1
 115          void Timer3_Init (int counts);         // Configure Timer 3
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/04/2020 02:22:24 PAGE 3   

 116          void Timer4_Init (int counts);         // Configure Timer 4
 117          void Set_DAC_Frequency (unsigned long frequency);
 118          void init_after_flash_reload();
 119          
 120          // Define the UART printing functions
 121          #if defined __C51__
 122          char putchar (char c);                 // Define putchar for Keil
 123          #elif defined SDCC
              void putchar (char c);
              #endif // defined SDCC
 126          
 127          SI_INTERRUPT_PROTO(UART0_ISR, INTERRUPT_UART0);
 128          SI_INTERRUPT_PROTO(TIMER0_ISR, INTERRUPT_TIMER0);
 129          SI_INTERRUPT_PROTO(ADC0_ISR, INTERRUPT_ADC0_EOC);
 130          // A full cycle, 16-bit, 2's complement sine wave lookup table
 131          //int code SINE_TABLE[256] = {
 132          SI_SEGMENT_VARIABLE(SINE_TABLE[256], int, code) = {
 133             0x0000, 0x0324, 0x0647, 0x096a, 0x0c8b, 0x0fab, 0x12c8, 0x15e2,
 134             0x18f8, 0x1c0b, 0x1f19, 0x2223, 0x2528, 0x2826, 0x2b1f, 0x2e11,
 135             0x30fb, 0x33de, 0x36ba, 0x398c, 0x3c56, 0x3f17, 0x41ce, 0x447a,
 136             0x471c, 0x49b4, 0x4c3f, 0x4ebf, 0x5133, 0x539b, 0x55f5, 0x5842,
 137             0x5a82, 0x5cb4, 0x5ed7, 0x60ec, 0x62f2, 0x64e8, 0x66cf, 0x68a6,
 138             0x6a6d, 0x6c24, 0x6dca, 0x6f5f, 0x70e2, 0x7255, 0x73b5, 0x7504,
 139             0x7641, 0x776c, 0x7884, 0x798a, 0x7a7d, 0x7b5d, 0x7c29, 0x7ce3,
 140             0x7d8a, 0x7e1d, 0x7e9d, 0x7f09, 0x7f62, 0x7fa7, 0x7fd8, 0x7ff6,
 141             0x7fff, 0x7ff6, 0x7fd8, 0x7fa7, 0x7f62, 0x7f09, 0x7e9d, 0x7e1d,
 142             0x7d8a, 0x7ce3, 0x7c29, 0x7b5d, 0x7a7d, 0x798a, 0x7884, 0x776c,
 143             0x7641, 0x7504, 0x73b5, 0x7255, 0x70e2, 0x6f5f, 0x6dca, 0x6c24,
 144             0x6a6d, 0x68a6, 0x66cf, 0x64e8, 0x62f2, 0x60ec, 0x5ed7, 0x5cb4,
 145             0x5a82, 0x5842, 0x55f5, 0x539b, 0x5133, 0x4ebf, 0x4c3f, 0x49b4,
 146             0x471c, 0x447a, 0x41ce, 0x3f17, 0x3c56, 0x398c, 0x36ba, 0x33de,
 147             0x30fb, 0x2e11, 0x2b1f, 0x2826, 0x2528, 0x2223, 0x1f19, 0x1c0b,
 148             0x18f8, 0x15e2, 0x12c8, 0x0fab, 0x0c8b, 0x096a, 0x0647, 0x0324,
 149             0x0000, 0xfcdc, 0xf9b9, 0xf696, 0xf375, 0xf055, 0xed38, 0xea1e,
 150             0xe708, 0xe3f5, 0xe0e7, 0xdddd, 0xdad8, 0xd7da, 0xd4e1, 0xd1ef,
 151             0xcf05, 0xcc22, 0xc946, 0xc674, 0xc3aa, 0xc0e9, 0xbe32, 0xbb86,
 152             0xb8e4, 0xb64c, 0xb3c1, 0xb141, 0xaecd, 0xac65, 0xaa0b, 0xa7be,
 153             0xa57e, 0xa34c, 0xa129, 0x9f14, 0x9d0e, 0x9b18, 0x9931, 0x975a,
 154             0x9593, 0x93dc, 0x9236, 0x90a1, 0x8f1e, 0x8dab, 0x8c4b, 0x8afc,
 155             0x89bf, 0x8894, 0x877c, 0x8676, 0x8583, 0x84a3, 0x83d7, 0x831d,
 156             0x8276, 0x81e3, 0x8163, 0x80f7, 0x809e, 0x8059, 0x8028, 0x800a,
 157             0x8000, 0x800a, 0x8028, 0x8059, 0x809e, 0x80f7, 0x8163, 0x81e3,
 158             0x8276, 0x831d, 0x83d7, 0x84a3, 0x8583, 0x8676, 0x877c, 0x8894,
 159             0x89bf, 0x8afc, 0x8c4b, 0x8dab, 0x8f1e, 0x90a1, 0x9236, 0x93dc,
 160             0x9593, 0x975a, 0x9931, 0x9b18, 0x9d0e, 0x9f14, 0xa129, 0xa34c,
 161             0xa57e, 0xa7be, 0xaa0b, 0xac65, 0xaecd, 0xb141, 0xb3c1, 0xb64c,
 162             0xb8e4, 0xbb86, 0xbe32, 0xc0e9, 0xc3aa, 0xc674, 0xc946, 0xcc22,
 163             0xcf05, 0xd1ef, 0xd4e1, 0xd7da, 0xdad8, 0xdddd, 0xe0e7, 0xe3f5,
 164             0xe708, 0xea1e, 0xed38, 0xf055, 0xf375, 0xf696, 0xf9b9, 0xfcdc,
 165          };
 166          
 167          // Similar to STARTUP.A51 for Keil, this function stub for SDCC allows us to
 168          // disable the WDT before memory is initialized.
 169          #if defined SDCC
              void _sdcc_external_startup (void);
              
              void _sdcc_external_startup (void)
              {
                 WDTCN = 0xDE;                       // Disable watchdog timer
                 WDTCN = 0xAD;
              }
              #endif // defined SDCC
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/04/2020 02:22:24 PAGE 4   

 178          
 179          //-----------------------------------------------------------------------------
 180          // MAIN Routine
 181          //-----------------------------------------------------------------------------
 182          
 183          void main (void)
 184          {
 185   1         //-----------------------------------------------------------------------------
 186   1         // FIR VARIABLES
 187   1         //-----------------------------------------------------------------------------
 188   1         static unsigned char delay_index = 0;
 189   1         SI_SEGMENT_VARIABLE(coeff_index, unsigned char, xdata);
 190   1         SI_SEGMENT_VARIABLE(sample_index, unsigned char, xdata);
 191   1         SI_SEGMENT_VARIABLE(opposite_sample_index, unsigned char, xdata);
 192   1         SI_SEGMENT_VARIABLE(i, int, xdata);
 193   1         //-----------------------------------------------------------------------------
 194   1         int count = 0;
 195   1         float average = 0;
 196   1         float RMS_summation = 0;
 197   1         float RMS_Value;
 198   1         float temp;
 199   1         //-----------------------------------------------------------------------------
 200   1         void (*init_func_pointer)(void) = init_after_flash_reload;
 201   1         //-----------------------------------------------------------------------------
 202   1         
 203   1         WDTCN = 0xDE;                       // Disable watchdog timer
 204   1         WDTCN = 0xAD;
 205   1      
 206   1         SYSCLK_Init ();                     // Initialize oscillator
 207   1         PORT_Init ();                       // Initialize crossbar and GPIO
 208   1         UART0_Init ();                      // Initialize UART0
 209   1         Timer0_Init ();
 210   1        
 211   1         // Initialize Timer3 to overflow at the ADC sample rate
 212   1         Timer3_Init (SYSCLK/SAMPLE_RATE);
 213   1        
 214   1         // Initialize Timer4 to overflow at the DAC sample rate
 215   1         Timer4_Init (SYSCLK/OUTPUT_RATE_DAC);  
 216   1        
 217   1         DAC0_Init ();                       // Initialize the DAC0
 218   1         DAC1_Init ();                       // Initialize the DAC1
 219   1         ADC0_Init ();                       // Initialize the ADC  
 220   1        
 221   1         SFRPAGE = ADC0_PAGE;
 222   1      
 223   1         AD0EN = 1;                          // Enable ADC
 224   1      
 225   1         SFRPAGE = MAC0_PAGE;
 226   1      
 227   1         MAC0CF = 0x06;                      // Fractional mode; Saturate
 228   1                                             // enabled
 229   1         data_for_filter_counter = 0;
 230   1         
 231   1         //
 232   1         freq_number = 0;
 233   1         
 234   1         frequency = START_FREQUENCY;
 235   1         
 236   1         EA = 1;
 237   1        
 238   1         modbus_init_from_flash(init_func_pointer);
 239   1         
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/04/2020 02:22:24 PAGE 5   

 240   1      //-----------------------------------------------------------------------------  
 241   1         while (1) {
 242   2            if (data_for_filter_counter == N) {
 243   3               for (freq_number=0; freq_number<12; freq_number++) {
 244   4                  delay_index = delay_index_arr [freq_number];
 245   4                  // Initialize the delay line for the FIR filter
 246   4                  for (i = 0; i < FILTER_MAX_ORDER; i++)
 247   4                  {
 248   5                     x[i].s16 = 0;
 249   5                  }
 250   4                  // Initialize the sample array
 251   4                  for (i = 0; i < N; i ++)
 252   4                  {
 253   5                     filtered_samples[i] = 0;
 254   5                  }   
 255   4                  TAPS = populateFirCoefficients(B_FIR, freq_number);
 256   4                  if (TAPS > FILTER_MAX_ORDER || TAPS == 0) {
 257   5                     TAPS = 10;
 258   5                  }
 259   4                  for (i=0; i<N; i++) {         
 260   5                     // Store ADC result in the delay line
 261   5                     x[delay_index].u16 = data_for_filter[i].u16;
 262   5                     // Sample_index points to newest data
 263   5                     sample_index = delay_index;         
 264   5                     // Update delay index
 265   5                     if (delay_index == (TAPS - 1))
 266   5                     {
 267   6                        delay_index = 0;
 268   6                     }
 269   5                     else
 270   5                     {
 271   6                        delay_index++;
 272   6                     }
 273   5      
 274   5                     MAC0CF |= 0x08;                  // Clear accumulator
 275   5                
 276   5                     // Mirror algorithm
 277   5                     if (sample_index == TAPS - 1)
 278   5                     {
 279   6                        opposite_sample_index = 0;
 280   6                     }
 281   5                     else
 282   5                     {
 283   6                        opposite_sample_index = sample_index + 1;
 284   6                     }
 285   5                     for (coeff_index = 0; coeff_index < (TAPS / 2); coeff_index++)
 286   5                     {
 287   6                        //EA=0;
 288   6                        FIR_TAP_MIRROR (B_FIR[coeff_index].u16, x[sample_index],
 289   6                        x[opposite_sample_index]);
 290   6                        //EA=1;
 291   6                       
 292   6                        if (sample_index == 0)
 293   6                        {
 294   7                           sample_index = TAPS - 1;
 295   7                        }
 296   6                        else
 297   6                        {
 298   7                           sample_index--;
 299   7                        }
 300   6      
 301   6                        if (opposite_sample_index == TAPS - 1)
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/04/2020 02:22:24 PAGE 6   

 302   6                        {
 303   7                           opposite_sample_index = 0;
 304   7                        }
 305   6                        else
 306   6                        {
 307   7                           opposite_sample_index++;
 308   7                        }
 309   6                     }    
 310   5                     if ((TAPS % 2) == 1)             // Handle middle tap of odd order filter
 311   5                     {
 312   6                        //EA=0;
 313   6                        FIR_TAP (B_FIR[coeff_index].u16, x[sample_index]);
 314   6                        //EA=1;
 315   6                        NOP ();
 316   6                        NOP ();
 317   6                        NOP ();
 318   6                     }
 319   5                     Sample.u16 = MAC0RND;
 320   5                     filtered_samples[i] = Sample.u16;
 321   5                  }
 322   4                  //---------------------------------------------------------------------
 323   4                  average = 0.0;
 324   4      
 325   4                  for (count = TAPS; count < N; count++)
 326   4                  {
 327   5                    average += (float) filtered_samples[count];
 328   5                  }
 329   4                  average = (float)(average / (N-TAPS));
 330   4      
 331   4                  // Calculate the RMS Value using the average computed above
 332   4                  // Calculate the sum from 1 to N of (x-x_avg)^2
 333   4                  for (count = TAPS; count < N; count++)
 334   4                  {
 335   5                    // calculate difference from mean
 336   5                    temp = filtered_samples[count] - average;
 337   5                    // square it
 338   5                    temp *= temp;
 339   5                    // and add it to sum
 340   5                    RMS_summation += temp;
 341   5                  }
 342   4                  // Calculate sum from above / N
 343   4                  RMS_summation = (float)RMS_summation / (N-TAPS);
 344   4                  RMS_Value = RMS_summation / 20000;
 345   4                  //---------------------------------------------------------------------
 346   4                  putRms2Modbus(RMS_Value, freq_number);
 347   4                  delay_index_arr [freq_number] = delay_index;
 348   4               }
 349   3               LED = !LED;
 350   3               data_for_filter_counter = 0;
 351   3            }
 352   2         }
 353   1      //-----------------------------------------------------------------------------  
 354   1      }
 355          
 356          //-----------------------------------------------------------------------------
 357          // Initialization Subroutines
 358          //-----------------------------------------------------------------------------
 359          
 360          //-----------------------------------------------------------------------------
 361          // SYSCLK_Init
 362          //-----------------------------------------------------------------------------
 363          //
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/04/2020 02:22:24 PAGE 7   

 364          // Return Value:  None
 365          // Parameters:    None
 366          //
 367          // This routine initializes the system clock to use the internal 24.5MHz*4
 368          // oscillator as its clock source.
 369          //
 370          //-----------------------------------------------------------------------------
 371          void SYSCLK_Init (void)
 372          {
 373   1         SI_SEGMENT_VARIABLE(i, char, xdata);
 374   1        
 375   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 376   1        
 377   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 378   1      
 379   1         SFRPAGE = CONFIG_PAGE;              // Switch to the necessary SFRPAGE
 380   1      
 381   1         OSCICN = 0x83;
 382   1      
 383   1         // Step 2. Set the PLLSRC bit (PLL0CN.2) to select the desired
 384   1         // clock source for the PLL.
 385   1         PLL0CN &= ~0x04;                    // Internal oscillator
 386   1      
 387   1         // Step 3. Program the Flash read timing bits, FLRT (FLSCL.5-4) to the
 388   1         // appropriate value for the new clock rate (see Section 15. Flash Memory
 389   1         // on page 199).
 390   1         SFRPAGE = LEGACY_PAGE;
 391   1         FLSCL |= 0x30;                      // >= 100 MHz
 392   1         SFRPAGE = CONFIG_PAGE;
 393   1      
 394   1         // Step 4. Enable power to the PLL by setting PLLPWR (PLL0CN.0) to ‘1’.
 395   1         PLL0CN |= 0x01;
 396   1      
 397   1         // Step 5. Program the PLL0DIV register to produce the divided reference
 398   1         // frequency to the PLL.
 399   1         PLL0DIV = 0x01;
 400   1      
 401   1         // Step 6. Program the PLLLP3-0 bits (PLL0FLT.3-0) to the appropriate
 402   1         // range for the divided reference frequency.
 403   1         PLL0FLT |= 0x01;
 404   1      
 405   1         // Step 7. Program the PLLICO1-0 bits (PLL0FLT.5-4) to the appropriate
 406   1         // range for the PLL output frequency.
 407   1         PLL0FLT &= ~0x30;
 408   1      
 409   1         // Step 8. Program the PLL0MUL register to the desired clock multiplication
 410   1         // factor.
 411   1         PLL0MUL = 0x04;
 412   1      
 413   1         // Step 9. Wait at least 5 µs, to provide a fast frequency lock.
 414   1         for (i = 100; i > 0; i--);
 415   1      
 416   1         // Step 10. Enable the PLL by setting PLLEN (PLL0CN.1) to ‘1’.
 417   1         PLL0CN |= 0x02;
 418   1      
 419   1         // Step 11. Poll PLLLCK (PLL0CN.4) until it changes from ‘0’ to ‘1’.
 420   1         while ((PLL0CN & 0x10) != 0x10);
 421   1      
 422   1         // Step 12. Switch the System Clock source to the PLL using the CLKSEL
 423   1         // register.
 424   1         CLKSEL = 0x02;
 425   1      
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/04/2020 02:22:24 PAGE 8   

 426   1         SFRPAGE = SFRPAGE_SAVE;             // Restore the SFRPAGE
 427   1      }
 428          
 429          //-----------------------------------------------------------------------------
 430          // PORT_Init
 431          //-----------------------------------------------------------------------------
 432          //
 433          // Return Value:  None
 434          // Parameters:    None
 435          //
 436          // Configure the Crossbar and GPIO ports.
 437          //
 438          // Pinout:
 439          //
 440          // P0.0 - UART TX1 (push-pull)
 441          // P0.1 - UART RX1
 442          //
 443          // P1.6 - LED (push-pull)
 444          //
 445          // DAC0 - DAC0 output
 446          //
 447          // AIN0.0 - ADC0 analog input
 448          //
 449          // Note: DAC0 and AIN0.0 must be tied together.
 450          //
 451          //-----------------------------------------------------------------------------
 452          void PORT_Init (void)
 453          {
 454   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata);
 455   1         SFRPAGE_save = SFRPAGE;             // Save the current SFRPAGE
 456   1      
 457   1         SFRPAGE = CONFIG_PAGE;              // Switch to the necessary SFRPAGE
 458   1      
 459   1         XBR0     = 0x04;
 460   1         XBR1     = 0x00;
 461   1         XBR2     = 0x40;                    // Enable crossbar and weak pull-up
 462   1                                             // Enable UART0
 463   1      
 464   1         P0MDOUT |= 0x01;                    // Set TX1 pin to push-pull
 465   1         P1MDOUT |= 0x40;                    // Set P1.6(LED) to push-pull
 466   1        
 467   1         SFRPAGE = SFRPAGE_save;             // Restore the SFRPAGE
 468   1      }
 469          
 470          //-----------------------------------------------------------------------------
 471          // UART0_Init
 472          //-----------------------------------------------------------------------------
 473          void Timer0_Init(void)
 474          {
 475   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata);
 476   1        SFRPAGE_save = SFRPAGE;
 477   1        
 478   1        SFRPAGE = TIMER01_PAGE;
 479   1        
 480   1        TMOD   &= 0xFD;
 481   1        TMOD   |= 0x01;
 482   1        TH0     = 0x00;
 483   1        TL0     = 0x00;
 484   1        ET0     = 1;
 485   1        TR0     = 1;
 486   1        CKCON  |= 0x08;
 487   1        SFRPAGE = SFRPAGE_save;
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/04/2020 02:22:24 PAGE 9   

 488   1      }
 489          //-----------------------------------------------------------------------------
 490          // UART0_Init
 491          //-----------------------------------------------------------------------------
 492          //
 493          // Return Value:  None
 494          // Parameters:    None
 495          //
 496          // Configure the UART0 using Timer1, for <BAUDRATE> and 8-N-1.
 497          //
 498          //-----------------------------------------------------------------------------
 499          void UART0_Init (void)
 500          {
 501   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata); 
 502   1         SFRPAGE_save = SFRPAGE; // Save the current SFRPAGE
 503   1      
 504   1         SFRPAGE = UART0_PAGE;               // Switch to the necessary SFRPAGE
 505   1          
 506   1         SCON0  = 0x70;
 507   1         TMOD   = 0x20;
 508   1         TH1    = 0x5D;///0xE5;///0x5D;////0xE5;// - 115200;
 509   1         TR1    = 1;
 510   1         CKCON |= 0x10;
 511   1         PCON  |= 0x80;//SMOD0 = 1 
 512   1        
 513   1         TI0    = 0;                         // Indicate TX0 ready
 514   1         
 515   1         PS0    = 1;
 516   1        
 517   1         ES0    = 1; 
 518   1        
 519   1         SFRPAGE = SFRPAGE_save;             // Restore the SFRPAGE
 520   1      }
 521          //-----------------------------------------------------------------------------
 522          // DAC0_Init
 523          //-----------------------------------------------------------------------------
 524          //
 525          // Return Value:  None
 526          // Parameters:    None
 527          //
 528          // Configure DAC1 to update on Timer4 overflows.  VREF is already enabled by
 529          // the ADC initialization code.
 530          //
 531          //-----------------------------------------------------------------------------
 532          void DAC0_Init(void){
 533   1      
 534   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 535   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 536   1      
 537   1         SFRPAGE = DAC0_PAGE;
 538   1      
 539   1         DAC0CN = 0x94;                      // Enable DAC0 in left-justified mode
 540   1                                             // managed by Timer4 overflows
 541   1      
 542   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 543   1      }
 544          
 545          //-----------------------------------------------------------------------------
 546          // DAC1_Init
 547          //-----------------------------------------------------------------------------
 548          //
 549          // Return Value:  None
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/04/2020 02:22:24 PAGE 10  

 550          // Parameters:    None
 551          //
 552          // Configure DAC1 to update on write to DAC1H.  VREF is already enabled by
 553          // the ADC initialization code.
 554          //
 555          //-----------------------------------------------------------------------------
 556          void DAC1_Init(void){
 557   1      
 558   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 559   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 560   1      
 561   1         SFRPAGE = DAC1_PAGE;
 562   1      
 563   1         DAC1CN = 0x84;                      // Enable DAC1 in left-justified mode
 564   1                                             // managed by write data to DAC1H
 565   1         
 566   1         DAC1 = DAC1_VALUE;                  // Write to DAC1
 567   1      
 568   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 569   1      }
 570          
 571          //-----------------------------------------------------------------------------
 572          // ADC0_Init
 573          //-----------------------------------------------------------------------------
 574          //
 575          // Return Value:  None
 576          // Parameters:    None
 577          //
 578          // Configures ADC0 to make single-ended analog measurements on pin AIN0.0 for
 579          // the FIR filter.  Timer3 overflows are the conversion source and the data is
 580          // left-justified.  This function also enables the ADC end-of-conversion
 581          // interrupt and leaves the ADC disabled.
 582          //
 583          //-----------------------------------------------------------------------------
 584          void ADC0_Init (void)
 585          {
 586   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 587   1        
 588   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 589   1      
 590   1         SFRPAGE = ADC0_PAGE;
 591   1      
 592   1         ADC0CN = 0x05;                      // ADC0 disabled; normal tracking
 593   1                                             // mode; ADC0 conversions are initiated
 594   1                                             // on overflow of Timer3; ADC0 data is
 595   1                                             // left-justified
 596   1      
 597   1         REF0CN = 0x03;                      // Enable on-chip VREF and VREF output
 598   1                                             // buffer
 599   1      #ifndef BIPOLIAR_ADC
 600   1         AMX0SL = 0x00;                      // Select AIN0.0 as ADC mux input
 601   1      #else 
                 AMX0CF = 0x01;
                 AMX0SL = 0x00;
              #endif
 605   1        
 606   1         ADC0CF = (SYSCLK/2500000) << 3;     // ADC conversion clock = 2.5MHz
 607   1      
 608   1         EIE2 |= 0x02;                       // Enable ADC interrupts
 609   1      
 610   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 611   1      }
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/04/2020 02:22:24 PAGE 11  

 612          
 613          //-----------------------------------------------------------------------------
 614          // Timer3_Init
 615          //-----------------------------------------------------------------------------
 616          //
 617          // Return Value:  None
 618          // Parameters:    None
 619          //
 620          // Configure Timer3 to auto-reload at interval specified by <counts> (no
 621          // interrupt generated) using SYSCLK as its time base.
 622          //
 623          // Timer 3 overflow automatically triggers ADC0 conversion.
 624          //
 625          //-----------------------------------------------------------------------------
 626          void Timer3_Init (int counts)
 627          {
 628   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 629   1        
 630   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 631   1      
 632   1         SFRPAGE = TMR3_PAGE;
 633   1      
 634   1         TMR3CN = 0x00;                      // Stop Timer3; Clear TF3;
 635   1         TMR3CF = 0x08;                      // use SYSCLK as timebase
 636   1      
 637   1         RCAP3   = -counts;                  // Init reload values
 638   1         TMR3    = RCAP3;                    // set to reload immediately
 639   1         EIE2   &= ~0x01;                    // Disable Timer3 interrupts
 640   1         TR3 = 1;                            // Start Timer3
 641   1      
 642   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 643   1      }
 644          //-----------------------------------------------------------------------------
 645          // Timer4_Init
 646          //-----------------------------------------------------------------------------
 647          //
 648          // Return Value:  None
 649          // Parameters:
 650          //   1) counts - the number of timer clocks to count before a timer interrupt
 651          //           should occur
 652          //
 653          // Configure Timer4 to auto-reload mode and to generate interrupts
 654          // at intervals specified in <counts> using SYSCLK as its time base.
 655          //
 656          // Timer 4 overflow controls the DAC update rate.
 657          //
 658          //-----------------------------------------------------------------------------
 659          void Timer4_Init (int counts)
 660          {
 661   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 662   1        
 663   1         SFRPAGE_SAVE = SFRPAGE;          // Save Current SFR page
 664   1      
 665   1         SFRPAGE = TMR4_PAGE;
 666   1      
 667   1         TMR4CN = 0x00;                   // Stop Timer4; Clear overflow flag (TF4);
 668   1                                          // Set to Auto-Reload Mode
 669   1      
 670   1         TMR4CF = 0x08;                   // Configure Timer4 to increment;
 671   1                                          // Timer4 counts SYSCLKs
 672   1      
 673   1         RCAP4 = -counts;                 // Set reload value
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/04/2020 02:22:24 PAGE 12  

 674   1         TMR4 = RCAP4;                    // Initialzie Timer4 to reload value
 675   1        
 676   1         EIE2 |= 0x04;                    // Enable Timer4 interrupts
 677   1         TR4 = 1;                         // Start Timer4
 678   1      
 679   1         SFRPAGE = SFRPAGE_SAVE;          // Restore SFR page
 680   1      }
 681          //-----------------------------------------------------------------------------
 682          // ADC0_ISR
 683          //-----------------------------------------------------------------------------
 684          //
 685          // ADC0 end-of-conversion ISR
 686          //
 687          // This interrupt service routine is called on ADC0 conversion complete.
 688          // The ADC result is converted to signed and stored in the FIR delay line.
 689          //
 690          // If the global <FIR_On> bit is set to a '1', then the FIR output is computed
 691          // and stored in the global variable 'Sample'.  The 'Sample_Ready' indicator
 692          // bit is set to indicate the value is ready.
 693          //
 694          // If <FIR_On> is set to '0', then the ADC sample is copied to the global
 695          // 'Sample' variable.  The 'Sample_Ready' indicator bit is set to indicate
 696          // that the value is ready.
 697          //
 698          //-----------------------------------------------------------------------------
 699          //void ADC0_ISR (void) interrupt 15
 700          SI_INTERRUPT(ADC0_ISR, INTERRUPT_ADC0_EOC)
 701          {
 702   1         volatile SI_UU16_t input;
 703   1        
 704   1         AD0INT = 0;                         // Clear ADC conversion complete
 705   1                                             // indicator
 706   1      
 707   1         input.s16 = ADC0^0x8000;            // Convert to bipolar value
 708   1         
 709   1         
 710   1         if (data_for_filter_counter < N) {
 711   2            data_for_filter [data_for_filter_counter++].u16 = input.u16;
 712   2         }
 713   1      }
 714          
 715          SI_INTERRUPT(TIMER0_ISR, INTERRUPT_TIMER0)
 716          {
 717   1        unsigned char SFRPAGE_save = SFRPAGE;
 718   1        SFRPAGE = TIMER01_PAGE;
 719   1        TH0     = 0x00;
 720   1        TL0     = 0x00;
 721   1        TF0     = 0;
 722   1        SFRPAGE = SFRPAGE_save;
 723   1        if(modbus_was_sendind_received()) {
 724   2          modbus_command_received();
 725   2          LED     = !LED;
 726   2        }
 727   1        SFRPAGE = SFRPAGE_save;
 728   1      }
 729          
 730          SI_INTERRUPT(UART0_ISR, INTERRUPT_UART0)
 731          {
 732   1        unsigned char SFRPAGE_save = SFRPAGE; // Save the current SFRPAGE
 733   1        SFRPAGE = UART0_PAGE;
 734   1        if(RI0 == 1) {
 735   2          //SFRPAGE = TMR4_PAGE;
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/04/2020 02:22:24 PAGE 13  

 736   2          //TR4 = 0;
 737   2          //SFRPAGE = UART0_PAGE;
 738   2          //AD0EN = 0;
 739   2          modbus_byte_receive(SBUF0);
 740   2          RI0 = 0;
 741   2        }
 742   1        if(TI0 == 1) {
 743   2          TI0 = 0;
 744   2          if (modbus_transmit_buffer_is_empty()) {
 745   3          }
 746   2          else {
 747   3            modbus_transmit_byte();
 748   3          }
 749   2        }
 750   1        SFRPAGE = SFRPAGE_save;               // Restore the SFRPAGE  
 751   1      }
 752          //-----------------------------------------------------------------------------
 753          // Timer4_ISR
 754          //-----------------------------------------------------------------------------
 755          //
 756          // This ISR is called on Timer4 overflows.  Timer4 is set to auto-reload mode
 757          // and is used to schedule the DAC output sample rate in this example.
 758          // Note that the value that is written to DAC1 during this ISR call is
 759          // actually transferred to DAC1 at the next Timer4 overflow.
 760          //
 761          //-----------------------------------------------------------------------------
 762          //void Timer4_ISR (void) interrupt 16
 763          SI_INTERRUPT(Timer4_ISR, INTERRUPT_TIMER4)
 764          { 
 765   1         char number = 0;
 766   1         int temp1 = 0;                      // The temporary value that passes
 767   1                                             // through 3 stages before being written
 768   1                                             // to the IDAC
 769   1         TMR3CN &= ~0x80;                    // Clear Timer3 overflow flag
 770   1        
 771   1         for (number=0; number<12; number++) {
 772   2            if (freq_dac_flags [number] == 1) {
 773   3              phase_acc[number].u16 += Phase_Add [number];
 774   3              temp1 += (SINE_TABLE[phase_acc[number].u8[MSB]] / freq_divider);
 775   3            }
 776   2         }
 777   1        
 778   1         //LED = !LED;
 779   1         
 780   1         SFRPAGE = DAC0_PAGE;
 781   1      
 782   1         // Add a DC bias to make the rails 0 to 65535
 783   1         // Note: the XOR with 0x8000 translates the bipolar quantity into
 784   1         // a unipolar quantity.
 785   1      
 786   1         DAC0 = 0x8000 ^ temp1;              // Write to DAC0
 787   1      }
 788          void init_after_flash_reload() {
 789   1         //-----------------------------------------------------------------------
 790   1         SI_SEGMENT_VARIABLE(i, char, xdata);
 791   1         //----------------------- FREQ DIVIDER INIT -----------------------------
 792   1         freq_divider = modbus_get_freq_divider();
 793   1         if (freq_divider == 0) {
 794   2            freq_divider = 1;
 795   2         }
 796   1         //--------------------------- FREQ INIT ---------------------------------
 797   1         modbus_init_freqs(FREQS);
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/04/2020 02:22:24 PAGE 14  

 798   1         //-----------------------------------------------------------------------
 799   1         for (i=0; i<12; i++) {
 800   2            Phase_Add [i] = (unsigned int)((unsigned long)((FREQS [i] *
 801   2                      PHASE_PRECISION) / OUTPUT_RATE_DAC));
 802   2            if (getFreqFromModbusForDAC(i) != 0) {
 803   3               freq_dac_flags [i] = 1;
 804   3            } else {
 805   3               freq_dac_flags [i] = 0;
 806   3            }
 807   2         }
 808   1         //-----------------------------------------------------------------------
 809   1      }
 810          
 811          //-----------------------------------------------------------------------------
 812          // putchar
 813          //-----------------------------------------------------------------------------
 814          //
 815          // Return Value:
 816          //   1) char c - returns the char c that was passed as a parameter
 817          // Parameters:
 818          //   1) char c - the character to be printed
 819          //
 820          // Print the character <c> using UART0 at <BAUDRATE>.
 821          //
 822          //-----------------------------------------------------------------------------
 823          #if defined __C51__
 824          char putchar (char c)
 825          #elif defined SDCC
              void putchar (char c)
              #endif
 828          {
 829   1         modbus_push_transmit_buffer(c);
 830   1      #if defined __C51__
 831   1         return c;                           // Print the character
 832   1      #endif
 833   1      }
 834          //-----------------------------------------------------------------------------
 835          // End Of File
 836          //-----------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2184    ----
   CONSTANT SIZE    =    512    ----
   XDATA SIZE       =   2376      16
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      28
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
