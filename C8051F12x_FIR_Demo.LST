C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                08/03/2020 23:29:47 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE C8051F12X_FIR_DEMO
OBJECT MODULE PLACED IN C8051F12x_FIR_Demo.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE C8051F12x_FIR_Demo.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // Includes
   3          //-----------------------------------------------------------------------------
   4          
   5          #include "si_toolchain.h"             // Compiler-specific declarations
   6                                                 // (Keil/SDCC)
   7          #include "C8051F120_defs.h"            // SFR declarations
   8          #include <stdio.h>
   9          #include <math.h>
  10          #include "fir.h"
  11          #include "modbus.h"
  12          
  13          //-------------------------- BIPOLIAR SELECTOR --------------------------------
  14          //#define BIPOLIAR_ADC
  15          //-----------------------------------------------------------------------------
  16          
  17          //-----------------------------------------------------------------------------
  18          // Global Constants
  19          //-----------------------------------------------------------------------------
  20          
  21          #define BAUDRATE     115200            // Baud rate of UART in bps
  22          
  23          #define INTCLK       24500000          // Internal oscillator frequency in Hz    
  24          
  25          #define SYSCLK       98000000          // Output of PLL derived from (INTCLK*2)
  26          
  27          #define SAMPLE_RATE  11000             // Sample frequency in Hz
  28          
  29          #define N            500               // Number of samples to capture at
  30                                                 // each DAC frequency
  31          
  32          #define PHASE_PRECISION  65536         // Range of phase accumulator
  33          
  34          #define OUTPUT_RATE_DAC  20000L        // DAC output rate in Hz
  35          
  36          #define START_FREQUENCY  10            // Define the starting frequency
  37          #define STOP_FREQUENCY   4999          // Define the ending frequency
  38          #define FREQ_STEP        10            // Define the number of Hz the frequency
  39                                                 // will step for the frequency sweep
  40          #define DAC1_VALUE       0x8000        // value for DAC1
  41          #define SECOND_INTERVAL  1024
  42          #define MILLISECONDS_10  10
  43          //-----------------------------------------------------------------------------
  44          // Macros
  45          //-----------------------------------------------------------------------------
  46          
  47          #if defined __C51__
  48          #include <intrins.h>
  49          #define NOP() \
*** WARNING C317 IN LINE 50 OF C8051F12x_FIR_Demo.c: attempt to redefine macro 'NOP'
  50             _nop_();
  51          #elif defined SDCC
              #define NOP() \
                 _asm \
                 nop \
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                08/03/2020 23:29:47 PAGE 2   

                 _endasm;
              #endif // defined SDCC
  57          
  58          // Single FIR_TAP macro takes advantage of mirroring
  59          // (i.e. the FIR coefficients are mirrored, so the coefficient only needs to be
  60          // loaded into the MAC registers once).
  61          #define FIR_TAP_MIRROR(X,Y,Z) \
  62             MAC0A = X; \
  63             MAC0BH = Y.u8[MSB]; \
  64             MAC0BL = Y.u8[LSB]; \
  65             MAC0BH = Z.u8[MSB]; \
  66             MAC0BL = Z.u8[LSB];
  67          
  68          // Single FIR_TAP macro
  69          #define FIR_TAP(X,Y) \
  70             MAC0A = X; \
  71             MAC0BH = Y.u8[MSB]; \
  72             MAC0BL = Y.u8[LSB];
  73          
  74          #define BREAK_MACRO \
  75             SFRPAGE = UART0_PAGE; \
  76             if(TI0 == 1 || RI0 == 1){ \
  77               break; \
  78             } \
  79             SFRPAGE = SFRPAGE_save;
  80          
  81          //-----------------------------------------------------------------------------
  82          // Global Variables
  83          //-----------------------------------------------------------------------------
  84          // For the FIR filter
  85          // 'x' holds the 'delay line' of input samples
  86          //idata SI_UU16_t x[TAPS];
  87          SI_SEGMENT_VARIABLE(x[FILTER_MAX_ORDER], SI_UU16_t, xdata);
  88          SI_SEGMENT_VARIABLE(B_FIR[FILTER_MAX_ORDER], SI_UU16_t, xdata);
  89          SI_SEGMENT_VARIABLE(TAPS, uint8_t, xdata);
  90          SI_SEGMENT_VARIABLE(data_for_filter[N], SI_UU16_t, xdata);
  91          SI_SEGMENT_VARIABLE(data_for_filter_counter, int, xdata);
  92          SI_SEGMENT_VARIABLE(filtered_samples[N], int, xdata);
  93          SI_SEGMENT_VARIABLE(freq_number, unsigned char, xdata);
  94          SI_SEGMENT_VARIABLE(phase_acc[12], SI_UU16_t, xdata) = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  95          SI_SEGMENT_VARIABLE(FREQS[12], unsigned long, xdata) = {1343, 1445, 1547, 1649, 1751, 1853, 1955, 2057, 21
             -59, 2261, 2363, 2465};
  96          SI_SEGMENT_VARIABLE(frequency, unsigned long, xdata);
  97          SI_SEGMENT_VARIABLE(delay_index_arr[12], unsigned char, xdata) = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  98          SI_SEGMENT_VARIABLE(freq_divider, unsigned char, xdata);
  99          SI_SEGMENT_VARIABLE(freq_dac_flags[12], unsigned char, xdata);
 100          
 101          sbit LED = P1^6;                                         // LED='1' means ON
 102          sbit LED485 = P7^7;                                      // LED for 485
 103          sbit SELECT485 = P4^4;                                   // Select 485 transmit/receive
 104          
 105          SI_SEGMENT_VARIABLE(Sample, SI_UU16_t, xdata);           // Filter output
 106          SI_SEGMENT_VARIABLE(Phase_Add[12], unsigned int, xdata); // For the frequency sweep
 107          SI_SEGMENT_VARIABLE(TimerForDC24Output, unsigned int, xdata);
 108          SI_SEGMENT_VARIABLE(DividerForDC24Output, unsigned int, xdata);
 109          SI_SEGMENT_VARIABLE(isNeedGetADCValuesFlag, unsigned int, xdata);
 110          SI_SEGMENT_VARIABLE(TIMER, unsigned short, xdata);
 111          SI_SEGMENT_VARIABLE(modbus_16_post_func_invoke_flag, uint8_t, xdata);
 112          SI_SEGMENT_VARIABLE(FOUND_1_OR_2_FREQ_FLAG, extern uint8_t, xdata);
 113          //-----------------------------------------------------------------------------
 114          // Function Prototypes
 115          //-----------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                08/03/2020 23:29:47 PAGE 3   

 116          
 117          void SYSCLK_Init (void);               // Configure system clock
 118          void PORT_Init (void);                 // Configure port output
 119          void UART0_Init (void);                // Configure UART operation
 120          void Timer0_Init(void);                // Configure Timer0
 121          void ADC0_Init (void);                 // Configure ADC
 122          void DAC0_Init(void);                  // Configure DAC0
 123          void DAC1_Init(void);                  // Configure DAC1
 124          void Timer3_Init (int counts);         // Configure Timer 3
 125          void Timer4_Init (int counts);         // Configure Timer 4
 126          void Set_DAC_Frequency (unsigned long frequency);
 127          void init_after_flash_reload();
 128          void delay(unsigned short timer);
 129          void toTransmit485();
 130          void toReceive485();
 131          
 132          // Define the UART printing functions
 133          #if defined __C51__
 134          char putchar (char c);                 // Define putchar for Keil
 135          #elif defined SDCC
              void putchar (char c);
              #endif // defined SDCC
 138          
 139          SI_INTERRUPT_PROTO(UART0_ISR, INTERRUPT_UART0);
 140          SI_INTERRUPT_PROTO(TIMER0_ISR, INTERRUPT_TIMER0);
 141          SI_INTERRUPT_PROTO(ADC0_ISR, INTERRUPT_ADC0_EOC);
 142          // A full cycle, 16-bit, 2's complement sine wave lookup table
 143          //int code SINE_TABLE[256] = {
 144          SI_SEGMENT_VARIABLE(SINE_TABLE[256], int, code) = {
 145             0x0000, 0x0324, 0x0647, 0x096a, 0x0c8b, 0x0fab, 0x12c8, 0x15e2,
 146             0x18f8, 0x1c0b, 0x1f19, 0x2223, 0x2528, 0x2826, 0x2b1f, 0x2e11,
 147             0x30fb, 0x33de, 0x36ba, 0x398c, 0x3c56, 0x3f17, 0x41ce, 0x447a,
 148             0x471c, 0x49b4, 0x4c3f, 0x4ebf, 0x5133, 0x539b, 0x55f5, 0x5842,
 149             0x5a82, 0x5cb4, 0x5ed7, 0x60ec, 0x62f2, 0x64e8, 0x66cf, 0x68a6,
 150             0x6a6d, 0x6c24, 0x6dca, 0x6f5f, 0x70e2, 0x7255, 0x73b5, 0x7504,
 151             0x7641, 0x776c, 0x7884, 0x798a, 0x7a7d, 0x7b5d, 0x7c29, 0x7ce3,
 152             0x7d8a, 0x7e1d, 0x7e9d, 0x7f09, 0x7f62, 0x7fa7, 0x7fd8, 0x7ff6,
 153             0x7fff, 0x7ff6, 0x7fd8, 0x7fa7, 0x7f62, 0x7f09, 0x7e9d, 0x7e1d,
 154             0x7d8a, 0x7ce3, 0x7c29, 0x7b5d, 0x7a7d, 0x798a, 0x7884, 0x776c,
 155             0x7641, 0x7504, 0x73b5, 0x7255, 0x70e2, 0x6f5f, 0x6dca, 0x6c24,
 156             0x6a6d, 0x68a6, 0x66cf, 0x64e8, 0x62f2, 0x60ec, 0x5ed7, 0x5cb4,
 157             0x5a82, 0x5842, 0x55f5, 0x539b, 0x5133, 0x4ebf, 0x4c3f, 0x49b4,
 158             0x471c, 0x447a, 0x41ce, 0x3f17, 0x3c56, 0x398c, 0x36ba, 0x33de,
 159             0x30fb, 0x2e11, 0x2b1f, 0x2826, 0x2528, 0x2223, 0x1f19, 0x1c0b,
 160             0x18f8, 0x15e2, 0x12c8, 0x0fab, 0x0c8b, 0x096a, 0x0647, 0x0324,
 161             0x0000, 0xfcdc, 0xf9b9, 0xf696, 0xf375, 0xf055, 0xed38, 0xea1e,
 162             0xe708, 0xe3f5, 0xe0e7, 0xdddd, 0xdad8, 0xd7da, 0xd4e1, 0xd1ef,
 163             0xcf05, 0xcc22, 0xc946, 0xc674, 0xc3aa, 0xc0e9, 0xbe32, 0xbb86,
 164             0xb8e4, 0xb64c, 0xb3c1, 0xb141, 0xaecd, 0xac65, 0xaa0b, 0xa7be,
 165             0xa57e, 0xa34c, 0xa129, 0x9f14, 0x9d0e, 0x9b18, 0x9931, 0x975a,
 166             0x9593, 0x93dc, 0x9236, 0x90a1, 0x8f1e, 0x8dab, 0x8c4b, 0x8afc,
 167             0x89bf, 0x8894, 0x877c, 0x8676, 0x8583, 0x84a3, 0x83d7, 0x831d,
 168             0x8276, 0x81e3, 0x8163, 0x80f7, 0x809e, 0x8059, 0x8028, 0x800a,
 169             0x8000, 0x800a, 0x8028, 0x8059, 0x809e, 0x80f7, 0x8163, 0x81e3,
 170             0x8276, 0x831d, 0x83d7, 0x84a3, 0x8583, 0x8676, 0x877c, 0x8894,
 171             0x89bf, 0x8afc, 0x8c4b, 0x8dab, 0x8f1e, 0x90a1, 0x9236, 0x93dc,
 172             0x9593, 0x975a, 0x9931, 0x9b18, 0x9d0e, 0x9f14, 0xa129, 0xa34c,
 173             0xa57e, 0xa7be, 0xaa0b, 0xac65, 0xaecd, 0xb141, 0xb3c1, 0xb64c,
 174             0xb8e4, 0xbb86, 0xbe32, 0xc0e9, 0xc3aa, 0xc674, 0xc946, 0xcc22,
 175             0xcf05, 0xd1ef, 0xd4e1, 0xd7da, 0xdad8, 0xdddd, 0xe0e7, 0xe3f5,
 176             0xe708, 0xea1e, 0xed38, 0xf055, 0xf375, 0xf696, 0xf9b9, 0xfcdc,
 177          };
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                08/03/2020 23:29:47 PAGE 4   

 178          
 179          // Similar to STARTUP.A51 for Keil, this function stub for SDCC allows us to
 180          // disable the WDT before memory is initialized.
 181          #if defined SDCC
              void _sdcc_external_startup (void);
              
              void _sdcc_external_startup (void)
              {
                 WDTCN = 0xDE;                       // Disable watchdog timer
                 WDTCN = 0xAD;
              }
              #endif // defined SDCC
 190          
 191          //-----------------------------------------------------------------------------
 192          // MAIN Routine
 193          //-----------------------------------------------------------------------------
 194          
 195          void main (void)
 196          {
 197   1         //-----------------------------------------------------------------------------
 198   1         // FIR VARIABLES
 199   1         //-----------------------------------------------------------------------------
 200   1         static unsigned char delay_index = 0;
 201   1         SI_SEGMENT_VARIABLE(coeff_index, unsigned char, xdata);
 202   1         SI_SEGMENT_VARIABLE(sample_index, unsigned char, xdata);
 203   1         SI_SEGMENT_VARIABLE(opposite_sample_index, unsigned char, xdata);
 204   1         SI_SEGMENT_VARIABLE(i, int, xdata);
 205   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 206   1         SI_SEGMENT_VARIABLE(hi, uint8_t, xdata);
 207   1         SI_SEGMENT_VARIABLE(lo, uint8_t, xdata);
 208   1         SI_SEGMENT_VARIABLE(freq_quantity, uint8_t, xdata);
 209   1         unsigned int RMS_Value = 0;
 210   1        //------------------------------------------------------------------------------
 211   1         void (*init_func_pointer)(void) = init_after_flash_reload;
 212   1         //-----------------------------------------------------------------------------
 213   1         WDTCN = 0xDE;                       // Disable watchdog timer
 214   1         WDTCN = 0xAD;
 215   1      
 216   1         SYSCLK_Init ();                     // Initialize oscillator
 217   1         PORT_Init ();                       // Initialize crossbar and GPIO
 218   1         UART0_Init ();                      // Initialize UART0
 219   1         Timer0_Init ();
 220   1        
 221   1         // Initialize Timer3 to overflow at the ADC sample rate
 222   1         Timer3_Init (SYSCLK/SAMPLE_RATE);
 223   1        
 224   1         // Initialize Timer4 to overflow at the DAC sample rate
 225   1         Timer4_Init (SYSCLK/OUTPUT_RATE_DAC);  
 226   1        
 227   1         DAC0_Init ();                       // Initialize the DAC0
 228   1         DAC1_Init ();                       // Initialize the DAC1
 229   1         ADC0_Init ();                       // Initialize the ADC  
 230   1        
 231   1         SFRPAGE = ADC0_PAGE;
 232   1      
 233   1         AD0EN = 1;                          // Enable ADC
 234   1      
 235   1         SFRPAGE = MAC0_PAGE;
 236   1      
 237   1         MAC0CF = 0x06;                      // Fractional mode; Saturate
 238   1                                             // enabled
 239   1         data_for_filter_counter = 0;
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                08/03/2020 23:29:47 PAGE 5   

 240   1         
 241   1         //
 242   1         freq_number = 0;
 243   1         
 244   1         frequency = START_FREQUENCY;
 245   1         
 246   1         isNeedGetADCValuesFlag = 0;
 247   1         
 248   1         EA = 1;
 249   1        
 250   1         modbus_init_from_flash(init_func_pointer);
 251   1         
 252   1         modbus_16_post_func_invoke_flag = FALSE;
 253   1         
 254   1         FOUND_1_OR_2_FREQ_FLAG = FALSE;
 255   1         
 256   1         //------------------------------------------------------------------------
 257   1         // DP VERSION !!!!!!!!!!!!!!!!! FOR FAST REASON !!!!!!!!!!!!!!!!!!!!!!!!!!
 258   1         freq_quantity = 2;
 259   1      //-----------------------------------------------------------------------------  
 260   1         while (1) {
 261   2            //-----------------------------------------------------------------------
 262   2            if (modbus_16_post_func_invoke_flag == TRUE) {
 263   3               EA = 0; EA = 0;
 264   3               init_after_flash_reload();
 265   3               EA = 1;
 266   3               modbus_16_post_func_invoke_flag = FALSE;
 267   3            }
 268   2            //-----------------------------------------------------------------------
 269   2            if (getDC24INPUT() == 0) {
 270   3              setDC24InputRegister(1);
 271   3            } else {
 272   3              setDC24InputRegister(0);
 273   3            }
 274   2            //------------------------------------------------------------------------
 275   2            if (data_for_filter_counter == N) {
 276   3               for (freq_number = 0; freq_number < freq_quantity; freq_number++) {
 277   4                  delay_index = delay_index_arr [freq_number];
 278   4                  // Initialize the delay line for the FIR filter
 279   4                  for (i = 0; i < FILTER_MAX_ORDER; i++)
 280   4                  {
 281   5                     x[i].s16 = 0;
 282   5                  }
 283   4                  // Initialize the sample array
 284   4                  for (i = 0; i < N; i ++)
 285   4                  {
 286   5                     filtered_samples[i] = 0;
 287   5                     //-----------------------------------------------------------------------------------------------
             ----
 288   5                     if (isNeedGetADCValuesFlag != 0) {
 289   6                       SFRPAGE_SAVE = SFRPAGE;
 290   6                       SFRPAGE = UART0_PAGE;
 291   6                       if(i == 0) {
 292   7                         modbus_push_transmit_buffer(0xAA);
 293   7                         modbus_push_transmit_buffer(0xAA);
 294   7                       }
 295   6                       hi = ((data_for_filter [i].u16 >> 8) & 0x00FF);
 296   6                       lo = (data_for_filter [i].u16 & 0x00FF);
 297   6                       modbus_push_transmit_buffer(hi);
 298   6                       modbus_push_transmit_buffer(lo);                
 299   6                       if ((i + 1) % 128 == 0) {
 300   7                         TI0 = 1;
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                08/03/2020 23:29:47 PAGE 6   

 301   7                         delay(100);
 302   7                       }
 303   6                       if (i == N - 1) {
 304   7                         modbus_push_transmit_buffer(0xBB);
 305   7                         modbus_push_transmit_buffer(0xBB);
 306   7                         isNeedGetADCValuesFlag = 0;
 307   7                         TI0 = 1;
 308   7                         delay(100);
 309   7                       }
 310   6                       SFRPAGE = SFRPAGE_SAVE;
 311   6                     }
 312   5                     //------------------------------------------------------------------------------------------------
             ---
 313   5                  }
 314   4                  //--------------------------------------------------------------------------------------------------
 315   4                  TAPS = populateFirCoefficients(B_FIR, freq_number);
 316   4                  if (TAPS != 61) {
 317   5                     NOP();
 318   5                  }
 319   4                  if (TAPS == 61) {
 320   5                    for (i=0; i<N; i++) {         
 321   6                       // Store ADC result in the delay line
 322   6                       x[delay_index].u16 = data_for_filter[i].u16;
 323   6                       // Sample_index points to newest data
 324   6                       sample_index = delay_index;         
 325   6                       // Update delay index
 326   6                       if (delay_index == (TAPS - 1))
 327   6                       {
 328   7                          delay_index = 0;
 329   7                       }
 330   6                       else
 331   6                       {
 332   7                          delay_index++;
 333   7                       }
 334   6      
 335   6                       MAC0CF |= 0x08;                  // Clear accumulator
 336   6                  
 337   6                       // Mirror algorithm
 338   6                       if (sample_index == TAPS - 1)
 339   6                       {
 340   7                          opposite_sample_index = 0;
 341   7                       }
 342   6                       else
 343   6                       {
 344   7                          opposite_sample_index = sample_index + 1;
 345   7                       }
 346   6                       for (coeff_index = 0; coeff_index < (TAPS / 2); coeff_index++)
 347   6                       {
 348   7                          FIR_TAP_MIRROR (B_FIR[coeff_index].u16, x[sample_index],
 349   7                          x[opposite_sample_index]);
 350   7                         
 351   7                          if (sample_index == 0)
 352   7                          {
 353   8                             sample_index = TAPS - 1;
 354   8                          }
 355   7                          else
 356   7                          {
 357   8                             sample_index--;
 358   8                          }
 359   7      
 360   7                          if (opposite_sample_index == TAPS - 1)
 361   7                          {
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                08/03/2020 23:29:47 PAGE 7   

 362   8                             opposite_sample_index = 0;
 363   8                          }
 364   7                          else
 365   7                          {
 366   8                             opposite_sample_index++;
 367   8                          }
 368   7                       }
 369   6                       if ((TAPS % 2) == 1)             // Handle middle tap of odd order filter
 370   6                       {
 371   7                          FIR_TAP (B_FIR[coeff_index].u16, x[sample_index]);
 372   7                          NOP ();
 373   7                          NOP ();
 374   7                          NOP ();
 375   7                       }
 376   6                       Sample.u16 = MAC0RND;
 377   6                       filtered_samples[i] = Sample.u16;
 378   6                    }
 379   5                    RMS_Value = RMS_Calc(filtered_samples, N, TAPS);
 380   5                    
 381   5                    putRms2Modbus(RMS_Value, freq_number);
 382   5                    delay_index_arr [freq_number] = delay_index;
 383   5                  }
 384   4               }
 385   3               LED = !LED;
 386   3               if (FOUND_1_OR_2_FREQ_FLAG == TRUE && freq_quantity == 2) {
 387   4                 freq_quantity = 6;
 388   4               } else {
 389   4                 freq_quantity = 2;
 390   4                 data_for_filter_counter = 0;
 391   4               }
 392   3            }
 393   2         }
 394   1      //-----------------------------------------------------------------------------  
 395   1      }
 396          
 397          //-----------------------------------------------------------------------------
 398          // Initialization Subroutines
 399          //-----------------------------------------------------------------------------
 400          
 401          //-----------------------------------------------------------------------------
 402          // SYSCLK_Init
 403          //-----------------------------------------------------------------------------
 404          //
 405          // Return Value:  None
 406          // Parameters:    None
 407          //
 408          // This routine initializes the system clock to use the internal 24.5MHz*4
 409          // oscillator as its clock source.
 410          //
 411          //-----------------------------------------------------------------------------
 412          void SYSCLK_Init (void)
 413          {
 414   1         SI_SEGMENT_VARIABLE(i, char, xdata);
 415   1        
 416   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 417   1        
 418   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 419   1      
 420   1         SFRPAGE = CONFIG_PAGE;              // Switch to the necessary SFRPAGE
 421   1      
 422   1         OSCICN = 0x83;
 423   1      
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                08/03/2020 23:29:47 PAGE 8   

 424   1         // Step 2. Set the PLLSRC bit (PLL0CN.2) to select the desired
 425   1         // clock source for the PLL.
 426   1         PLL0CN &= ~0x04;                    // Internal oscillator
 427   1      
 428   1         // Step 3. Program the Flash read timing bits, FLRT (FLSCL.5-4) to the
 429   1         // appropriate value for the new clock rate (see Section 15. Flash Memory
 430   1         // on page 199).
 431   1         SFRPAGE = LEGACY_PAGE;
 432   1         FLSCL |= 0x30;                      // >= 100 MHz
 433   1         SFRPAGE = CONFIG_PAGE;
 434   1      
 435   1         // Step 4. Enable power to the PLL by setting PLLPWR (PLL0CN.0) to ‘1’.
 436   1         PLL0CN |= 0x01;
 437   1      
 438   1         // Step 5. Program the PLL0DIV register to produce the divided reference
 439   1         // frequency to the PLL.
 440   1         PLL0DIV = 0x01;
 441   1      
 442   1         // Step 6. Program the PLLLP3-0 bits (PLL0FLT.3-0) to the appropriate
 443   1         // range for the divided reference frequency.
 444   1         PLL0FLT |= 0x01;
 445   1      
 446   1         // Step 7. Program the PLLICO1-0 bits (PLL0FLT.5-4) to the appropriate
 447   1         // range for the PLL output frequency.
 448   1         PLL0FLT &= ~0x30;
 449   1      
 450   1         // Step 8. Program the PLL0MUL register to the desired clock multiplication
 451   1         // factor.
 452   1         PLL0MUL = 0x04;
 453   1      
 454   1         // Step 9. Wait at least 5 µs, to provide a fast frequency lock.
 455   1         for (i = 100; i > 0; i--);
 456   1      
 457   1         // Step 10. Enable the PLL by setting PLLEN (PLL0CN.1) to ‘1’.
 458   1         PLL0CN |= 0x02;
 459   1      
 460   1         // Step 11. Poll PLLLCK (PLL0CN.4) until it changes from ‘0’ to ‘1’.
 461   1         while ((PLL0CN & 0x10) != 0x10);
 462   1      
 463   1         // Step 12. Switch the System Clock source to the PLL using the CLKSEL
 464   1         // register.
 465   1         CLKSEL = 0x02;
 466   1      
 467   1         SFRPAGE = SFRPAGE_SAVE;             // Restore the SFRPAGE
 468   1      }
 469          
 470          //-----------------------------------------------------------------------------
 471          // PORT_Init
 472          //-----------------------------------------------------------------------------
 473          //
 474          // Return Value:  None
 475          // Parameters:    None
 476          //
 477          // Configure the Crossbar and GPIO ports.
 478          //
 479          // Pinout:
 480          //
 481          // P0.0 - UART TX1 (push-pull)
 482          // P0.1 - UART RX1
 483          //
 484          // P1.6 - LED (push-pull)
 485          //
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                08/03/2020 23:29:47 PAGE 9   

 486          // DAC0 - DAC0 output
 487          //
 488          // AIN0.0 - ADC0 analog input
 489          //
 490          // Note: DAC0 and AIN0.0 must be tied together.
 491          //
 492          //-----------------------------------------------------------------------------
 493          void PORT_Init (void)
 494          {
 495   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata);
 496   1         SFRPAGE_save = SFRPAGE;             // Save the current SFRPAGE
 497   1      
 498   1         SFRPAGE = CONFIG_PAGE;              // Switch to the necessary SFRPAGE
 499   1      
 500   1         XBR0     = 0x04;
 501   1         XBR1     = 0x00;
 502   1         XBR2     = 0x40;                    // Enable crossbar and weak pull-up
 503   1                                             // Enable UART0
 504   1      
 505   1         P0MDOUT |= 0x01;                    // Set TX1 pin to push-pull
 506   1         P1MDOUT |= 0x40;                    // Set P1.6(LED) to push-pull
 507   1         
 508   1         P3MDOUT &= ~0x80;                   // Set P3.7 to input
 509   1         
 510   1         P4MDOUT |= 0x04;                    // Set P4.2 to push-pull
 511   1         P4MDOUT |= 0x10;                    // Set P4.4 to push-pull
 512   1         P4MDOUT &= ~0x08;                   // Set P4.3 to input
 513   1        
 514   1         P5MDOUT |= 0xFF;
 515   1         P6MDOUT |= 0xFF;
 516   1         P7MDOUT |= 0xFF;
 517   1         P5 =  0x00;
 518   1         P6 |= 0x0F;
 519   1         P7 =  0xFF;
 520   1         DC24OUTPUT = 1;
 521   1         DC24INPUT = 1;
 522   1         SELECT485 = 0;                      // to receive
 523   1         CONDSELECTOR = 1;                   // set to KP condition
 524   1         
 525   1         SFRPAGE = SFRPAGE_save;             // Restore the SFRPAGE
 526   1      }
 527          
 528          //-----------------------------------------------------------------------------
 529          // UART0_Init
 530          //-----------------------------------------------------------------------------
 531          void Timer0_Init(void)
 532          {
 533   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata);
 534   1        SFRPAGE_save = SFRPAGE;
 535   1        
 536   1        SFRPAGE = TIMER01_PAGE;
 537   1        
 538   1        TMOD   &= 0xFD;
 539   1        TMOD   |= 0x01;
 540   1        TH0     = 0x00;
 541   1        TL0     = 0x00;
 542   1        ET0     = 1;
 543   1        TR0     = 1;
 544   1        CKCON  |= 0x08;
 545   1        SFRPAGE = SFRPAGE_save;
 546   1      }
 547          //-----------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                08/03/2020 23:29:47 PAGE 10  

 548          // UART0_Init
 549          //-----------------------------------------------------------------------------
 550          //
 551          // Return Value:  None
 552          // Parameters:    None
 553          //
 554          // Configure the UART0 using Timer1, for <BAUDRATE> and 8-N-1.
 555          //
 556          //-----------------------------------------------------------------------------
 557          void UART0_Init (void)
 558          {
 559   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata); 
 560   1         SFRPAGE_save = SFRPAGE; // Save the current SFRPAGE
 561   1      
 562   1         SFRPAGE = UART0_PAGE;               // Switch to the necessary SFRPAGE
 563   1          
 564   1         SCON0  = 0x70;
 565   1         TMOD   = 0x20;
 566   1         TH1    = 0x5D;///0xE5;///0x5D;////0xE5;// - 115200;
 567   1         TR1    = 1;
 568   1         CKCON |= 0x10;
 569   1         PCON  |= 0x80;//SMOD0 = 1 
 570   1        
 571   1         TI0    = 0;                         // Indicate TX0 ready
 572   1         
 573   1         PS0    = 1;
 574   1        
 575   1         ES0    = 1; 
 576   1        
 577   1         SFRPAGE = SFRPAGE_save;             // Restore the SFRPAGE
 578   1      }
 579          //-----------------------------------------------------------------------------
 580          // DAC0_Init
 581          //-----------------------------------------------------------------------------
 582          //
 583          // Return Value:  None
 584          // Parameters:    None
 585          //
 586          // Configure DAC1 to update on Timer4 overflows.  VREF is already enabled by
 587          // the ADC initialization code.
 588          //
 589          //-----------------------------------------------------------------------------
 590          void DAC0_Init(void){
 591   1      
 592   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 593   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 594   1      
 595   1         SFRPAGE = DAC0_PAGE;
 596   1      
 597   1         DAC0CN = 0x94;                      // Enable DAC0 in left-justified mode
 598   1                                             // managed by Timer4 overflows
 599   1      
 600   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 601   1      }
 602          
 603          //-----------------------------------------------------------------------------
 604          // DAC1_Init
 605          //-----------------------------------------------------------------------------
 606          //
 607          // Return Value:  None
 608          // Parameters:    None
 609          //
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                08/03/2020 23:29:47 PAGE 11  

 610          // Configure DAC1 to update on write to DAC1H.  VREF is already enabled by
 611          // the ADC initialization code.
 612          //
 613          //-----------------------------------------------------------------------------
 614          void DAC1_Init(void){
 615   1      
 616   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 617   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 618   1      
 619   1         SFRPAGE = DAC1_PAGE;
 620   1      
 621   1         DAC1CN = 0x84;                      // Enable DAC1 in left-justified mode
 622   1                                             // managed by write data to DAC1H
 623   1         
 624   1         DAC1 = DAC1_VALUE;                  // Write to DAC1
 625   1      
 626   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 627   1      }
 628          
 629          //-----------------------------------------------------------------------------
 630          // ADC0_Init
 631          //-----------------------------------------------------------------------------
 632          //
 633          // Return Value:  None
 634          // Parameters:    None
 635          //
 636          // Configures ADC0 to make single-ended analog measurements on pin AIN0.0 for
 637          // the FIR filter.  Timer3 overflows are the conversion source and the data is
 638          // left-justified.  This function also enables the ADC end-of-conversion
 639          // interrupt and leaves the ADC disabled.
 640          //
 641          //-----------------------------------------------------------------------------
 642          void ADC0_Init (void)
 643          {
 644   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 645   1        
 646   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 647   1      
 648   1         SFRPAGE = ADC0_PAGE;
 649   1      
 650   1         ADC0CN = 0x05;                      // ADC0 disabled; normal tracking
 651   1                                             // mode; ADC0 conversions are initiated
 652   1                                             // on overflow of Timer3; ADC0 data is
 653   1                                             // left-justified
 654   1      
 655   1         REF0CN = 0x03;                      // Enable on-chip VREF and VREF output
 656   1                                             // buffer
 657   1      #ifndef BIPOLIAR_ADC
 658   1         AMX0SL = 0x00;                      // Select AIN0.0 as ADC mux input
 659   1      #else 
                 AMX0CF = 0x01;
                 AMX0SL = 0x00;
              #endif
 663   1        
 664   1         ADC0CF = (SYSCLK/2500000) << 3;     // ADC conversion clock = 2.5MHz
 665   1      
 666   1         EIE2 |= 0x02;                       // Enable ADC interrupts
 667   1      
 668   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 669   1      }
 670          
 671          //-----------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                08/03/2020 23:29:47 PAGE 12  

 672          // Timer3_Init
 673          //-----------------------------------------------------------------------------
 674          //
 675          // Return Value:  None
 676          // Parameters:    None
 677          //
 678          // Configure Timer3 to auto-reload at interval specified by <counts> (no
 679          // interrupt generated) using SYSCLK as its time base.
 680          //
 681          // Timer 3 overflow automatically triggers ADC0 conversion.
 682          //
 683          //-----------------------------------------------------------------------------
 684          void Timer3_Init (int counts)
 685          {
 686   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 687   1        
 688   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 689   1      
 690   1         SFRPAGE = TMR3_PAGE;
 691   1      
 692   1         TMR3CN = 0x00;                      // Stop Timer3; Clear TF3;
 693   1         TMR3CF = 0x08;                      // use SYSCLK as timebase
 694   1      
 695   1         RCAP3   = -counts;                  // Init reload values
 696   1         TMR3    = RCAP3;                    // set to reload immediately
 697   1         EIE2   &= ~0x01;                    // Disable Timer3 interrupts
 698   1         TR3 = 1;                            // Start Timer3
 699   1      
 700   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 701   1      }
 702          //-----------------------------------------------------------------------------
 703          // Timer4_Init
 704          //-----------------------------------------------------------------------------
 705          //
 706          // Return Value:  None
 707          // Parameters:
 708          //   1) counts - the number of timer clocks to count before a timer interrupt
 709          //           should occur
 710          //
 711          // Configure Timer4 to auto-reload mode and to generate interrupts
 712          // at intervals specified in <counts> using SYSCLK as its time base.
 713          //
 714          // Timer 4 overflow controls the DAC update rate.
 715          //
 716          //-----------------------------------------------------------------------------
 717          void Timer4_Init (int counts)
 718          {
 719   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 720   1        
 721   1         SFRPAGE_SAVE = SFRPAGE;          // Save Current SFR page
 722   1      
 723   1         SFRPAGE = TMR4_PAGE;
 724   1      
 725   1         TMR4CN = 0x00;                   // Stop Timer4; Clear overflow flag (TF4);
 726   1                                          // Set to Auto-Reload Mode
 727   1      
 728   1         TMR4CF = 0x08;                   // Configure Timer4 to increment;
 729   1                                          // Timer4 counts SYSCLKs
 730   1      
 731   1         RCAP4 = -counts;                 // Set reload value
 732   1         TMR4 = RCAP4;                    // Initialzie Timer4 to reload value
 733   1        
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                08/03/2020 23:29:47 PAGE 13  

 734   1         EIE2 |= 0x04;                    // Enable Timer4 interrupts
 735   1         TR4 = 1;                         // Start Timer4
 736   1      
 737   1         SFRPAGE = SFRPAGE_SAVE;          // Restore SFR page
 738   1      }
 739          //-----------------------------------------------------------------------------
 740          // ADC0_ISR
 741          //-----------------------------------------------------------------------------
 742          //
 743          // ADC0 end-of-conversion ISR
 744          //
 745          // This interrupt service routine is called on ADC0 conversion complete.
 746          // The ADC result is converted to signed and stored in the FIR delay line.
 747          //
 748          // If the global <FIR_On> bit is set to a '1', then the FIR output is computed
 749          // and stored in the global variable 'Sample'.  The 'Sample_Ready' indicator
 750          // bit is set to indicate the value is ready.
 751          //
 752          // If <FIR_On> is set to '0', then the ADC sample is copied to the global
 753          // 'Sample' variable.  The 'Sample_Ready' indicator bit is set to indicate
 754          // that the value is ready.
 755          //
 756          //-----------------------------------------------------------------------------
 757          //void ADC0_ISR (void) interrupt 15
 758          #pragma NOAREGS
 759          SI_INTERRUPT(ADC0_ISR, INTERRUPT_ADC0_EOC)
 760          {
 761   1         volatile SI_UU16_t input;
 762   1        
 763   1         AD0INT = 0;                         // Clear ADC conversion complete
 764   1                                             // indicator
 765   1      
 766   1         input.s16 = ADC0^0x8000;            // Convert to bipolar value
 767   1         
 768   1         
 769   1         if (data_for_filter_counter < N) {
 770   2            data_for_filter [data_for_filter_counter++].u16 = input.u16;
 771   2         }
 772   1      }
 773          
 774          #pragma NOAREGS
 775          SI_INTERRUPT(TIMER0_ISR, INTERRUPT_TIMER0)
 776          {
 777   1        unsigned char SFRPAGE_save = SFRPAGE;
 778   1        SFRPAGE = TIMER01_PAGE;
 779   1        TH0     = 0x00;
 780   1        TL0     = 0x00;
 781   1        TF0     = 0;
 782   1        SFRPAGE = SFRPAGE_save;
 783   1        if(modbus_was_sendind_received()) {
 784   2          modbus_command_received();
 785   2          SFRPAGE = CONFIG_PAGE;
 786   2          LED485  = !LED485;
 787   2        }
 788   1        SFRPAGE = CONFIG_PAGE;
 789   1        if (DC24OUTPUT == 0) {
 790   2          if (TimerForDC24Output++ % DividerForDC24Output == 0) {
 791   3            DC24OUTPUT = 1;
 792   3          }
 793   2        }
 794   1        TIMER++;
 795   1        SFRPAGE = SFRPAGE_save;
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                08/03/2020 23:29:47 PAGE 14  

 796   1      }
 797          
 798          #pragma NOAREGS
 799          SI_INTERRUPT(UART0_ISR, INTERRUPT_UART0)
 800          {
 801   1        unsigned char SFRPAGE_save = SFRPAGE; // Save the current SFRPAGE
 802   1        SFRPAGE = UART0_PAGE;
 803   1        if(RI0 == 1) {
 804   2          modbus_byte_receive(SBUF0);
 805   2          RI0 = 0;
 806   2        }
 807   1        if(TI0 == 1) {
 808   2          TI0 = 0;
 809   2          toTransmit485();
 810   2          if (modbus_transmit_buffer_is_empty()) {
 811   3            toReceive485();
 812   3          }
 813   2          else {
 814   3            modbus_transmit_byte();
 815   3          }
 816   2        }
 817   1        SFRPAGE = SFRPAGE_save;               // Restore the SFRPAGE  
 818   1      }
 819          //-----------------------------------------------------------------------------
 820          // Timer4_ISR
 821          //-----------------------------------------------------------------------------
 822          //
 823          // This ISR is called on Timer4 overflows.  Timer4 is set to auto-reload mode
 824          // and is used to schedule the DAC output sample rate in this example.
 825          // Note that the value that is written to DAC1 during this ISR call is
 826          // actually transferred to DAC1 at the next Timer4 overflow.
 827          //
 828          //-----------------------------------------------------------------------------
 829          //void Timer4_ISR (void) interrupt 16
 830          #pragma NOAREGS
 831          SI_INTERRUPT(Timer4_ISR, INTERRUPT_TIMER4)
 832          { 
 833   1         char number = 0;
 834   1         int temp1 = 0;                      // The temporary value that passes
 835   1                                             // through 3 stages before being written
 836   1                                             // to the IDAC
 837   1         TMR3CN &= ~0x80;                    // Clear Timer3 overflow flag
 838   1        
 839   1         for (number=0; number<12; number++) {
 840   2            if (freq_dac_flags [number] == 1) {
 841   3              phase_acc[number].u16 += Phase_Add [number];
 842   3              temp1 += (SINE_TABLE[phase_acc[number].u8[MSB]] / freq_divider);
 843   3            }
 844   2         }
 845   1           
 846   1         SFRPAGE = DAC0_PAGE;
 847   1      
 848   1         // Add a DC bias to make the rails 0 to 65535
 849   1         // Note: the XOR with 0x8000 translates the bipolar quantity into
 850   1         // a unipolar quantity.
 851   1      
 852   1         DAC0 = 0x8000 ^ temp1;              // Write to DAC0
 853   1      }
 854          
 855          #pragma NOAREGS
 856          void init_after_flash_reload() {
 857   1         //-----------------------------------------------------------------------
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                08/03/2020 23:29:47 PAGE 15  

 858   1         SI_SEGMENT_VARIABLE(i, uint8_t, xdata);
 859   1         SI_SEGMENT_VARIABLE(d, uint8_t, xdata);
 860   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 861   1         //-----------------------------------------------------------------------
 862   1         SFRPAGE_save = SFRPAGE;
 863   1         d = 0;
 864   1         //----------------------- FREQ DIVIDER INIT -----------------------------
 865   1         freq_divider = modbus_get_freq_divider();
 866   1         if (freq_divider == 0) {
 867   2            freq_divider = 1;
 868   2         }
 869   1         //--------------------------- FREQ INIT ---------------------------------
 870   1         modbus_init_freqs(FREQS);
 871   1         for (i=0; i<12; i++) {
 872   2            Phase_Add [i] = (unsigned int)((unsigned long)((FREQS [i] *
 873   2                      PHASE_PRECISION) / OUTPUT_RATE_DAC));
 874   2            if (getFreqFromModbusForDAC(i) != 0) {
 875   3               freq_dac_flags [i] = 1;
 876   3               if (i < 8) {
 877   4                  d = bit_set(d, i);
 878   4               }
 879   3            } else {
 880   3               freq_dac_flags [i] = 0;
 881   3            }
 882   2            if (getCondition() == DP_CONDITION) {
 883   3               // DP
 884   3               flashP5P6(i, freq_dac_flags [i]);
 885   3            }
 886   2         }
 887   1         if (getCondition() == KP_CONDITION) {
 888   2            // KP
 889   2            flashDiodesOnCommand(d, KP_CONDITION);
 890   2         }
 891   1         d = getDC24DurationTimeIfEnabed();
 892   1         if (d != 0) {
 893   2            setDC24OUTPUT(0);
 894   2            DividerForDC24Output = d * MILLISECONDS_10;
 895   2            TimerForDC24Output = 1;
 896   2         }
 897   1         //--------------------------------------------------------------------------
 898   1         if (isNeedGetADCValues() == 1) {
 899   2           isNeedGetADCValuesFlag = 1;
 900   2         }
 901   1         SFRPAGE = SFRPAGE_save;
 902   1      }
 903          //-----------------------------------------------------------------------------
 904          // delay
 905          void delay(unsigned short timer) {
 906   1        TIMER = 0;
 907   1        while(TIMER < timer); 
 908   1      }
 909          //-----------------------------------------------------------------------------
 910          // transmit 485
 911          void toTransmit485() {
 912   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 913   1        SFRPAGE_save = SFRPAGE;
 914   1        SFRPAGE = CONFIG_PAGE;
 915   1        SELECT485 = 1;
 916   1        SFRPAGE = SFRPAGE_save;
 917   1      }
 918          //-----------------------------------------------------------------------------
 919          // receive 485
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                08/03/2020 23:29:47 PAGE 16  

 920          void toReceive485() {
 921   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 922   1        SFRPAGE_save = SFRPAGE;
 923   1        SFRPAGE = CONFIG_PAGE;
 924   1        SELECT485 = 0;
 925   1        SFRPAGE = SFRPAGE_save;
 926   1      }
 927          //-----------------------------------------------------------------------------
 928          // putchar
 929          //-----------------------------------------------------------------------------
 930          //
 931          // Return Value:
 932          //   1) char c - returns the char c that was passed as a parameter
 933          // Parameters:
 934          //   1) char c - the character to be printed
 935          //
 936          // Print the character <c> using UART0 at <BAUDRATE>.
 937          //
 938          //-----------------------------------------------------------------------------
 939          #if defined __C51__
 940          char putchar (char c)
 941          #elif defined SDCC
              void putchar (char c)
              #endif
 944          {
 945   1         modbus_push_transmit_buffer(c);
 946   1      #if defined __C51__
 947   1         return c;                           // Print the character
 948   1      #endif
 949   1      }
 950          //-----------------------------------------------------------------------------
 951          // End Of File
 952          //-----------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2303    ----
   CONSTANT SIZE    =    512    ----
   XDATA SIZE       =   2384      24
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
