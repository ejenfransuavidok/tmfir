C51 COMPILER V9.53.0.0   FIR                                                               07/19/2020 09:18:10 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE FIR
OBJECT MODULE PLACED IN fir.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE fir.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "fir.h"
   2          
   3          SI_SEGMENT_VARIABLE(FOUND_1_OR_2_FREQ_FLAG, uint8_t, xdata);
   4          
   5          /**
   6           *
   7           * MUST WRITE COMMAND TO MODBUS FROM 1278 TO 1283 FOR DP
   8           *
   9           */
  10          #pragma NOAREGS
  11          void flashDiodesOnCommand(uint8_t d, uint8_t kp_or_dp) {
  12   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
  13   1         SFRPAGE_save = SFRPAGE;
  14   1         SFRPAGE = CONFIG_PAGE;
  15   1         //-----------------------------------------------------------------------
  16   1         // CLEAR - INVERSE LOGIC
  17   1         P7 =  0xFF;
  18   1         if ((d & CMD_1) == (uint8_t)CMD_1) {
  19   2            bit_clear_P7(0);
  20   2            if (kp_or_dp == DP_CONDITION) {
  21   3               modbus_write_register(CMD_ADDRESS_1, 1);
  22   3            }
  23   2         }
  24   1         if ((d & CMD_2) == CMD_2) {
  25   2            bit_clear_P7(1);
  26   2            if (kp_or_dp == DP_CONDITION) {
  27   3               modbus_write_register(CMD_ADDRESS_2, 1);
  28   3            }
  29   2         }
  30   1         if ((d & CMD_3) == CMD_3) {
  31   2            bit_clear_P7(2);
  32   2            if (kp_or_dp == DP_CONDITION) {
  33   3               modbus_write_register(CMD_ADDRESS_3, 1);
  34   3            }
  35   2         }
  36   1         if ((d & CMD_4) == CMD_4) {
  37   2            bit_clear_P7(3);
  38   2            if (kp_or_dp == DP_CONDITION) {
  39   3               modbus_write_register(CMD_ADDRESS_4, 1);
  40   3            }
  41   2         }
  42   1         if ((d & CMD_5) == CMD_5) {
  43   2            bit_clear_P7(4);
  44   2            if (kp_or_dp == DP_CONDITION) {
  45   3               modbus_write_register(CMD_ADDRESS_5, 1);
  46   3            }
  47   2         }
  48   1         if ((d & CMD_6) == CMD_6) {
  49   2            bit_clear_P7(5);
  50   2            if (kp_or_dp == DP_CONDITION) {
  51   3               modbus_write_register(CMD_ADDRESS_6, 1);
  52   3            }
  53   2         }
  54   1         SFRPAGE = SFRPAGE_save;
  55   1      }
C51 COMPILER V9.53.0.0   FIR                                                               07/19/2020 09:18:10 PAGE 2   

  56          
  57          #pragma NOAREGS
  58          int getFreqFromModbusForDAC(int number) {
  59   1        uint8_t hi;
  60   1        uint8_t lo;
  61   1        uint8_t * modbus_buffer_data;
  62   1        
  63   1        modbus_buffer_data = getModbusBufferData();
  64   1        
  65   1        hi = modbus_buffer_data[((MODBUS_OUTPUT_FREQ_FLAG_REGISTER_OFFSET + number) << 1)];
  66   1        lo = modbus_buffer_data[(((MODBUS_OUTPUT_FREQ_FLAG_REGISTER_OFFSET + number) << 1) + 1)];
  67   1        
  68   1        return ((hi << 8) + lo);
  69   1      }
  70          
  71          #pragma NOAREGS
  72          uint8_t populateFirCoefficients(SI_UU16_t * coefficients, int number) {
  73   1        SI_SEGMENT_VARIABLE(i, uint8_t, xdata);
  74   1        SI_SEGMENT_VARIABLE(order, uint16_t, xdata);
  75   1        SI_SEGMENT_VARIABLE(result, uint8_t, xdata);
  76   1        SI_SEGMENT_VARIABLE(temp, uint16_t, xdata);
  77   1        SI_SEGMENT_VARIABLE(coefficientIndex, uint16_t, xdata);
  78   1        SI_SEGMENT_VARIABLE(hi, uint8_t, xdata);
  79   1        SI_SEGMENT_VARIABLE(lo, uint8_t, xdata);
  80   1        
  81   1        uint8_t * modbus_buffer_data;
  82   1        if (number > 11 || number < 0) {
  83   2          return 0;
  84   2        }
  85   1        coefficientIndex = MODBUS_FILTER_COEFFICIENT_START_REGISTER + FILTER_MAX_ORDER_IN_MODBUS * number;
  86   1        modbus_buffer_data = getModbusBufferData();
  87   1        order = MODBUS_FILTER_ORDER_START_REGISTER;
  88   1        order = order + number;
  89   1        // reg number to byte number
  90   1        order = order << 1;
  91   1        // get filter order
  92   1        result = modbus_buffer_data [order + 1];
  93   1        if (result != 61) {
  94   2          result = 0;
  95   2        }
  96   1        for (i = 0; i<result; i++) {
  97   2          temp = coefficientIndex + i;
  98   2          hi = modbus_buffer_data [temp << 1];
  99   2          lo = modbus_buffer_data [(temp << 1) + 1];
 100   2          coefficients [i].u16 = (hi << 8) + lo;
 101   2        }
 102   1        if (result != 61) {
 103   2          NOP();
 104   2        }
 105   1        return result;
 106   1      }
 107          
 108          
 109          #pragma NOAREGS
 110          void putRms2Modbus(int value, uint8_t number) {
 111   1        uint8_t * modbus_buffer_data;
 112   1        SI_SEGMENT_VARIABLE(i, uint8_t, xdata);
 113   1        SI_SEGMENT_VARIABLE(hi, uint8_t, xdata);
 114   1        SI_SEGMENT_VARIABLE(lo, uint8_t, xdata);
 115   1        SI_SEGMENT_VARIABLE(address, unsigned int, xdata);
 116   1        SI_SEGMENT_VARIABLE(amplitude_reference, unsigned int, xdata);
 117   1        SI_SEGMENT_VARIABLE(flag, uint8_t, xdata);
C51 COMPILER V9.53.0.0   FIR                                                               07/19/2020 09:18:10 PAGE 3   

 118   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata);
 119   1        SI_SEGMENT_VARIABLE(d, uint8_t, xdata);
 120   1        
 121   1        SFRPAGE_save = SFRPAGE;
 122   1        
 123   1        if (number > 11 || number < 0) {
 124   2          return;
 125   2        }
 126   1        //---------------------- PUT FIR RESULT TO MODBUS ----------------------
 127   1        address = MODBUS_FREQUENCY_AMPLITUDES_VALUE_START + number;
 128   1        address = address << 1;
 129   1        hi = (value >> 8);
 130   1        lo = (value & 0xFF);
 131   1        modbus_buffer_data = getModbusBufferData();
 132   1        modbus_buffer_data [address] = hi;
 133   1        modbus_buffer_data [address + 1] = lo;
 134   1        //---------------------- READ REFERENCE FROM MODBUS ----------------------
 135   1        address = MODBUS_AMPLITUDES_THREASHOLS_VALUE_START + number;
 136   1        address = address << 1;
 137   1        hi = modbus_buffer_data [address];
 138   1        lo = modbus_buffer_data [address + 1];
 139   1        amplitude_reference = (hi << 8) + lo;
 140   1        //---------------------- COMPARE FIR RESULT AND REFEREBCE ----------------------
 141   1        if (value > amplitude_reference) {
 142   2           flag = 1;
 143   2        } else {
 144   2           flag = 0;
 145   2        }
 146   1        //---------------------- PUT COMPARATIVE TO MODBUS LIKE A FLAG ----------------------
 147   1        address = MODBUS_FREQUENCY_VALUE_START + number;
 148   1        address = address << 1;
 149   1        modbus_buffer_data [address] = 0;
 150   1        modbus_buffer_data [address + 1] = flag;
 151   1        //-------------------------------------------------------------------------------------
 152   1        // DP
 153   1        d = 0;
 154   1        for (i=0; i<8; i++) {
 155   2          address = MODBUS_FREQUENCY_VALUE_START + i;
 156   2          address = address << 1;
 157   2          address += 1;
 158   2          if (modbus_buffer_data [address] == 1) {
 159   3             d = bit_set(d, i);
 160   3          }
 161   2          if ((d & 0x01 == 0x01) || (d & 0x02 == 0x02)) {
 162   3             FOUND_1_OR_2_FREQ_FLAG = TRUE;
 163   3          } else {
 164   3             FOUND_1_OR_2_FREQ_FLAG = FALSE;
 165   3          }
 166   2        }
 167   1        flashDiodesOnCommand(d, DP_CONDITION);
 168   1        //-------------------------------------------------------------------------------------
 169   1      }
 170          //-----------------------------------------------------------------------------
 171          // bits operations
 172          //-----------------------------------------------------------------------------
 173          #pragma NOAREGS
 174          void bit_set_P5(uint8_t position)
 175          {
 176   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 177   1         SI_SEGMENT_VARIABLE(d, uint8_t, xdata);
 178   1         SFRPAGE_save = SFRPAGE;
 179   1         SFRPAGE = CONFIG_PAGE;
C51 COMPILER V9.53.0.0   FIR                                                               07/19/2020 09:18:10 PAGE 4   

 180   1         d = (0x01<<position);
 181   1         P5|= d;
 182   1         SFRPAGE = SFRPAGE_save;
 183   1      }
 184          #pragma NOAREGS
 185          void bit_clear_P5(uint8_t position)
 186          {
 187   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 188   1         SI_SEGMENT_VARIABLE(d, uint8_t, xdata);
 189   1         SFRPAGE_save = SFRPAGE;
 190   1         SFRPAGE = CONFIG_PAGE;
 191   1         d = (1u<<position);
 192   1         P5&= ~d;
 193   1         SFRPAGE = SFRPAGE_save;
 194   1      }
 195          #pragma NOAREGS
 196          void bit_set_P6(uint8_t position)
 197          {
 198   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 199   1         SI_SEGMENT_VARIABLE(d, uint8_t, xdata);
 200   1         SFRPAGE_save = SFRPAGE;
 201   1         SFRPAGE = CONFIG_PAGE;
 202   1         d = (1u<<position);
 203   1         P6|= d;
 204   1         SFRPAGE = SFRPAGE_save;
 205   1      }
 206          #pragma NOAREGS
 207          void bit_clear_P6(uint8_t position)
 208          {
 209   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 210   1         SI_SEGMENT_VARIABLE(d, uint8_t, xdata);
 211   1         SFRPAGE_save = SFRPAGE;
 212   1         SFRPAGE = CONFIG_PAGE;
 213   1         d = (1u<<position);
 214   1         P6&= ~d;
 215   1         SFRPAGE = SFRPAGE_save;
 216   1      }
 217          #pragma NOAREGS
 218          void bit_set_P7(uint8_t position)
 219          {
 220   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 221   1         SI_SEGMENT_VARIABLE(d, uint8_t, xdata);
 222   1         SFRPAGE_save = SFRPAGE;
 223   1         SFRPAGE = CONFIG_PAGE;
 224   1         d = (1u<<position);
 225   1         P7|= d;
 226   1         SFRPAGE = SFRPAGE_save;
 227   1      }
 228          #pragma NOAREGS
 229          void bit_clear_P7(uint8_t position)
 230          {
 231   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 232   1         SI_SEGMENT_VARIABLE(d, uint8_t, xdata);
 233   1         SFRPAGE_save = SFRPAGE;
 234   1         SFRPAGE = CONFIG_PAGE;
 235   1         d = (1u<<position);
 236   1         P7&=~d;
 237   1         SFRPAGE = SFRPAGE_save;
 238   1      }
 239          #pragma NOAREGS
 240          uint8_t bit_set(uint8_t d, uint8_t position)
 241          {
C51 COMPILER V9.53.0.0   FIR                                                               07/19/2020 09:18:10 PAGE 5   

 242   1         d |= (1u<<position);
 243   1         return d;
 244   1      }
 245          #pragma NOAREGS
 246          uint8_t bit_clear(uint8_t d, uint8_t position)
 247          {
 248   1         d &= ~(1u<<position);
 249   1         return d;
 250   1      }
 251          //-----------------------------------------------------------------------------
 252          // KP - 1 / DP - 0
 253          #pragma NOAREGS
 254          int getCondition() {
 255   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 256   1        SI_SEGMENT_VARIABLE(result, int, xdata);
 257   1        SFRPAGE_save = SFRPAGE;
 258   1        SFRPAGE = CONFIG_PAGE;
 259   1        result = CONDSELECTOR;
 260   1        SFRPAGE = SFRPAGE_save;
 261   1        return result;
 262   1      }
 263          //-----------------------------------------------------------------------------
 264          // FLASH DIODES P5 and P6
 265          #pragma NOAREGS
 266          void flashP5P6(uint8_t number, uint8_t flag) {
 267   1        if (number < 8) {
 268   2           flag == 1 ? bit_set_P5(number) : bit_clear_P5(number);
 269   2        } else {
 270   2           flag == 1 ? bit_set_P6(number - 4) : bit_clear_P6(number - 4);
 271   2        }
 272   1      }
 273          //-----------------------------------------------------------------------------
 274          // get DC24 input P4^3 value
 275          #pragma NOAREGS
 276          uint8_t getDC24INPUT() {
 277   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 278   1        SI_SEGMENT_VARIABLE(value, uint8_t, xdata);
 279   1        SFRPAGE_save = SFRPAGE;
 280   1        SFRPAGE = CONFIG_PAGE;
 281   1        value = DC24INPUT;
 282   1        SFRPAGE = SFRPAGE_save;
 283   1        return value;
 284   1      }
 285          //-----------------------------------------------------------------------------
 286          // set DC24 output P4^2 value
 287          #pragma NOAREGS
 288          void setDC24OUTPUT(uint8_t value) {
 289   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 290   1        SFRPAGE_save = SFRPAGE;
 291   1        SFRPAGE = CONFIG_PAGE;
 292   1        DC24OUTPUT = value;
 293   1        SFRPAGE = SFRPAGE_save;
 294   1      }
 295          /*-----------------------------------------------------------------------------
 296          // RMS_Calc
 297          //-----------------------------------------------------------------------------
 298          //
 299          // Return Value : None
 300          // Parameters   :
 301          //   1) input_samples - pointer to an array of the data to be used for the RMS
 302          //                        Value calculations
 303          //   2) num_samples - the number of data elements in the <input_samples> array
C51 COMPILER V9.53.0.0   FIR                                                               07/19/2020 09:18:10 PAGE 6   

 304          //
 305          // This routine takes a pointer to an array and a number of samples and first
 306          // computes the average value of the data.  Then, it uses this average to
 307          // calculate the RMS Value by using the following equation:
 308          //
 309          //                 N
 310          //                 __
 311          //                 \
 312          //                 /_  (x-x_avg)^2
 313          //                 n=10
 314          // RMS_Value^2 =  -----------------
 315          //                       N-10
 316          //
 317          //
 318          // The above routine skips the first <TAPS> samples where the filter hasn't quite
 319          // settled.
 320          //---------------------------------------------------------------------------*/
 321          #pragma NOAREGS
 322          int RMS_Calc (int *input_samples, int num_samples, int TAPS)
 323          {
 324   1         int count = 0;
 325   1         float average = 0;
 326   1         float RMS_summation = 0;
 327   1         float RMS_Value;
 328   1         float temp;
 329   1        
 330   1         // Calculate the average value (x_avg) of the <input_samples> array
 331   1         average = 0.0;
 332   1      
 333   1         for (count = TAPS; count < num_samples; count++)
 334   1         {
 335   2            average += (float) input_samples[count];
 336   2         }
 337   1         average = (float)(average / (num_samples-TAPS));
 338   1      
 339   1         // Calculate the RMS Value using the average computed above
 340   1         // Calculate the sum from 1 to N of (x-x_avg)^2
 341   1         for (count = TAPS; count < num_samples; count++)
 342   1         {
 343   2            // calculate difference from mean
 344   2            temp = input_samples[count] - average;
 345   2            // square it
 346   2            temp *= temp;
 347   2            // and add it to sum
 348   2            RMS_summation += temp;
 349   2         }
 350   1         // Calculate sum from above / N
 351   1         RMS_summation = (float)RMS_summation / (num_samples-TAPS);
 352   1      #if defined __C51__
 353   1         RMS_Value = sqrt(RMS_summation);
 354   1      #elif defined SDCC
                 RMS_Value = sqrtf(RMS_summation);
              #endif
 357   1         return (int)RMS_Value;
 358   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1680    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      39
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.53.0.0   FIR                                                               07/19/2020 09:18:10 PAGE 7   

   DATA SIZE        =   ----      39
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
