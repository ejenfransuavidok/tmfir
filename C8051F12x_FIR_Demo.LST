C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/11/2020 11:41:23 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE C8051F12X_FIR_DEMO
OBJECT MODULE PLACED IN C8051F12x_FIR_Demo.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE C8051F12x_FIR_Demo.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // Includes
   3          //-----------------------------------------------------------------------------
   4          
   5          #include "si_toolchain.h"             // Compiler-specific declarations
   6                                                 // (Keil/SDCC)
   7          #include "C8051F120_defs.h"            // SFR declarations
   8          #include <stdio.h>
   9          #include <math.h>
  10          #include "fir.h"
  11          #include "modbus.h"
  12          
  13          //-------------------------- BIPOLIAR SELECTOR --------------------------------
  14          //#define BIPOLIAR_ADC
  15          //-----------------------------------------------------------------------------
  16          
  17          //-----------------------------------------------------------------------------
  18          // Global Constants
  19          //-----------------------------------------------------------------------------
  20          
  21          #define BAUDRATE     115200            // Baud rate of UART in bps
  22          
  23          #define INTCLK       24500000          // Internal oscillator frequency in Hz    
  24          
  25          #define SYSCLK       98000000          // Output of PLL derived from (INTCLK*2)
  26          
  27          #define SAMPLE_RATE  11000             // Sample frequency in Hz
  28          
  29          #define N            500               // Number of samples to capture at
  30                                                 // each DAC frequency
  31          
  32          #define PHASE_PRECISION  65536         // Range of phase accumulator
  33          
  34          #define OUTPUT_RATE_DAC  20000L        // DAC output rate in Hz
  35          
  36          #define START_FREQUENCY  10            // Define the starting frequency
  37          #define STOP_FREQUENCY   4999          // Define the ending frequency
  38          #define FREQ_STEP        10            // Define the number of Hz the frequency
  39                                                 // will step for the frequency sweep
  40          #define DAC1_VALUE       0x8000        // value for DAC1                                       
  41          //-----------------------------------------------------------------------------
  42          // Commands
  43          //-----------------------------------------------------------------------------
  44          const uint8_t CMD_1     =0x22;
  45          const uint8_t CMD_2     =0x05;
  46          const uint8_t CMD_3     =0x09;
  47          const uint8_t CMD_4     =0x06;
  48          const uint8_t CMD_5     =0x11;
  49          const uint8_t CMD_6     =0x12;
  50          //-----------------------------------------------------------------------------
  51          // Macros
  52          //-----------------------------------------------------------------------------
  53          
  54          #if defined __C51__
  55          #include <intrins.h>
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/11/2020 11:41:23 PAGE 2   

  56          #define NOP() \
*** WARNING C317 IN LINE 57 OF C8051F12x_FIR_Demo.c: attempt to redefine macro 'NOP'
  57             _nop_();
  58          #elif defined SDCC
              #define NOP() \
                 _asm \
                 nop \
                 _endasm;
              #endif // defined SDCC
  64          
  65          // Single FIR_TAP macro takes advantage of mirroring
  66          // (i.e. the FIR coefficients are mirrored, so the coefficient only needs to be
  67          // loaded into the MAC registers once).
  68          #define FIR_TAP_MIRROR(X,Y,Z) \
  69             MAC0A = X; \
  70             MAC0BH = Y.u8[MSB]; \
  71             MAC0BL = Y.u8[LSB]; \
  72             MAC0BH = Z.u8[MSB]; \
  73             MAC0BL = Z.u8[LSB];
  74          
  75          // Single FIR_TAP macro
  76          #define FIR_TAP(X,Y) \
  77             MAC0A = X; \
  78             MAC0BH = Y.u8[MSB]; \
  79             MAC0BL = Y.u8[LSB];
  80          
  81          #define BREAK_MACRO \
  82             SFRPAGE = UART0_PAGE; \
  83             if(TI0 == 1 || RI0 == 1){ \
  84               break; \
  85             } \
  86             SFRPAGE = SFRPAGE_save;
  87          
  88          //-----------------------------------------------------------------------------
  89          // Global Variables
  90          //-----------------------------------------------------------------------------
  91          // For the FIR filter
  92          // 'x' holds the 'delay line' of input samples
  93          //idata SI_UU16_t x[TAPS];
  94          SI_SEGMENT_VARIABLE(x[FILTER_MAX_ORDER], SI_UU16_t, xdata);
  95          SI_SEGMENT_VARIABLE(B_FIR[FILTER_MAX_ORDER], SI_UU16_t, xdata);
  96          SI_SEGMENT_VARIABLE(TAPS, uint8_t, xdata);
  97          SI_SEGMENT_VARIABLE(data_for_filter[N], SI_UU16_t, xdata);
  98          SI_SEGMENT_VARIABLE(data_for_filter_counter, int, xdata);
  99          SI_SEGMENT_VARIABLE(filtered_samples[N], int, xdata);
 100          SI_SEGMENT_VARIABLE(freq_number, unsigned char, xdata);
 101          SI_SEGMENT_VARIABLE(phase_acc[12], SI_UU16_t, xdata) = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
 102          SI_SEGMENT_VARIABLE(FREQS[12], unsigned long, xdata) = {1343, 1445, 1547, 1649, 1751, 1853, 1955, 2057, 21
             -59, 2261, 2363, 2465};
 103          SI_SEGMENT_VARIABLE(frequency, unsigned long, xdata);
 104          SI_SEGMENT_VARIABLE(delay_index_arr[12], unsigned char, xdata) = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
 105          SI_SEGMENT_VARIABLE(freq_divider, unsigned char, xdata);
 106          SI_SEGMENT_VARIABLE(freq_dac_flags[12], unsigned char, xdata);
 107          
 108          sbit LED = P1^6;                                     // LED='1' means ON
 109          sbit LED485 = P7^7;                                  // LED for 485
 110          
 111          SI_SEGMENT_VARIABLE(Sample, SI_UU16_t, xdata);       // Filter output
 112          SI_SEGMENT_VARIABLE(Phase_Add[12], unsigned int, xdata); // For the frequency sweep
 113          //-----------------------------------------------------------------------------
 114          // Function Prototypes
 115          //-----------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/11/2020 11:41:23 PAGE 3   

 116          
 117          void SYSCLK_Init (void);               // Configure system clock
 118          void PORT_Init (void);                 // Configure port output
 119          void UART0_Init (void);                // Configure UART operation
 120          void Timer0_Init(void);                // Configure Timer0
 121          void ADC0_Init (void);                 // Configure ADC
 122          void DAC0_Init(void);                  // Configure DAC0
 123          void DAC1_Init(void);                  // Configure DAC1
 124          void Timer3_Init (int counts);         // Configure Timer 3
 125          void Timer4_Init (int counts);         // Configure Timer 4
 126          void Set_DAC_Frequency (unsigned long frequency);
 127          void init_after_flash_reload();
 128          
 129          // Define the UART printing functions
 130          #if defined __C51__
 131          char putchar (char c);                 // Define putchar for Keil
 132          #elif defined SDCC
              void putchar (char c);
              #endif // defined SDCC
 135          
 136          SI_INTERRUPT_PROTO(UART0_ISR, INTERRUPT_UART0);
 137          SI_INTERRUPT_PROTO(TIMER0_ISR, INTERRUPT_TIMER0);
 138          SI_INTERRUPT_PROTO(ADC0_ISR, INTERRUPT_ADC0_EOC);
 139          // A full cycle, 16-bit, 2's complement sine wave lookup table
 140          //int code SINE_TABLE[256] = {
 141          SI_SEGMENT_VARIABLE(SINE_TABLE[256], int, code) = {
 142             0x0000, 0x0324, 0x0647, 0x096a, 0x0c8b, 0x0fab, 0x12c8, 0x15e2,
 143             0x18f8, 0x1c0b, 0x1f19, 0x2223, 0x2528, 0x2826, 0x2b1f, 0x2e11,
 144             0x30fb, 0x33de, 0x36ba, 0x398c, 0x3c56, 0x3f17, 0x41ce, 0x447a,
 145             0x471c, 0x49b4, 0x4c3f, 0x4ebf, 0x5133, 0x539b, 0x55f5, 0x5842,
 146             0x5a82, 0x5cb4, 0x5ed7, 0x60ec, 0x62f2, 0x64e8, 0x66cf, 0x68a6,
 147             0x6a6d, 0x6c24, 0x6dca, 0x6f5f, 0x70e2, 0x7255, 0x73b5, 0x7504,
 148             0x7641, 0x776c, 0x7884, 0x798a, 0x7a7d, 0x7b5d, 0x7c29, 0x7ce3,
 149             0x7d8a, 0x7e1d, 0x7e9d, 0x7f09, 0x7f62, 0x7fa7, 0x7fd8, 0x7ff6,
 150             0x7fff, 0x7ff6, 0x7fd8, 0x7fa7, 0x7f62, 0x7f09, 0x7e9d, 0x7e1d,
 151             0x7d8a, 0x7ce3, 0x7c29, 0x7b5d, 0x7a7d, 0x798a, 0x7884, 0x776c,
 152             0x7641, 0x7504, 0x73b5, 0x7255, 0x70e2, 0x6f5f, 0x6dca, 0x6c24,
 153             0x6a6d, 0x68a6, 0x66cf, 0x64e8, 0x62f2, 0x60ec, 0x5ed7, 0x5cb4,
 154             0x5a82, 0x5842, 0x55f5, 0x539b, 0x5133, 0x4ebf, 0x4c3f, 0x49b4,
 155             0x471c, 0x447a, 0x41ce, 0x3f17, 0x3c56, 0x398c, 0x36ba, 0x33de,
 156             0x30fb, 0x2e11, 0x2b1f, 0x2826, 0x2528, 0x2223, 0x1f19, 0x1c0b,
 157             0x18f8, 0x15e2, 0x12c8, 0x0fab, 0x0c8b, 0x096a, 0x0647, 0x0324,
 158             0x0000, 0xfcdc, 0xf9b9, 0xf696, 0xf375, 0xf055, 0xed38, 0xea1e,
 159             0xe708, 0xe3f5, 0xe0e7, 0xdddd, 0xdad8, 0xd7da, 0xd4e1, 0xd1ef,
 160             0xcf05, 0xcc22, 0xc946, 0xc674, 0xc3aa, 0xc0e9, 0xbe32, 0xbb86,
 161             0xb8e4, 0xb64c, 0xb3c1, 0xb141, 0xaecd, 0xac65, 0xaa0b, 0xa7be,
 162             0xa57e, 0xa34c, 0xa129, 0x9f14, 0x9d0e, 0x9b18, 0x9931, 0x975a,
 163             0x9593, 0x93dc, 0x9236, 0x90a1, 0x8f1e, 0x8dab, 0x8c4b, 0x8afc,
 164             0x89bf, 0x8894, 0x877c, 0x8676, 0x8583, 0x84a3, 0x83d7, 0x831d,
 165             0x8276, 0x81e3, 0x8163, 0x80f7, 0x809e, 0x8059, 0x8028, 0x800a,
 166             0x8000, 0x800a, 0x8028, 0x8059, 0x809e, 0x80f7, 0x8163, 0x81e3,
 167             0x8276, 0x831d, 0x83d7, 0x84a3, 0x8583, 0x8676, 0x877c, 0x8894,
 168             0x89bf, 0x8afc, 0x8c4b, 0x8dab, 0x8f1e, 0x90a1, 0x9236, 0x93dc,
 169             0x9593, 0x975a, 0x9931, 0x9b18, 0x9d0e, 0x9f14, 0xa129, 0xa34c,
 170             0xa57e, 0xa7be, 0xaa0b, 0xac65, 0xaecd, 0xb141, 0xb3c1, 0xb64c,
 171             0xb8e4, 0xbb86, 0xbe32, 0xc0e9, 0xc3aa, 0xc674, 0xc946, 0xcc22,
 172             0xcf05, 0xd1ef, 0xd4e1, 0xd7da, 0xdad8, 0xdddd, 0xe0e7, 0xe3f5,
 173             0xe708, 0xea1e, 0xed38, 0xf055, 0xf375, 0xf696, 0xf9b9, 0xfcdc,
 174          };
 175          
 176          // Similar to STARTUP.A51 for Keil, this function stub for SDCC allows us to
 177          // disable the WDT before memory is initialized.
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/11/2020 11:41:23 PAGE 4   

 178          #if defined SDCC
              void _sdcc_external_startup (void);
              
              void _sdcc_external_startup (void)
              {
                 WDTCN = 0xDE;                       // Disable watchdog timer
                 WDTCN = 0xAD;
              }
              #endif // defined SDCC
 187          
 188          //-----------------------------------------------------------------------------
 189          // MAIN Routine
 190          //-----------------------------------------------------------------------------
 191          
 192          void main (void)
 193          {
 194   1         //-----------------------------------------------------------------------------
 195   1         // FIR VARIABLES
 196   1         //-----------------------------------------------------------------------------
 197   1         static unsigned char delay_index = 0;
 198   1         SI_SEGMENT_VARIABLE(coeff_index, unsigned char, xdata);
 199   1         SI_SEGMENT_VARIABLE(sample_index, unsigned char, xdata);
 200   1         SI_SEGMENT_VARIABLE(opposite_sample_index, unsigned char, xdata);
 201   1         SI_SEGMENT_VARIABLE(i, int, xdata);
 202   1         unsigned int RMS_Value = 0; 
 203   1        //-----------------------------------------------------------------------------
 204   1         void (*init_func_pointer)(void) = init_after_flash_reload;
 205   1         //-----------------------------------------------------------------------------
 206   1         
 207   1         WDTCN = 0xDE;                       // Disable watchdog timer
 208   1         WDTCN = 0xAD;
 209   1      
 210   1         SYSCLK_Init ();                     // Initialize oscillator
 211   1         PORT_Init ();                       // Initialize crossbar and GPIO
 212   1         UART0_Init ();                      // Initialize UART0
 213   1         Timer0_Init ();
 214   1        
 215   1         // Initialize Timer3 to overflow at the ADC sample rate
 216   1         Timer3_Init (SYSCLK/SAMPLE_RATE);
 217   1        
 218   1         // Initialize Timer4 to overflow at the DAC sample rate
 219   1         Timer4_Init (SYSCLK/OUTPUT_RATE_DAC);  
 220   1        
 221   1         DAC0_Init ();                       // Initialize the DAC0
 222   1         DAC1_Init ();                       // Initialize the DAC1
 223   1         ADC0_Init ();                       // Initialize the ADC  
 224   1        
 225   1         SFRPAGE = ADC0_PAGE;
 226   1      
 227   1         AD0EN = 1;                          // Enable ADC
 228   1      
 229   1         SFRPAGE = MAC0_PAGE;
 230   1      
 231   1         MAC0CF = 0x06;                      // Fractional mode; Saturate
 232   1                                             // enabled
 233   1         data_for_filter_counter = 0;
 234   1         
 235   1         //
 236   1         freq_number = 0;
 237   1         
 238   1         frequency = START_FREQUENCY;
 239   1         
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/11/2020 11:41:23 PAGE 5   

 240   1         EA = 1;
 241   1        
 242   1         modbus_init_from_flash(init_func_pointer);
 243   1         
 244   1      //-----------------------------------------------------------------------------  
 245   1         while (1) {
 246   2            if (data_for_filter_counter == N) {
 247   3               for (freq_number=0; freq_number<12; freq_number++) {
 248   4                  delay_index = delay_index_arr [freq_number];
 249   4                  // Initialize the delay line for the FIR filter
 250   4                  for (i = 0; i < FILTER_MAX_ORDER; i++)
 251   4                  {
 252   5                     x[i].s16 = 0;
 253   5                  }
 254   4                  // Initialize the sample array
 255   4                  for (i = 0; i < N; i ++)
 256   4                  {
 257   5                     filtered_samples[i] = 0;
 258   5                  }
 259   4                  //EA = 0;           
 260   4                  TAPS = populateFirCoefficients(B_FIR, freq_number);
 261   4                  //EA = 1;
 262   4                  if (TAPS != 61) {
 263   5                     NOP();
 264   5                  }
 265   4                  if (TAPS == 61) {
 266   5                    for (i=0; i<N; i++) {         
 267   6                       // Store ADC result in the delay line
 268   6                       x[delay_index].u16 = data_for_filter[i].u16;
 269   6                       // Sample_index points to newest data
 270   6                       sample_index = delay_index;         
 271   6                       // Update delay index
 272   6                       if (delay_index == (TAPS - 1))
 273   6                       {
 274   7                          delay_index = 0;
 275   7                       }
 276   6                       else
 277   6                       {
 278   7                          delay_index++;
 279   7                       }
 280   6      
 281   6                       MAC0CF |= 0x08;                  // Clear accumulator
 282   6                  
 283   6                       // Mirror algorithm
 284   6                       if (sample_index == TAPS - 1)
 285   6                       {
 286   7                          opposite_sample_index = 0;
 287   7                       }
 288   6                       else
 289   6                       {
 290   7                          opposite_sample_index = sample_index + 1;
 291   7                       }
 292   6                       for (coeff_index = 0; coeff_index < (TAPS / 2); coeff_index++)
 293   6                       {
 294   7                          FIR_TAP_MIRROR (B_FIR[coeff_index].u16, x[sample_index],
 295   7                          x[opposite_sample_index]);
 296   7                         
 297   7                          if (sample_index == 0)
 298   7                          {
 299   8                             sample_index = TAPS - 1;
 300   8                          }
 301   7                          else
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/11/2020 11:41:23 PAGE 6   

 302   7                          {
 303   8                             sample_index--;
 304   8                          }
 305   7      
 306   7                          if (opposite_sample_index == TAPS - 1)
 307   7                          {
 308   8                             opposite_sample_index = 0;
 309   8                          }
 310   7                          else
 311   7                          {
 312   8                             opposite_sample_index++;
 313   8                          }
 314   7                       }
 315   6                       if ((TAPS % 2) == 1)             // Handle middle tap of odd order filter
 316   6                       {
 317   7                          FIR_TAP (B_FIR[coeff_index].u16, x[sample_index]);
 318   7                          NOP ();
 319   7                          NOP ();
 320   7                          NOP ();
 321   7                       }
 322   6                       Sample.u16 = MAC0RND;
 323   6                       filtered_samples[i] = Sample.u16;
 324   6                    }
 325   5                    RMS_Value = RMS_Calc(filtered_samples, N, TAPS);
 326   5                    putRms2Modbus(RMS_Value, freq_number);
 327   5                    delay_index_arr [freq_number] = delay_index;
 328   5                  }
 329   4               }
 330   3               LED = !LED;
 331   3               data_for_filter_counter = 0;
 332   3            }
 333   2         }
 334   1      //-----------------------------------------------------------------------------  
 335   1      }
 336          
 337          //-----------------------------------------------------------------------------
 338          // Initialization Subroutines
 339          //-----------------------------------------------------------------------------
 340          
 341          //-----------------------------------------------------------------------------
 342          // SYSCLK_Init
 343          //-----------------------------------------------------------------------------
 344          //
 345          // Return Value:  None
 346          // Parameters:    None
 347          //
 348          // This routine initializes the system clock to use the internal 24.5MHz*4
 349          // oscillator as its clock source.
 350          //
 351          //-----------------------------------------------------------------------------
 352          void SYSCLK_Init (void)
 353          {
 354   1         SI_SEGMENT_VARIABLE(i, char, xdata);
 355   1        
 356   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 357   1        
 358   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 359   1      
 360   1         SFRPAGE = CONFIG_PAGE;              // Switch to the necessary SFRPAGE
 361   1      
 362   1         OSCICN = 0x83;
 363   1      
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/11/2020 11:41:23 PAGE 7   

 364   1         // Step 2. Set the PLLSRC bit (PLL0CN.2) to select the desired
 365   1         // clock source for the PLL.
 366   1         PLL0CN &= ~0x04;                    // Internal oscillator
 367   1      
 368   1         // Step 3. Program the Flash read timing bits, FLRT (FLSCL.5-4) to the
 369   1         // appropriate value for the new clock rate (see Section 15. Flash Memory
 370   1         // on page 199).
 371   1         SFRPAGE = LEGACY_PAGE;
 372   1         FLSCL |= 0x30;                      // >= 100 MHz
 373   1         SFRPAGE = CONFIG_PAGE;
 374   1      
 375   1         // Step 4. Enable power to the PLL by setting PLLPWR (PLL0CN.0) to ‘1’.
 376   1         PLL0CN |= 0x01;
 377   1      
 378   1         // Step 5. Program the PLL0DIV register to produce the divided reference
 379   1         // frequency to the PLL.
 380   1         PLL0DIV = 0x01;
 381   1      
 382   1         // Step 6. Program the PLLLP3-0 bits (PLL0FLT.3-0) to the appropriate
 383   1         // range for the divided reference frequency.
 384   1         PLL0FLT |= 0x01;
 385   1      
 386   1         // Step 7. Program the PLLICO1-0 bits (PLL0FLT.5-4) to the appropriate
 387   1         // range for the PLL output frequency.
 388   1         PLL0FLT &= ~0x30;
 389   1      
 390   1         // Step 8. Program the PLL0MUL register to the desired clock multiplication
 391   1         // factor.
 392   1         PLL0MUL = 0x04;
 393   1      
 394   1         // Step 9. Wait at least 5 µs, to provide a fast frequency lock.
 395   1         for (i = 100; i > 0; i--);
 396   1      
 397   1         // Step 10. Enable the PLL by setting PLLEN (PLL0CN.1) to ‘1’.
 398   1         PLL0CN |= 0x02;
 399   1      
 400   1         // Step 11. Poll PLLLCK (PLL0CN.4) until it changes from ‘0’ to ‘1’.
 401   1         while ((PLL0CN & 0x10) != 0x10);
 402   1      
 403   1         // Step 12. Switch the System Clock source to the PLL using the CLKSEL
 404   1         // register.
 405   1         CLKSEL = 0x02;
 406   1      
 407   1         SFRPAGE = SFRPAGE_SAVE;             // Restore the SFRPAGE
 408   1      }
 409          
 410          //-----------------------------------------------------------------------------
 411          // PORT_Init
 412          //-----------------------------------------------------------------------------
 413          //
 414          // Return Value:  None
 415          // Parameters:    None
 416          //
 417          // Configure the Crossbar and GPIO ports.
 418          //
 419          // Pinout:
 420          //
 421          // P0.0 - UART TX1 (push-pull)
 422          // P0.1 - UART RX1
 423          //
 424          // P1.6 - LED (push-pull)
 425          //
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/11/2020 11:41:23 PAGE 8   

 426          // DAC0 - DAC0 output
 427          //
 428          // AIN0.0 - ADC0 analog input
 429          //
 430          // Note: DAC0 and AIN0.0 must be tied together.
 431          //
 432          //-----------------------------------------------------------------------------
 433          void PORT_Init (void)
 434          {
 435   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata);
 436   1         SFRPAGE_save = SFRPAGE;             // Save the current SFRPAGE
 437   1      
 438   1         SFRPAGE = CONFIG_PAGE;              // Switch to the necessary SFRPAGE
 439   1      
 440   1         XBR0     = 0x04;
 441   1         XBR1     = 0x00;
 442   1         XBR2     = 0x40;                    // Enable crossbar and weak pull-up
 443   1                                             // Enable UART0
 444   1      
 445   1         P0MDOUT |= 0x01;                    // Set TX1 pin to push-pull
 446   1         P1MDOUT |= 0x40;                    // Set P1.6(LED) to push-pull
 447   1         P5MDOUT |= 0xFF;
 448   1         P6MDOUT |= 0xFF;
 449   1         P7MDOUT |= 0xFF;
 450   1         P5 =  0x00;
 451   1         P6 |= 0x0F;
 452   1         P7 =  0xFF;
 453   1        
 454   1         SFRPAGE = SFRPAGE_save;             // Restore the SFRPAGE
 455   1      }
 456          
 457          //-----------------------------------------------------------------------------
 458          // UART0_Init
 459          //-----------------------------------------------------------------------------
 460          void Timer0_Init(void)
 461          {
 462   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata);
 463   1        SFRPAGE_save = SFRPAGE;
 464   1        
 465   1        SFRPAGE = TIMER01_PAGE;
 466   1        
 467   1        TMOD   &= 0xFD;
 468   1        TMOD   |= 0x01;
 469   1        TH0     = 0x00;
 470   1        TL0     = 0x00;
 471   1        ET0     = 1;
 472   1        TR0     = 1;
 473   1        CKCON  |= 0x08;
 474   1        SFRPAGE = SFRPAGE_save;
 475   1      }
 476          //-----------------------------------------------------------------------------
 477          // UART0_Init
 478          //-----------------------------------------------------------------------------
 479          //
 480          // Return Value:  None
 481          // Parameters:    None
 482          //
 483          // Configure the UART0 using Timer1, for <BAUDRATE> and 8-N-1.
 484          //
 485          //-----------------------------------------------------------------------------
 486          void UART0_Init (void)
 487          {
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/11/2020 11:41:23 PAGE 9   

 488   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata); 
 489   1         SFRPAGE_save = SFRPAGE; // Save the current SFRPAGE
 490   1      
 491   1         SFRPAGE = UART0_PAGE;               // Switch to the necessary SFRPAGE
 492   1          
 493   1         SCON0  = 0x70;
 494   1         TMOD   = 0x20;
 495   1         TH1    = 0x5D;///0xE5;///0x5D;////0xE5;// - 115200;
 496   1         TR1    = 1;
 497   1         CKCON |= 0x10;
 498   1         PCON  |= 0x80;//SMOD0 = 1 
 499   1        
 500   1         TI0    = 0;                         // Indicate TX0 ready
 501   1         
 502   1         PS0    = 1;
 503   1        
 504   1         ES0    = 1; 
 505   1        
 506   1         SFRPAGE = SFRPAGE_save;             // Restore the SFRPAGE
 507   1      }
 508          //-----------------------------------------------------------------------------
 509          // DAC0_Init
 510          //-----------------------------------------------------------------------------
 511          //
 512          // Return Value:  None
 513          // Parameters:    None
 514          //
 515          // Configure DAC1 to update on Timer4 overflows.  VREF is already enabled by
 516          // the ADC initialization code.
 517          //
 518          //-----------------------------------------------------------------------------
 519          void DAC0_Init(void){
 520   1      
 521   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 522   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 523   1      
 524   1         SFRPAGE = DAC0_PAGE;
 525   1      
 526   1         DAC0CN = 0x94;                      // Enable DAC0 in left-justified mode
 527   1                                             // managed by Timer4 overflows
 528   1      
 529   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 530   1      }
 531          
 532          //-----------------------------------------------------------------------------
 533          // DAC1_Init
 534          //-----------------------------------------------------------------------------
 535          //
 536          // Return Value:  None
 537          // Parameters:    None
 538          //
 539          // Configure DAC1 to update on write to DAC1H.  VREF is already enabled by
 540          // the ADC initialization code.
 541          //
 542          //-----------------------------------------------------------------------------
 543          void DAC1_Init(void){
 544   1      
 545   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 546   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 547   1      
 548   1         SFRPAGE = DAC1_PAGE;
 549   1      
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/11/2020 11:41:23 PAGE 10  

 550   1         DAC1CN = 0x84;                      // Enable DAC1 in left-justified mode
 551   1                                             // managed by write data to DAC1H
 552   1         
 553   1         DAC1 = DAC1_VALUE;                  // Write to DAC1
 554   1      
 555   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 556   1      }
 557          
 558          //-----------------------------------------------------------------------------
 559          // ADC0_Init
 560          //-----------------------------------------------------------------------------
 561          //
 562          // Return Value:  None
 563          // Parameters:    None
 564          //
 565          // Configures ADC0 to make single-ended analog measurements on pin AIN0.0 for
 566          // the FIR filter.  Timer3 overflows are the conversion source and the data is
 567          // left-justified.  This function also enables the ADC end-of-conversion
 568          // interrupt and leaves the ADC disabled.
 569          //
 570          //-----------------------------------------------------------------------------
 571          void ADC0_Init (void)
 572          {
 573   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 574   1        
 575   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 576   1      
 577   1         SFRPAGE = ADC0_PAGE;
 578   1      
 579   1         ADC0CN = 0x05;                      // ADC0 disabled; normal tracking
 580   1                                             // mode; ADC0 conversions are initiated
 581   1                                             // on overflow of Timer3; ADC0 data is
 582   1                                             // left-justified
 583   1      
 584   1         REF0CN = 0x03;                      // Enable on-chip VREF and VREF output
 585   1                                             // buffer
 586   1      #ifndef BIPOLIAR_ADC
 587   1         AMX0SL = 0x00;                      // Select AIN0.0 as ADC mux input
 588   1      #else 
                 AMX0CF = 0x01;
                 AMX0SL = 0x00;
              #endif
 592   1        
 593   1         ADC0CF = (SYSCLK/2500000) << 3;     // ADC conversion clock = 2.5MHz
 594   1      
 595   1         EIE2 |= 0x02;                       // Enable ADC interrupts
 596   1      
 597   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 598   1      }
 599          
 600          //-----------------------------------------------------------------------------
 601          // Timer3_Init
 602          //-----------------------------------------------------------------------------
 603          //
 604          // Return Value:  None
 605          // Parameters:    None
 606          //
 607          // Configure Timer3 to auto-reload at interval specified by <counts> (no
 608          // interrupt generated) using SYSCLK as its time base.
 609          //
 610          // Timer 3 overflow automatically triggers ADC0 conversion.
 611          //
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/11/2020 11:41:23 PAGE 11  

 612          //-----------------------------------------------------------------------------
 613          void Timer3_Init (int counts)
 614          {
 615   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 616   1        
 617   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 618   1      
 619   1         SFRPAGE = TMR3_PAGE;
 620   1      
 621   1         TMR3CN = 0x00;                      // Stop Timer3; Clear TF3;
 622   1         TMR3CF = 0x08;                      // use SYSCLK as timebase
 623   1      
 624   1         RCAP3   = -counts;                  // Init reload values
 625   1         TMR3    = RCAP3;                    // set to reload immediately
 626   1         EIE2   &= ~0x01;                    // Disable Timer3 interrupts
 627   1         TR3 = 1;                            // Start Timer3
 628   1      
 629   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 630   1      }
 631          //-----------------------------------------------------------------------------
 632          // Timer4_Init
 633          //-----------------------------------------------------------------------------
 634          //
 635          // Return Value:  None
 636          // Parameters:
 637          //   1) counts - the number of timer clocks to count before a timer interrupt
 638          //           should occur
 639          //
 640          // Configure Timer4 to auto-reload mode and to generate interrupts
 641          // at intervals specified in <counts> using SYSCLK as its time base.
 642          //
 643          // Timer 4 overflow controls the DAC update rate.
 644          //
 645          //-----------------------------------------------------------------------------
 646          void Timer4_Init (int counts)
 647          {
 648   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 649   1        
 650   1         SFRPAGE_SAVE = SFRPAGE;          // Save Current SFR page
 651   1      
 652   1         SFRPAGE = TMR4_PAGE;
 653   1      
 654   1         TMR4CN = 0x00;                   // Stop Timer4; Clear overflow flag (TF4);
 655   1                                          // Set to Auto-Reload Mode
 656   1      
 657   1         TMR4CF = 0x08;                   // Configure Timer4 to increment;
 658   1                                          // Timer4 counts SYSCLKs
 659   1      
 660   1         RCAP4 = -counts;                 // Set reload value
 661   1         TMR4 = RCAP4;                    // Initialzie Timer4 to reload value
 662   1        
 663   1         EIE2 |= 0x04;                    // Enable Timer4 interrupts
 664   1         TR4 = 1;                         // Start Timer4
 665   1      
 666   1         SFRPAGE = SFRPAGE_SAVE;          // Restore SFR page
 667   1      }
 668          //-----------------------------------------------------------------------------
 669          // ADC0_ISR
 670          //-----------------------------------------------------------------------------
 671          //
 672          // ADC0 end-of-conversion ISR
 673          //
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/11/2020 11:41:23 PAGE 12  

 674          // This interrupt service routine is called on ADC0 conversion complete.
 675          // The ADC result is converted to signed and stored in the FIR delay line.
 676          //
 677          // If the global <FIR_On> bit is set to a '1', then the FIR output is computed
 678          // and stored in the global variable 'Sample'.  The 'Sample_Ready' indicator
 679          // bit is set to indicate the value is ready.
 680          //
 681          // If <FIR_On> is set to '0', then the ADC sample is copied to the global
 682          // 'Sample' variable.  The 'Sample_Ready' indicator bit is set to indicate
 683          // that the value is ready.
 684          //
 685          //-----------------------------------------------------------------------------
 686          //void ADC0_ISR (void) interrupt 15
 687          #pragma NOAREGS
 688          SI_INTERRUPT(ADC0_ISR, INTERRUPT_ADC0_EOC)
 689          {
 690   1         volatile SI_UU16_t input;
 691   1        
 692   1         AD0INT = 0;                         // Clear ADC conversion complete
 693   1                                             // indicator
 694   1      
 695   1         input.s16 = ADC0^0x8000;            // Convert to bipolar value
 696   1         
 697   1         
 698   1         if (data_for_filter_counter < N) {
 699   2            data_for_filter [data_for_filter_counter++].u16 = input.u16;
 700   2         }
 701   1      }
 702          
 703          #pragma NOAREGS
 704          SI_INTERRUPT(TIMER0_ISR, INTERRUPT_TIMER0)
 705          {
 706   1        unsigned char SFRPAGE_save = SFRPAGE;
 707   1        SFRPAGE = TIMER01_PAGE;
 708   1        TH0     = 0x00;
 709   1        TL0     = 0x00;
 710   1        TF0     = 0;
 711   1        SFRPAGE = SFRPAGE_save;
 712   1        if(modbus_was_sendind_received()) {
 713   2          modbus_command_received();
 714   2          SFRPAGE = CONFIG_PAGE;
 715   2          LED485  = !LED485;
 716   2        }
 717   1        SFRPAGE = SFRPAGE_save;
 718   1      }
 719          
 720          #pragma NOAREGS
 721          SI_INTERRUPT(UART0_ISR, INTERRUPT_UART0)
 722          {
 723   1        unsigned char SFRPAGE_save = SFRPAGE; // Save the current SFRPAGE
 724   1        SFRPAGE = UART0_PAGE;
 725   1        if(RI0 == 1) {
 726   2          modbus_byte_receive(SBUF0);
 727   2          RI0 = 0;
 728   2        }
 729   1        if(TI0 == 1) {
 730   2          TI0 = 0;
 731   2          if (modbus_transmit_buffer_is_empty()) {
 732   3          }
 733   2          else {
 734   3            modbus_transmit_byte();
 735   3          }
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/11/2020 11:41:23 PAGE 13  

 736   2        }
 737   1        SFRPAGE = SFRPAGE_save;               // Restore the SFRPAGE  
 738   1      }
 739          //-----------------------------------------------------------------------------
 740          // Timer4_ISR
 741          //-----------------------------------------------------------------------------
 742          //
 743          // This ISR is called on Timer4 overflows.  Timer4 is set to auto-reload mode
 744          // and is used to schedule the DAC output sample rate in this example.
 745          // Note that the value that is written to DAC1 during this ISR call is
 746          // actually transferred to DAC1 at the next Timer4 overflow.
 747          //
 748          //-----------------------------------------------------------------------------
 749          //void Timer4_ISR (void) interrupt 16
 750          #pragma NOAREGS
 751          SI_INTERRUPT(Timer4_ISR, INTERRUPT_TIMER4)
 752          { 
 753   1         char number = 0;
 754   1         int temp1 = 0;                      // The temporary value that passes
 755   1                                             // through 3 stages before being written
 756   1                                             // to the IDAC
 757   1         TMR3CN &= ~0x80;                    // Clear Timer3 overflow flag
 758   1        
 759   1         for (number=0; number<12; number++) {
 760   2            if (freq_dac_flags [number] == 1) {
 761   3              phase_acc[number].u16 += Phase_Add [number];
 762   3              temp1 += (SINE_TABLE[phase_acc[number].u8[MSB]] / freq_divider);
 763   3            }
 764   2         }
 765   1           
 766   1         SFRPAGE = DAC0_PAGE;
 767   1      
 768   1         // Add a DC bias to make the rails 0 to 65535
 769   1         // Note: the XOR with 0x8000 translates the bipolar quantity into
 770   1         // a unipolar quantity.
 771   1      
 772   1         DAC0 = 0x8000 ^ temp1;              // Write to DAC0
 773   1      }
 774          
 775          #pragma NOAREGS
 776          void init_after_flash_reload() {
 777   1         //-----------------------------------------------------------------------
 778   1         SI_SEGMENT_VARIABLE(i, uint8_t, xdata);
 779   1         //----------------------- FREQ DIVIDER INIT -----------------------------
 780   1         freq_divider = modbus_get_freq_divider();
 781   1         if (freq_divider == 0) {
 782   2            freq_divider = 1;
 783   2         }
 784   1         //--------------------------- FREQ INIT ---------------------------------
 785   1         modbus_init_freqs(FREQS);
 786   1         //-----------------------------------------------------------------------
 787   1         // CLEAR - INVERSE LOGIC
 788   1         P7 =  0xFF;
 789   1         for (i=0; i<12; i++) {
 790   2            Phase_Add [i] = (unsigned int)((unsigned long)((FREQS [i] *
 791   2                      PHASE_PRECISION) / OUTPUT_RATE_DAC));
 792   2            if (getFreqFromModbusForDAC(i) != 0) {
 793   3               freq_dac_flags [i] = 1;
 794   3            } else {
 795   3               freq_dac_flags [i] = 0;
 796   3            }
 797   2         }
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                05/11/2020 11:41:23 PAGE 14  

 798   1         if (P5 & (uint8_t)CMD_1 == (uint8_t)CMD_1) {
 799   2            bit_clear_P7(0);
 800   2         }
 801   1         if (P5 & CMD_2 == CMD_2) {
 802   2            bit_clear_P7(1);
 803   2         }
 804   1         if (P5 & CMD_3 == CMD_3) {
 805   2            bit_clear_P7(2);
 806   2         }
 807   1         if (P5 & CMD_4 == CMD_4) {
 808   2            bit_clear_P7(3);
 809   2         }
 810   1         if (P5 & CMD_5 == CMD_5) {
 811   2            bit_clear_P7(4);
 812   2         }
 813   1         if (P5 & CMD_6 == CMD_5) {
 814   2            bit_clear_P7(5);
 815   2         }
 816   1         //-----------------------------------------------------------------------
 817   1      }
 818          //-----------------------------------------------------------------------------
 819          // putchar
 820          //-----------------------------------------------------------------------------
 821          //
 822          // Return Value:
 823          //   1) char c - returns the char c that was passed as a parameter
 824          // Parameters:
 825          //   1) char c - the character to be printed
 826          //
 827          // Print the character <c> using UART0 at <BAUDRATE>.
 828          //
 829          //-----------------------------------------------------------------------------
 830          #if defined __C51__
 831          char putchar (char c)
 832          #elif defined SDCC
              void putchar (char c)
              #endif
 835          {
 836   1         modbus_push_transmit_buffer(c);
 837   1      #if defined __C51__
 838   1         return c;                           // Print the character
 839   1      #endif
 840   1      }
 841          //-----------------------------------------------------------------------------
 842          // End Of File
 843          //-----------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1902    ----
   CONSTANT SIZE    =    512    ----
   XDATA SIZE       =   2375      16
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
