C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/23/2020 18:55:24 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE C8051F12X_FIR_DEMO
OBJECT MODULE PLACED IN C8051F12x_FIR_Demo.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE C8051F12x_FIR_Demo.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // Includes
   3          //-----------------------------------------------------------------------------
   4          
   5          #include "si_toolchain.h"             // Compiler-specific declarations
   6                                                 // (Keil/SDCC)
   7          #include "C8051F120_defs.h"            // SFR declarations
   8          #include <stdio.h>
   9          #include <math.h>
  10          #include "fir.h"
  11          #include "modbus.h"
  12          
  13          //-------------------------- BIPOLIAR SELECTOR --------------------------------
  14          //#define BIPOLIAR_ADC
  15          //-----------------------------------------------------------------------------
  16          
  17          //-----------------------------------------------------------------------------
  18          // Global Constants
  19          //-----------------------------------------------------------------------------
  20          
  21          #define BAUDRATE     115200            // Baud rate of UART in bps
  22          
  23          #define INTCLK       24500000          // Internal oscillator frequency in Hz    
  24          
  25          #define SYSCLK       98000000          // Output of PLL derived from (INTCLK*2)
  26          
  27          #define SAMPLE_RATE  11000             // Sample frequency in Hz
  28          
  29          #define N            500               // Number of samples to capture at
  30                                                 // each DAC frequency
  31          
  32          #define PHASE_PRECISION  65536         // Range of phase accumulator
  33          
  34          #define OUTPUT_RATE_DAC  20000L        // DAC output rate in Hz
  35          
  36          #define START_FREQUENCY  10            // Define the starting frequency
  37          #define STOP_FREQUENCY   4999          // Define the ending frequency
  38          #define FREQ_STEP        10            // Define the number of Hz the frequency
  39                                                 // will step for the frequency sweep
  40          #define DAC1_VALUE       0x8000        // value for DAC1
  41          #define SECOND_INTERVAL  1024
  42          #define MILLISECONDS_10  10
  43          //-----------------------------------------------------------------------------
  44          // Macros
  45          //-----------------------------------------------------------------------------
  46          
  47          #if defined __C51__
  48          #include <intrins.h>
  49          #define NOP() \
*** WARNING C317 IN LINE 50 OF C8051F12x_FIR_Demo.c: attempt to redefine macro 'NOP'
  50             _nop_();
  51          #elif defined SDCC
              #define NOP() \
                 _asm \
                 nop \
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/23/2020 18:55:24 PAGE 2   

                 _endasm;
              #endif // defined SDCC
  57          
  58          // Single FIR_TAP macro takes advantage of mirroring
  59          // (i.e. the FIR coefficients are mirrored, so the coefficient only needs to be
  60          // loaded into the MAC registers once).
  61          #define FIR_TAP_MIRROR(X,Y,Z) \
  62             MAC0A = X; \
  63             MAC0BH = Y.u8[MSB]; \
  64             MAC0BL = Y.u8[LSB]; \
  65             MAC0BH = Z.u8[MSB]; \
  66             MAC0BL = Z.u8[LSB];
  67          
  68          // Single FIR_TAP macro
  69          #define FIR_TAP(X,Y) \
  70             MAC0A = X; \
  71             MAC0BH = Y.u8[MSB]; \
  72             MAC0BL = Y.u8[LSB];
  73          
  74          #define BREAK_MACRO \
  75             SFRPAGE = UART0_PAGE; \
  76             if(TI0 == 1 || RI0 == 1){ \
  77               break; \
  78             } \
  79             SFRPAGE = SFRPAGE_save;
  80          
  81          //-----------------------------------------------------------------------------
  82          // Global Variables
  83          //-----------------------------------------------------------------------------
  84          // For the FIR filter
  85          // 'x' holds the 'delay line' of input samples
  86          //idata SI_UU16_t x[TAPS];
  87          SI_SEGMENT_VARIABLE(x[FILTER_MAX_ORDER], SI_UU16_t, xdata);
  88          SI_SEGMENT_VARIABLE(B_FIR[FILTER_MAX_ORDER], SI_UU16_t, xdata);
  89          SI_SEGMENT_VARIABLE(TAPS, uint8_t, xdata);
  90          SI_SEGMENT_VARIABLE(data_for_filter[N], SI_UU16_t, xdata);
  91          SI_SEGMENT_VARIABLE(data_for_filter_counter, int, xdata);
  92          SI_SEGMENT_VARIABLE(filtered_samples[N], int, xdata);
  93          SI_SEGMENT_VARIABLE(freq_number, unsigned char, xdata);
  94          SI_SEGMENT_VARIABLE(phase_acc[12], SI_UU16_t, xdata) = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  95          SI_SEGMENT_VARIABLE(FREQS[12], unsigned long, xdata) = {1343, 1445, 1547, 1649, 1751, 1853, 1955, 2057, 21
             -59, 2261, 2363, 2465};
  96          SI_SEGMENT_VARIABLE(frequency, unsigned long, xdata);
  97          SI_SEGMENT_VARIABLE(delay_index_arr[12], unsigned char, xdata) = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
  98          SI_SEGMENT_VARIABLE(freq_divider, unsigned char, xdata);
  99          SI_SEGMENT_VARIABLE(freq_dac_flags[12], unsigned char, xdata);
 100          
 101          sbit LED = P1^6;                                         // LED='1' means ON
 102          sbit LED485 = P7^7;                                      // LED for 485
 103          sbit SELECT485 = P4^4;                                   // Select 485 transmit/receive
 104          
 105          SI_SEGMENT_VARIABLE(Sample, SI_UU16_t, xdata);           // Filter output
 106          SI_SEGMENT_VARIABLE(Phase_Add[12], unsigned int, xdata); // For the frequency sweep
 107          SI_SEGMENT_VARIABLE(TimerForDC24Output, unsigned int, xdata);
 108          SI_SEGMENT_VARIABLE(DividerForDC24Output, unsigned int, xdata);
 109          SI_SEGMENT_VARIABLE(isNeedGetADCValuesFlag, unsigned int, xdata);
 110          SI_SEGMENT_VARIABLE(TIMER, unsigned short, xdata);
 111          //-----------------------------------------------------------------------------
 112          // Function Prototypes
 113          //-----------------------------------------------------------------------------
 114          
 115          void SYSCLK_Init (void);               // Configure system clock
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/23/2020 18:55:24 PAGE 3   

 116          void PORT_Init (void);                 // Configure port output
 117          void UART0_Init (void);                // Configure UART operation
 118          void Timer0_Init(void);                // Configure Timer0
 119          void ADC0_Init (void);                 // Configure ADC
 120          void DAC0_Init(void);                  // Configure DAC0
 121          void DAC1_Init(void);                  // Configure DAC1
 122          void Timer3_Init (int counts);         // Configure Timer 3
 123          void Timer4_Init (int counts);         // Configure Timer 4
 124          void Set_DAC_Frequency (unsigned long frequency);
 125          void init_after_flash_reload();
 126          void delay(unsigned short timer);
 127          void toTransmit485();
 128          void toReceive485();
 129          
 130          // Define the UART printing functions
 131          #if defined __C51__
 132          char putchar (char c);                 // Define putchar for Keil
 133          #elif defined SDCC
              void putchar (char c);
              #endif // defined SDCC
 136          
 137          SI_INTERRUPT_PROTO(UART0_ISR, INTERRUPT_UART0);
 138          SI_INTERRUPT_PROTO(TIMER0_ISR, INTERRUPT_TIMER0);
 139          SI_INTERRUPT_PROTO(ADC0_ISR, INTERRUPT_ADC0_EOC);
 140          // A full cycle, 16-bit, 2's complement sine wave lookup table
 141          //int code SINE_TABLE[256] = {
 142          SI_SEGMENT_VARIABLE(SINE_TABLE[256], int, code) = {
 143             0x0000, 0x0324, 0x0647, 0x096a, 0x0c8b, 0x0fab, 0x12c8, 0x15e2,
 144             0x18f8, 0x1c0b, 0x1f19, 0x2223, 0x2528, 0x2826, 0x2b1f, 0x2e11,
 145             0x30fb, 0x33de, 0x36ba, 0x398c, 0x3c56, 0x3f17, 0x41ce, 0x447a,
 146             0x471c, 0x49b4, 0x4c3f, 0x4ebf, 0x5133, 0x539b, 0x55f5, 0x5842,
 147             0x5a82, 0x5cb4, 0x5ed7, 0x60ec, 0x62f2, 0x64e8, 0x66cf, 0x68a6,
 148             0x6a6d, 0x6c24, 0x6dca, 0x6f5f, 0x70e2, 0x7255, 0x73b5, 0x7504,
 149             0x7641, 0x776c, 0x7884, 0x798a, 0x7a7d, 0x7b5d, 0x7c29, 0x7ce3,
 150             0x7d8a, 0x7e1d, 0x7e9d, 0x7f09, 0x7f62, 0x7fa7, 0x7fd8, 0x7ff6,
 151             0x7fff, 0x7ff6, 0x7fd8, 0x7fa7, 0x7f62, 0x7f09, 0x7e9d, 0x7e1d,
 152             0x7d8a, 0x7ce3, 0x7c29, 0x7b5d, 0x7a7d, 0x798a, 0x7884, 0x776c,
 153             0x7641, 0x7504, 0x73b5, 0x7255, 0x70e2, 0x6f5f, 0x6dca, 0x6c24,
 154             0x6a6d, 0x68a6, 0x66cf, 0x64e8, 0x62f2, 0x60ec, 0x5ed7, 0x5cb4,
 155             0x5a82, 0x5842, 0x55f5, 0x539b, 0x5133, 0x4ebf, 0x4c3f, 0x49b4,
 156             0x471c, 0x447a, 0x41ce, 0x3f17, 0x3c56, 0x398c, 0x36ba, 0x33de,
 157             0x30fb, 0x2e11, 0x2b1f, 0x2826, 0x2528, 0x2223, 0x1f19, 0x1c0b,
 158             0x18f8, 0x15e2, 0x12c8, 0x0fab, 0x0c8b, 0x096a, 0x0647, 0x0324,
 159             0x0000, 0xfcdc, 0xf9b9, 0xf696, 0xf375, 0xf055, 0xed38, 0xea1e,
 160             0xe708, 0xe3f5, 0xe0e7, 0xdddd, 0xdad8, 0xd7da, 0xd4e1, 0xd1ef,
 161             0xcf05, 0xcc22, 0xc946, 0xc674, 0xc3aa, 0xc0e9, 0xbe32, 0xbb86,
 162             0xb8e4, 0xb64c, 0xb3c1, 0xb141, 0xaecd, 0xac65, 0xaa0b, 0xa7be,
 163             0xa57e, 0xa34c, 0xa129, 0x9f14, 0x9d0e, 0x9b18, 0x9931, 0x975a,
 164             0x9593, 0x93dc, 0x9236, 0x90a1, 0x8f1e, 0x8dab, 0x8c4b, 0x8afc,
 165             0x89bf, 0x8894, 0x877c, 0x8676, 0x8583, 0x84a3, 0x83d7, 0x831d,
 166             0x8276, 0x81e3, 0x8163, 0x80f7, 0x809e, 0x8059, 0x8028, 0x800a,
 167             0x8000, 0x800a, 0x8028, 0x8059, 0x809e, 0x80f7, 0x8163, 0x81e3,
 168             0x8276, 0x831d, 0x83d7, 0x84a3, 0x8583, 0x8676, 0x877c, 0x8894,
 169             0x89bf, 0x8afc, 0x8c4b, 0x8dab, 0x8f1e, 0x90a1, 0x9236, 0x93dc,
 170             0x9593, 0x975a, 0x9931, 0x9b18, 0x9d0e, 0x9f14, 0xa129, 0xa34c,
 171             0xa57e, 0xa7be, 0xaa0b, 0xac65, 0xaecd, 0xb141, 0xb3c1, 0xb64c,
 172             0xb8e4, 0xbb86, 0xbe32, 0xc0e9, 0xc3aa, 0xc674, 0xc946, 0xcc22,
 173             0xcf05, 0xd1ef, 0xd4e1, 0xd7da, 0xdad8, 0xdddd, 0xe0e7, 0xe3f5,
 174             0xe708, 0xea1e, 0xed38, 0xf055, 0xf375, 0xf696, 0xf9b9, 0xfcdc,
 175          };
 176          
 177          // Similar to STARTUP.A51 for Keil, this function stub for SDCC allows us to
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/23/2020 18:55:24 PAGE 4   

 178          // disable the WDT before memory is initialized.
 179          #if defined SDCC
              void _sdcc_external_startup (void);
              
              void _sdcc_external_startup (void)
              {
                 WDTCN = 0xDE;                       // Disable watchdog timer
                 WDTCN = 0xAD;
              }
              #endif // defined SDCC
 188          
 189          //-----------------------------------------------------------------------------
 190          // MAIN Routine
 191          //-----------------------------------------------------------------------------
 192          
 193          void main (void)
 194          {
 195   1         //-----------------------------------------------------------------------------
 196   1         // FIR VARIABLES
 197   1         //-----------------------------------------------------------------------------
 198   1         static unsigned char delay_index = 0;
 199   1         SI_SEGMENT_VARIABLE(coeff_index, unsigned char, xdata);
 200   1         SI_SEGMENT_VARIABLE(sample_index, unsigned char, xdata);
 201   1         SI_SEGMENT_VARIABLE(opposite_sample_index, unsigned char, xdata);
 202   1         SI_SEGMENT_VARIABLE(i, int, xdata);
 203   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 204   1         SI_SEGMENT_VARIABLE(hi, uint8_t, xdata);
 205   1         SI_SEGMENT_VARIABLE(lo, uint8_t, xdata);
 206   1         SI_SEGMENT_VARIABLE(freq_quantity, uint8_t, xdata);
 207   1         unsigned int RMS_Value = 0;
 208   1        //------------------------------------------------------------------------------
 209   1         void (*init_func_pointer)(void) = init_after_flash_reload;
 210   1         //-----------------------------------------------------------------------------
 211   1         WDTCN = 0xDE;                       // Disable watchdog timer
 212   1         WDTCN = 0xAD;
 213   1      
 214   1         SYSCLK_Init ();                     // Initialize oscillator
 215   1         PORT_Init ();                       // Initialize crossbar and GPIO
 216   1         UART0_Init ();                      // Initialize UART0
 217   1         Timer0_Init ();
 218   1        
 219   1         // Initialize Timer3 to overflow at the ADC sample rate
 220   1         Timer3_Init (SYSCLK/SAMPLE_RATE);
 221   1        
 222   1         // Initialize Timer4 to overflow at the DAC sample rate
 223   1         Timer4_Init (SYSCLK/OUTPUT_RATE_DAC);  
 224   1        
 225   1         DAC0_Init ();                       // Initialize the DAC0
 226   1         DAC1_Init ();                       // Initialize the DAC1
 227   1         ADC0_Init ();                       // Initialize the ADC  
 228   1        
 229   1         SFRPAGE = ADC0_PAGE;
 230   1      
 231   1         AD0EN = 1;                          // Enable ADC
 232   1      
 233   1         SFRPAGE = MAC0_PAGE;
 234   1      
 235   1         MAC0CF = 0x06;                      // Fractional mode; Saturate
 236   1                                             // enabled
 237   1         data_for_filter_counter = 0;
 238   1         
 239   1         //
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/23/2020 18:55:24 PAGE 5   

 240   1         freq_number = 0;
 241   1         
 242   1         frequency = START_FREQUENCY;
 243   1         
 244   1         isNeedGetADCValuesFlag = 0;
 245   1         
 246   1         EA = 1;
 247   1        
 248   1         modbus_init_from_flash(init_func_pointer);
 249   1         
 250   1      //-----------------------------------------------------------------------------  
 251   1         while (1) {
 252   2            //-----------------------------------------------------------------------
 253   2            if (getDC24INPUT() == 0) {
 254   3              setDC24InputRegister(1);
 255   3            } else {
 256   3              setDC24InputRegister(0);
 257   3            }
 258   2            if (getCondition() == DP_CONDITION) {
 259   3              freq_quantity = 6;
 260   3            }
 261   2            else {
 262   3              freq_quantity = 12;
 263   3            }
 264   2            //------------------------------------------------------------------------
 265   2            if (data_for_filter_counter == N) {
 266   3               for (freq_number = 0; freq_number < freq_quantity; freq_number++) {
 267   4                  delay_index = delay_index_arr [freq_number];
 268   4                  // Initialize the delay line for the FIR filter
 269   4                  for (i = 0; i < FILTER_MAX_ORDER; i++)
 270   4                  {
 271   5                     x[i].s16 = 0;
 272   5                  }
 273   4                  // Initialize the sample array
 274   4                  for (i = 0; i < N; i ++)
 275   4                  {
 276   5                     filtered_samples[i] = 0;
 277   5                     //-----------------------------------------------------------------------------------------------
             ----
 278   5                     if (isNeedGetADCValuesFlag != 0) {
 279   6                       SFRPAGE_SAVE = SFRPAGE;
 280   6                       SFRPAGE = UART0_PAGE;
 281   6                       if(i == 0) {
 282   7                         modbus_push_transmit_buffer(0xAA);
 283   7                         modbus_push_transmit_buffer(0xAA);
 284   7                       }
 285   6                       hi = ((data_for_filter [i].u16 >> 8) & 0x00FF);
 286   6                       lo = (data_for_filter [i].u16 & 0x00FF);
 287   6                       modbus_push_transmit_buffer(hi);
 288   6                       modbus_push_transmit_buffer(lo);                
 289   6                       if ((i + 1) % 128 == 0) {
 290   7                         TI0 = 1;
 291   7                         delay(100);
 292   7                       }
 293   6                       if (i == N - 1) {
 294   7                         modbus_push_transmit_buffer(0xBB);
 295   7                         modbus_push_transmit_buffer(0xBB);
 296   7                         isNeedGetADCValuesFlag = 0;
 297   7                         TI0 = 1;
 298   7                         delay(100);
 299   7                       }
 300   6                       SFRPAGE = SFRPAGE_SAVE;
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/23/2020 18:55:24 PAGE 6   

 301   6                     }
 302   5                     //------------------------------------------------------------------------------------------------
             ---
 303   5                  }
 304   4                  //--------------------------------------------------------------------------------------------------
 305   4                  TAPS = populateFirCoefficients(B_FIR, freq_number);
 306   4                  if (TAPS != 61) {
 307   5                     NOP();
 308   5                  }
 309   4                  if (TAPS == 61) {
 310   5                    for (i=0; i<N; i++) {         
 311   6                       // Store ADC result in the delay line
 312   6                       x[delay_index].u16 = data_for_filter[i].u16;
 313   6                       // Sample_index points to newest data
 314   6                       sample_index = delay_index;         
 315   6                       // Update delay index
 316   6                       if (delay_index == (TAPS - 1))
 317   6                       {
 318   7                          delay_index = 0;
 319   7                       }
 320   6                       else
 321   6                       {
 322   7                          delay_index++;
 323   7                       }
 324   6      
 325   6                       MAC0CF |= 0x08;                  // Clear accumulator
 326   6                  
 327   6                       // Mirror algorithm
 328   6                       if (sample_index == TAPS - 1)
 329   6                       {
 330   7                          opposite_sample_index = 0;
 331   7                       }
 332   6                       else
 333   6                       {
 334   7                          opposite_sample_index = sample_index + 1;
 335   7                       }
 336   6                       for (coeff_index = 0; coeff_index < (TAPS / 2); coeff_index++)
 337   6                       {
 338   7                          FIR_TAP_MIRROR (B_FIR[coeff_index].u16, x[sample_index],
 339   7                          x[opposite_sample_index]);
 340   7                         
 341   7                          if (sample_index == 0)
 342   7                          {
 343   8                             sample_index = TAPS - 1;
 344   8                          }
 345   7                          else
 346   7                          {
 347   8                             sample_index--;
 348   8                          }
 349   7      
 350   7                          if (opposite_sample_index == TAPS - 1)
 351   7                          {
 352   8                             opposite_sample_index = 0;
 353   8                          }
 354   7                          else
 355   7                          {
 356   8                             opposite_sample_index++;
 357   8                          }
 358   7                       }
 359   6                       if ((TAPS % 2) == 1)             // Handle middle tap of odd order filter
 360   6                       {
 361   7                          FIR_TAP (B_FIR[coeff_index].u16, x[sample_index]);
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/23/2020 18:55:24 PAGE 7   

 362   7                          NOP ();
 363   7                          NOP ();
 364   7                          NOP ();
 365   7                       }
 366   6                       Sample.u16 = MAC0RND;
 367   6                       filtered_samples[i] = Sample.u16;
 368   6                    }
 369   5                    RMS_Value = RMS_Calc(filtered_samples, N, TAPS);
 370   5                    putRms2Modbus(RMS_Value, freq_number);
 371   5                    delay_index_arr [freq_number] = delay_index;
 372   5                  }
 373   4               }
 374   3               LED = !LED;
 375   3               data_for_filter_counter = 0;
 376   3            }
 377   2         }
 378   1      //-----------------------------------------------------------------------------  
 379   1      }
 380          
 381          //-----------------------------------------------------------------------------
 382          // Initialization Subroutines
 383          //-----------------------------------------------------------------------------
 384          
 385          //-----------------------------------------------------------------------------
 386          // SYSCLK_Init
 387          //-----------------------------------------------------------------------------
 388          //
 389          // Return Value:  None
 390          // Parameters:    None
 391          //
 392          // This routine initializes the system clock to use the internal 24.5MHz*4
 393          // oscillator as its clock source.
 394          //
 395          //-----------------------------------------------------------------------------
 396          void SYSCLK_Init (void)
 397          {
 398   1         SI_SEGMENT_VARIABLE(i, char, xdata);
 399   1        
 400   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 401   1        
 402   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 403   1      
 404   1         SFRPAGE = CONFIG_PAGE;              // Switch to the necessary SFRPAGE
 405   1      
 406   1         OSCICN = 0x83;
 407   1      
 408   1         // Step 2. Set the PLLSRC bit (PLL0CN.2) to select the desired
 409   1         // clock source for the PLL.
 410   1         PLL0CN &= ~0x04;                    // Internal oscillator
 411   1      
 412   1         // Step 3. Program the Flash read timing bits, FLRT (FLSCL.5-4) to the
 413   1         // appropriate value for the new clock rate (see Section 15. Flash Memory
 414   1         // on page 199).
 415   1         SFRPAGE = LEGACY_PAGE;
 416   1         FLSCL |= 0x30;                      // >= 100 MHz
 417   1         SFRPAGE = CONFIG_PAGE;
 418   1      
 419   1         // Step 4. Enable power to the PLL by setting PLLPWR (PLL0CN.0) to ‘1’.
 420   1         PLL0CN |= 0x01;
 421   1      
 422   1         // Step 5. Program the PLL0DIV register to produce the divided reference
 423   1         // frequency to the PLL.
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/23/2020 18:55:24 PAGE 8   

 424   1         PLL0DIV = 0x01;
 425   1      
 426   1         // Step 6. Program the PLLLP3-0 bits (PLL0FLT.3-0) to the appropriate
 427   1         // range for the divided reference frequency.
 428   1         PLL0FLT |= 0x01;
 429   1      
 430   1         // Step 7. Program the PLLICO1-0 bits (PLL0FLT.5-4) to the appropriate
 431   1         // range for the PLL output frequency.
 432   1         PLL0FLT &= ~0x30;
 433   1      
 434   1         // Step 8. Program the PLL0MUL register to the desired clock multiplication
 435   1         // factor.
 436   1         PLL0MUL = 0x04;
 437   1      
 438   1         // Step 9. Wait at least 5 µs, to provide a fast frequency lock.
 439   1         for (i = 100; i > 0; i--);
 440   1      
 441   1         // Step 10. Enable the PLL by setting PLLEN (PLL0CN.1) to ‘1’.
 442   1         PLL0CN |= 0x02;
 443   1      
 444   1         // Step 11. Poll PLLLCK (PLL0CN.4) until it changes from ‘0’ to ‘1’.
 445   1         while ((PLL0CN & 0x10) != 0x10);
 446   1      
 447   1         // Step 12. Switch the System Clock source to the PLL using the CLKSEL
 448   1         // register.
 449   1         CLKSEL = 0x02;
 450   1      
 451   1         SFRPAGE = SFRPAGE_SAVE;             // Restore the SFRPAGE
 452   1      }
 453          
 454          //-----------------------------------------------------------------------------
 455          // PORT_Init
 456          //-----------------------------------------------------------------------------
 457          //
 458          // Return Value:  None
 459          // Parameters:    None
 460          //
 461          // Configure the Crossbar and GPIO ports.
 462          //
 463          // Pinout:
 464          //
 465          // P0.0 - UART TX1 (push-pull)
 466          // P0.1 - UART RX1
 467          //
 468          // P1.6 - LED (push-pull)
 469          //
 470          // DAC0 - DAC0 output
 471          //
 472          // AIN0.0 - ADC0 analog input
 473          //
 474          // Note: DAC0 and AIN0.0 must be tied together.
 475          //
 476          //-----------------------------------------------------------------------------
 477          void PORT_Init (void)
 478          {
 479   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata);
 480   1         SFRPAGE_save = SFRPAGE;             // Save the current SFRPAGE
 481   1      
 482   1         SFRPAGE = CONFIG_PAGE;              // Switch to the necessary SFRPAGE
 483   1      
 484   1         XBR0     = 0x04;
 485   1         XBR1     = 0x00;
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/23/2020 18:55:24 PAGE 9   

 486   1         XBR2     = 0x40;                    // Enable crossbar and weak pull-up
 487   1                                             // Enable UART0
 488   1      
 489   1         P0MDOUT |= 0x01;                    // Set TX1 pin to push-pull
 490   1         P1MDOUT |= 0x40;                    // Set P1.6(LED) to push-pull
 491   1         
 492   1         P3MDOUT &= ~0x80;                   // Set P3.7 to input
 493   1         
 494   1         P4MDOUT |= 0x04;                    // Set P4.2 to push-pull
 495   1         P4MDOUT |= 0x10;                    // Set P4.4 to push-pull
 496   1         P4MDOUT &= ~0x08;                   // Set P4.3 to input
 497   1        
 498   1         P5MDOUT |= 0xFF;
 499   1         P6MDOUT |= 0xFF;
 500   1         P7MDOUT |= 0xFF;
 501   1         P5 =  0x00;
 502   1         P6 |= 0x0F;
 503   1         P7 =  0xFF;
 504   1         DC24OUTPUT = 1;
 505   1         DC24INPUT = 1;
 506   1         SELECT485 = 0;                      // to receive
 507   1         CONDSELECTOR = 1;                   // set to KP condition
 508   1         
 509   1         SFRPAGE = SFRPAGE_save;             // Restore the SFRPAGE
 510   1      }
 511          
 512          //-----------------------------------------------------------------------------
 513          // UART0_Init
 514          //-----------------------------------------------------------------------------
 515          void Timer0_Init(void)
 516          {
 517   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata);
 518   1        SFRPAGE_save = SFRPAGE;
 519   1        
 520   1        SFRPAGE = TIMER01_PAGE;
 521   1        
 522   1        TMOD   &= 0xFD;
 523   1        TMOD   |= 0x01;
 524   1        TH0     = 0x00;
 525   1        TL0     = 0x00;
 526   1        ET0     = 1;
 527   1        TR0     = 1;
 528   1        CKCON  |= 0x08;
 529   1        SFRPAGE = SFRPAGE_save;
 530   1      }
 531          //-----------------------------------------------------------------------------
 532          // UART0_Init
 533          //-----------------------------------------------------------------------------
 534          //
 535          // Return Value:  None
 536          // Parameters:    None
 537          //
 538          // Configure the UART0 using Timer1, for <BAUDRATE> and 8-N-1.
 539          //
 540          //-----------------------------------------------------------------------------
 541          void UART0_Init (void)
 542          {
 543   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata); 
 544   1         SFRPAGE_save = SFRPAGE; // Save the current SFRPAGE
 545   1      
 546   1         SFRPAGE = UART0_PAGE;               // Switch to the necessary SFRPAGE
 547   1          
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/23/2020 18:55:24 PAGE 10  

 548   1         SCON0  = 0x70;
 549   1         TMOD   = 0x20;
 550   1         TH1    = 0x5D;///0xE5;///0x5D;////0xE5;// - 115200;
 551   1         TR1    = 1;
 552   1         CKCON |= 0x10;
 553   1         PCON  |= 0x80;//SMOD0 = 1 
 554   1        
 555   1         TI0    = 0;                         // Indicate TX0 ready
 556   1         
 557   1         PS0    = 1;
 558   1        
 559   1         ES0    = 1; 
 560   1        
 561   1         SFRPAGE = SFRPAGE_save;             // Restore the SFRPAGE
 562   1      }
 563          //-----------------------------------------------------------------------------
 564          // DAC0_Init
 565          //-----------------------------------------------------------------------------
 566          //
 567          // Return Value:  None
 568          // Parameters:    None
 569          //
 570          // Configure DAC1 to update on Timer4 overflows.  VREF is already enabled by
 571          // the ADC initialization code.
 572          //
 573          //-----------------------------------------------------------------------------
 574          void DAC0_Init(void){
 575   1      
 576   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 577   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 578   1      
 579   1         SFRPAGE = DAC0_PAGE;
 580   1      
 581   1         DAC0CN = 0x94;                      // Enable DAC0 in left-justified mode
 582   1                                             // managed by Timer4 overflows
 583   1      
 584   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 585   1      }
 586          
 587          //-----------------------------------------------------------------------------
 588          // DAC1_Init
 589          //-----------------------------------------------------------------------------
 590          //
 591          // Return Value:  None
 592          // Parameters:    None
 593          //
 594          // Configure DAC1 to update on write to DAC1H.  VREF is already enabled by
 595          // the ADC initialization code.
 596          //
 597          //-----------------------------------------------------------------------------
 598          void DAC1_Init(void){
 599   1      
 600   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 601   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 602   1      
 603   1         SFRPAGE = DAC1_PAGE;
 604   1      
 605   1         DAC1CN = 0x84;                      // Enable DAC1 in left-justified mode
 606   1                                             // managed by write data to DAC1H
 607   1         
 608   1         DAC1 = DAC1_VALUE;                  // Write to DAC1
 609   1      
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/23/2020 18:55:24 PAGE 11  

 610   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 611   1      }
 612          
 613          //-----------------------------------------------------------------------------
 614          // ADC0_Init
 615          //-----------------------------------------------------------------------------
 616          //
 617          // Return Value:  None
 618          // Parameters:    None
 619          //
 620          // Configures ADC0 to make single-ended analog measurements on pin AIN0.0 for
 621          // the FIR filter.  Timer3 overflows are the conversion source and the data is
 622          // left-justified.  This function also enables the ADC end-of-conversion
 623          // interrupt and leaves the ADC disabled.
 624          //
 625          //-----------------------------------------------------------------------------
 626          void ADC0_Init (void)
 627          {
 628   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 629   1        
 630   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 631   1      
 632   1         SFRPAGE = ADC0_PAGE;
 633   1      
 634   1         ADC0CN = 0x05;                      // ADC0 disabled; normal tracking
 635   1                                             // mode; ADC0 conversions are initiated
 636   1                                             // on overflow of Timer3; ADC0 data is
 637   1                                             // left-justified
 638   1      
 639   1         REF0CN = 0x03;                      // Enable on-chip VREF and VREF output
 640   1                                             // buffer
 641   1      #ifndef BIPOLIAR_ADC
 642   1         AMX0SL = 0x00;                      // Select AIN0.0 as ADC mux input
 643   1      #else 
                 AMX0CF = 0x01;
                 AMX0SL = 0x00;
              #endif
 647   1        
 648   1         ADC0CF = (SYSCLK/2500000) << 3;     // ADC conversion clock = 2.5MHz
 649   1      
 650   1         EIE2 |= 0x02;                       // Enable ADC interrupts
 651   1      
 652   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 653   1      }
 654          
 655          //-----------------------------------------------------------------------------
 656          // Timer3_Init
 657          //-----------------------------------------------------------------------------
 658          //
 659          // Return Value:  None
 660          // Parameters:    None
 661          //
 662          // Configure Timer3 to auto-reload at interval specified by <counts> (no
 663          // interrupt generated) using SYSCLK as its time base.
 664          //
 665          // Timer 3 overflow automatically triggers ADC0 conversion.
 666          //
 667          //-----------------------------------------------------------------------------
 668          void Timer3_Init (int counts)
 669          {
 670   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 671   1        
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/23/2020 18:55:24 PAGE 12  

 672   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 673   1      
 674   1         SFRPAGE = TMR3_PAGE;
 675   1      
 676   1         TMR3CN = 0x00;                      // Stop Timer3; Clear TF3;
 677   1         TMR3CF = 0x08;                      // use SYSCLK as timebase
 678   1      
 679   1         RCAP3   = -counts;                  // Init reload values
 680   1         TMR3    = RCAP3;                    // set to reload immediately
 681   1         EIE2   &= ~0x01;                    // Disable Timer3 interrupts
 682   1         TR3 = 1;                            // Start Timer3
 683   1      
 684   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 685   1      }
 686          //-----------------------------------------------------------------------------
 687          // Timer4_Init
 688          //-----------------------------------------------------------------------------
 689          //
 690          // Return Value:  None
 691          // Parameters:
 692          //   1) counts - the number of timer clocks to count before a timer interrupt
 693          //           should occur
 694          //
 695          // Configure Timer4 to auto-reload mode and to generate interrupts
 696          // at intervals specified in <counts> using SYSCLK as its time base.
 697          //
 698          // Timer 4 overflow controls the DAC update rate.
 699          //
 700          //-----------------------------------------------------------------------------
 701          void Timer4_Init (int counts)
 702          {
 703   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 704   1        
 705   1         SFRPAGE_SAVE = SFRPAGE;          // Save Current SFR page
 706   1      
 707   1         SFRPAGE = TMR4_PAGE;
 708   1      
 709   1         TMR4CN = 0x00;                   // Stop Timer4; Clear overflow flag (TF4);
 710   1                                          // Set to Auto-Reload Mode
 711   1      
 712   1         TMR4CF = 0x08;                   // Configure Timer4 to increment;
 713   1                                          // Timer4 counts SYSCLKs
 714   1      
 715   1         RCAP4 = -counts;                 // Set reload value
 716   1         TMR4 = RCAP4;                    // Initialzie Timer4 to reload value
 717   1        
 718   1         EIE2 |= 0x04;                    // Enable Timer4 interrupts
 719   1         TR4 = 1;                         // Start Timer4
 720   1      
 721   1         SFRPAGE = SFRPAGE_SAVE;          // Restore SFR page
 722   1      }
 723          //-----------------------------------------------------------------------------
 724          // ADC0_ISR
 725          //-----------------------------------------------------------------------------
 726          //
 727          // ADC0 end-of-conversion ISR
 728          //
 729          // This interrupt service routine is called on ADC0 conversion complete.
 730          // The ADC result is converted to signed and stored in the FIR delay line.
 731          //
 732          // If the global <FIR_On> bit is set to a '1', then the FIR output is computed
 733          // and stored in the global variable 'Sample'.  The 'Sample_Ready' indicator
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/23/2020 18:55:24 PAGE 13  

 734          // bit is set to indicate the value is ready.
 735          //
 736          // If <FIR_On> is set to '0', then the ADC sample is copied to the global
 737          // 'Sample' variable.  The 'Sample_Ready' indicator bit is set to indicate
 738          // that the value is ready.
 739          //
 740          //-----------------------------------------------------------------------------
 741          //void ADC0_ISR (void) interrupt 15
 742          #pragma NOAREGS
 743          SI_INTERRUPT(ADC0_ISR, INTERRUPT_ADC0_EOC)
 744          {
 745   1         volatile SI_UU16_t input;
 746   1        
 747   1         AD0INT = 0;                         // Clear ADC conversion complete
 748   1                                             // indicator
 749   1      
 750   1         input.s16 = ADC0^0x8000;            // Convert to bipolar value
 751   1         
 752   1         
 753   1         if (data_for_filter_counter < N) {
 754   2            data_for_filter [data_for_filter_counter++].u16 = input.u16;
 755   2         }
 756   1      }
 757          
 758          #pragma NOAREGS
 759          SI_INTERRUPT(TIMER0_ISR, INTERRUPT_TIMER0)
 760          {
 761   1        unsigned char SFRPAGE_save = SFRPAGE;
 762   1        SFRPAGE = TIMER01_PAGE;
 763   1        TH0     = 0x00;
 764   1        TL0     = 0x00;
 765   1        TF0     = 0;
 766   1        SFRPAGE = SFRPAGE_save;
 767   1        if(modbus_was_sendind_received()) {
 768   2          modbus_command_received();
 769   2          SFRPAGE = CONFIG_PAGE;
 770   2          LED485  = !LED485;
 771   2        }
 772   1        SFRPAGE = CONFIG_PAGE;
 773   1        if (DC24OUTPUT == 0) {
 774   2          if (TimerForDC24Output++ % DividerForDC24Output == 0) {
 775   3            DC24OUTPUT = 1;
 776   3          }
 777   2        }
 778   1        TIMER++;
 779   1        SFRPAGE = SFRPAGE_save;
 780   1      }
 781          
 782          #pragma NOAREGS
 783          SI_INTERRUPT(UART0_ISR, INTERRUPT_UART0)
 784          {
 785   1        unsigned char SFRPAGE_save = SFRPAGE; // Save the current SFRPAGE
 786   1        SFRPAGE = UART0_PAGE;
 787   1        if(RI0 == 1) {
 788   2          modbus_byte_receive(SBUF0);
 789   2          RI0 = 0;
 790   2        }
 791   1        if(TI0 == 1) {
 792   2          TI0 = 0;
 793   2          toTransmit485();
 794   2          if (modbus_transmit_buffer_is_empty()) {
 795   3            toReceive485();
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/23/2020 18:55:24 PAGE 14  

 796   3          }
 797   2          else {
 798   3            modbus_transmit_byte();
 799   3          }
 800   2        }
 801   1        SFRPAGE = SFRPAGE_save;               // Restore the SFRPAGE  
 802   1      }
 803          //-----------------------------------------------------------------------------
 804          // Timer4_ISR
 805          //-----------------------------------------------------------------------------
 806          //
 807          // This ISR is called on Timer4 overflows.  Timer4 is set to auto-reload mode
 808          // and is used to schedule the DAC output sample rate in this example.
 809          // Note that the value that is written to DAC1 during this ISR call is
 810          // actually transferred to DAC1 at the next Timer4 overflow.
 811          //
 812          //-----------------------------------------------------------------------------
 813          //void Timer4_ISR (void) interrupt 16
 814          #pragma NOAREGS
 815          SI_INTERRUPT(Timer4_ISR, INTERRUPT_TIMER4)
 816          { 
 817   1         char number = 0;
 818   1         int temp1 = 0;                      // The temporary value that passes
 819   1                                             // through 3 stages before being written
 820   1                                             // to the IDAC
 821   1         TMR3CN &= ~0x80;                    // Clear Timer3 overflow flag
 822   1        
 823   1         for (number=0; number<12; number++) {
 824   2            if (freq_dac_flags [number] == 1) {
 825   3              phase_acc[number].u16 += Phase_Add [number];
 826   3              temp1 += (SINE_TABLE[phase_acc[number].u8[MSB]] / freq_divider);
 827   3            }
 828   2         }
 829   1           
 830   1         SFRPAGE = DAC0_PAGE;
 831   1      
 832   1         // Add a DC bias to make the rails 0 to 65535
 833   1         // Note: the XOR with 0x8000 translates the bipolar quantity into
 834   1         // a unipolar quantity.
 835   1      
 836   1         DAC0 = 0x8000 ^ temp1;              // Write to DAC0
 837   1      }
 838          
 839          #pragma NOAREGS
 840          void init_after_flash_reload() {
 841   1         //-----------------------------------------------------------------------
 842   1         SI_SEGMENT_VARIABLE(i, uint8_t, xdata);
 843   1         SI_SEGMENT_VARIABLE(d, uint8_t, xdata);
 844   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 845   1         //-----------------------------------------------------------------------
 846   1         SFRPAGE_save = SFRPAGE;
 847   1         d = 0;
 848   1         //----------------------- FREQ DIVIDER INIT -----------------------------
 849   1         freq_divider = modbus_get_freq_divider();
 850   1         if (freq_divider == 0) {
 851   2            freq_divider = 1;
 852   2         }
 853   1         //--------------------------- FREQ INIT ---------------------------------
 854   1         modbus_init_freqs(FREQS);
 855   1         for (i=0; i<12; i++) {
 856   2            Phase_Add [i] = (unsigned int)((unsigned long)((FREQS [i] *
 857   2                      PHASE_PRECISION) / OUTPUT_RATE_DAC));
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/23/2020 18:55:24 PAGE 15  

 858   2            if (getFreqFromModbusForDAC(i) != 0) {
 859   3               freq_dac_flags [i] = 1;
 860   3               if (i < 8) {
 861   4                  d = bit_set(d, i);
 862   4               }
 863   3            } else {
 864   3               freq_dac_flags [i] = 0;
 865   3            }
 866   2            if (getCondition() == DP_CONDITION) {
 867   3               // DP
 868   3               flashP5P6(i, freq_dac_flags [i]);
 869   3            }
 870   2         }
 871   1         if (getCondition() == KP_CONDITION) {
 872   2            // KP
 873   2            flashDiodesOnCommand(d, KP_CONDITION);
 874   2         }
 875   1         d = getDC24DurationTimeIfEnabed();
 876   1         if (d != 0) {
 877   2            setDC24OUTPUT(0);
 878   2            DividerForDC24Output = d * MILLISECONDS_10;
 879   2            TimerForDC24Output = 1;
 880   2         }
 881   1         //--------------------------------------------------------------------------
 882   1         if (isNeedGetADCValues() == 1) {
 883   2           isNeedGetADCValuesFlag = 1;
 884   2         }
 885   1         SFRPAGE = SFRPAGE_save;
 886   1         //--------------------------------------------------------------------------
 887   1      }
 888          //-----------------------------------------------------------------------------
 889          // delay
 890          void delay(unsigned short timer) {
 891   1        TIMER = 0;
 892   1        while(TIMER < timer); 
 893   1      }
 894          //-----------------------------------------------------------------------------
 895          // transmit 485
 896          void toTransmit485() {
 897   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 898   1        SFRPAGE_save = SFRPAGE;
 899   1        SFRPAGE = CONFIG_PAGE;
 900   1        SELECT485 = 1;
 901   1        SFRPAGE = SFRPAGE_save;
 902   1      }
 903          //-----------------------------------------------------------------------------
 904          // receive 485
 905          void toReceive485() {
 906   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 907   1        SFRPAGE_save = SFRPAGE;
 908   1        SFRPAGE = CONFIG_PAGE;
 909   1        SELECT485 = 0;
 910   1        SFRPAGE = SFRPAGE_save;
 911   1      }
 912          //-----------------------------------------------------------------------------
 913          // putchar
 914          //-----------------------------------------------------------------------------
 915          //
 916          // Return Value:
 917          //   1) char c - returns the char c that was passed as a parameter
 918          // Parameters:
 919          //   1) char c - the character to be printed
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/23/2020 18:55:24 PAGE 16  

 920          //
 921          // Print the character <c> using UART0 at <BAUDRATE>.
 922          //
 923          //-----------------------------------------------------------------------------
 924          #if defined __C51__
 925          char putchar (char c)
 926          #elif defined SDCC
              void putchar (char c)
              #endif
 929          {
 930   1         modbus_push_transmit_buffer(c);
 931   1      #if defined __C51__
 932   1         return c;                           // Print the character
 933   1      #endif
 934   1      }
 935          //-----------------------------------------------------------------------------
 936          // End Of File
 937          //-----------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2259    ----
   CONSTANT SIZE    =    512    ----
   XDATA SIZE       =   2383      24
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
