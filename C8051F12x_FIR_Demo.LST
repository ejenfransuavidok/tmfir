C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/05/2020 06:56:11 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE C8051F12X_FIR_DEMO
OBJECT MODULE PLACED IN C8051F12x_FIR_Demo.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE C8051F12x_FIR_Demo.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // Includes
   3          //-----------------------------------------------------------------------------
   4          
   5          #include "si_toolchain.h"             // Compiler-specific declarations
   6                                                 // (Keil/SDCC)
   7          #include "C8051F120_defs.h"            // SFR declarations
   8          #include <stdio.h>
   9          #include <math.h>
  10          #include "fir.h"
  11          #include "modbus.h"
  12          
  13          //-------------------------- BIPOLIAR SELECTOR --------------------------------
  14          //#define BIPOLIAR_ADC
  15          //-----------------------------------------------------------------------------
  16          
  17          //-----------------------------------------------------------------------------
  18          // Global Constants
  19          //-----------------------------------------------------------------------------
  20          
  21          #define BAUDRATE     115200            // Baud rate of UART in bps
  22          
  23          #define INTCLK       24500000          // Internal oscillator frequency in Hz    
  24          
  25          #define SYSCLK       98000000          // Output of PLL derived from (INTCLK*2)
  26          
  27          #define SAMPLE_RATE  11000             // Sample frequency in Hz
  28          
  29          #define N            500               // Number of samples to capture at
  30                                                 // each DAC frequency
  31          
  32          #define PHASE_PRECISION  65536         // Range of phase accumulator
  33          
  34          #define OUTPUT_RATE_DAC  20000L        // DAC output rate in Hz
  35          
  36          #define START_FREQUENCY  10            // Define the starting frequency
  37          #define STOP_FREQUENCY   4999          // Define the ending frequency
  38          #define FREQ_STEP        10            // Define the number of Hz the frequency
  39                                                 // will step for the frequency sweep
  40          #define DAC1_VALUE       0x8000        // value for DAC1
  41          #define SECOND_INTERVAL  1024
  42          //-----------------------------------------------------------------------------
  43          // Commands
  44          //-----------------------------------------------------------------------------
  45          const uint8_t CMD_1     =0x22;
  46          const uint8_t CMD_2     =0x05;
  47          const uint8_t CMD_3     =0x09;
  48          const uint8_t CMD_4     =0x06;
  49          const uint8_t CMD_5     =0x11;
  50          const uint8_t CMD_6     =0x12;
  51          //-----------------------------------------------------------------------------
  52          // Macros
  53          //-----------------------------------------------------------------------------
  54          
  55          #if defined __C51__
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/05/2020 06:56:11 PAGE 2   

  56          #include <intrins.h>
  57          #define NOP() \
*** WARNING C317 IN LINE 58 OF C8051F12x_FIR_Demo.c: attempt to redefine macro 'NOP'
  58             _nop_();
  59          #elif defined SDCC
              #define NOP() \
                 _asm \
                 nop \
                 _endasm;
              #endif // defined SDCC
  65          
  66          // Single FIR_TAP macro takes advantage of mirroring
  67          // (i.e. the FIR coefficients are mirrored, so the coefficient only needs to be
  68          // loaded into the MAC registers once).
  69          #define FIR_TAP_MIRROR(X,Y,Z) \
  70             MAC0A = X; \
  71             MAC0BH = Y.u8[MSB]; \
  72             MAC0BL = Y.u8[LSB]; \
  73             MAC0BH = Z.u8[MSB]; \
  74             MAC0BL = Z.u8[LSB];
  75          
  76          // Single FIR_TAP macro
  77          #define FIR_TAP(X,Y) \
  78             MAC0A = X; \
  79             MAC0BH = Y.u8[MSB]; \
  80             MAC0BL = Y.u8[LSB];
  81          
  82          #define BREAK_MACRO \
  83             SFRPAGE = UART0_PAGE; \
  84             if(TI0 == 1 || RI0 == 1){ \
  85               break; \
  86             } \
  87             SFRPAGE = SFRPAGE_save;
  88          
  89          //-----------------------------------------------------------------------------
  90          // Global Variables
  91          //-----------------------------------------------------------------------------
  92          // For the FIR filter
  93          // 'x' holds the 'delay line' of input samples
  94          //idata SI_UU16_t x[TAPS];
  95          SI_SEGMENT_VARIABLE(x[FILTER_MAX_ORDER], SI_UU16_t, xdata);
  96          SI_SEGMENT_VARIABLE(B_FIR[FILTER_MAX_ORDER], SI_UU16_t, xdata);
  97          SI_SEGMENT_VARIABLE(TAPS, uint8_t, xdata);
  98          SI_SEGMENT_VARIABLE(data_for_filter[N], SI_UU16_t, xdata);
  99          SI_SEGMENT_VARIABLE(data_for_filter_counter, int, xdata);
 100          SI_SEGMENT_VARIABLE(filtered_samples[N], int, xdata);
 101          SI_SEGMENT_VARIABLE(freq_number, unsigned char, xdata);
 102          SI_SEGMENT_VARIABLE(phase_acc[12], SI_UU16_t, xdata) = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
 103          SI_SEGMENT_VARIABLE(FREQS[12], unsigned long, xdata) = {1343, 1445, 1547, 1649, 1751, 1853, 1955, 2057, 21
             -59, 2261, 2363, 2465};
 104          SI_SEGMENT_VARIABLE(frequency, unsigned long, xdata);
 105          SI_SEGMENT_VARIABLE(delay_index_arr[12], unsigned char, xdata) = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
 106          SI_SEGMENT_VARIABLE(freq_divider, unsigned char, xdata);
 107          SI_SEGMENT_VARIABLE(freq_dac_flags[12], unsigned char, xdata);
 108          
 109          sbit LED = P1^6;                                         // LED='1' means ON
 110          sbit LED485 = P7^7;                                      // LED for 485
 111          sbit DC24OUTPUT = P4^2;
 112          sbit DC24INPUT = P4^3;
 113          sbit SELECT485 = P4^4;                                   // Select 485 transmit/receive
 114          
 115          SI_SEGMENT_VARIABLE(Sample, SI_UU16_t, xdata);           // Filter output
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/05/2020 06:56:11 PAGE 3   

 116          SI_SEGMENT_VARIABLE(Phase_Add[12], unsigned int, xdata); // For the frequency sweep
 117          SI_SEGMENT_VARIABLE(TimerForDC24Output, unsigned int, xdata);
 118          SI_SEGMENT_VARIABLE(DividerForDC24Output, unsigned int, xdata);
 119          SI_SEGMENT_VARIABLE(isNeedGetADCValuesFlag, unsigned int, xdata);
 120          SI_SEGMENT_VARIABLE(TIMER, unsigned short, xdata);
 121          //-----------------------------------------------------------------------------
 122          // Function Prototypes
 123          //-----------------------------------------------------------------------------
 124          
 125          void SYSCLK_Init (void);               // Configure system clock
 126          void PORT_Init (void);                 // Configure port output
 127          void UART0_Init (void);                // Configure UART operation
 128          void Timer0_Init(void);                // Configure Timer0
 129          void ADC0_Init (void);                 // Configure ADC
 130          void DAC0_Init(void);                  // Configure DAC0
 131          void DAC1_Init(void);                  // Configure DAC1
 132          void Timer3_Init (int counts);         // Configure Timer 3
 133          void Timer4_Init (int counts);         // Configure Timer 4
 134          void Set_DAC_Frequency (unsigned long frequency);
 135          void init_after_flash_reload();
 136          void delay(unsigned short timer);
 137          void toTransmit485();
 138          void toReceive485();
 139          
 140          // Define the UART printing functions
 141          #if defined __C51__
 142          char putchar (char c);                 // Define putchar for Keil
 143          #elif defined SDCC
              void putchar (char c);
              #endif // defined SDCC
 146          
 147          SI_INTERRUPT_PROTO(UART0_ISR, INTERRUPT_UART0);
 148          SI_INTERRUPT_PROTO(TIMER0_ISR, INTERRUPT_TIMER0);
 149          SI_INTERRUPT_PROTO(ADC0_ISR, INTERRUPT_ADC0_EOC);
 150          // A full cycle, 16-bit, 2's complement sine wave lookup table
 151          //int code SINE_TABLE[256] = {
 152          SI_SEGMENT_VARIABLE(SINE_TABLE[256], int, code) = {
 153             0x0000, 0x0324, 0x0647, 0x096a, 0x0c8b, 0x0fab, 0x12c8, 0x15e2,
 154             0x18f8, 0x1c0b, 0x1f19, 0x2223, 0x2528, 0x2826, 0x2b1f, 0x2e11,
 155             0x30fb, 0x33de, 0x36ba, 0x398c, 0x3c56, 0x3f17, 0x41ce, 0x447a,
 156             0x471c, 0x49b4, 0x4c3f, 0x4ebf, 0x5133, 0x539b, 0x55f5, 0x5842,
 157             0x5a82, 0x5cb4, 0x5ed7, 0x60ec, 0x62f2, 0x64e8, 0x66cf, 0x68a6,
 158             0x6a6d, 0x6c24, 0x6dca, 0x6f5f, 0x70e2, 0x7255, 0x73b5, 0x7504,
 159             0x7641, 0x776c, 0x7884, 0x798a, 0x7a7d, 0x7b5d, 0x7c29, 0x7ce3,
 160             0x7d8a, 0x7e1d, 0x7e9d, 0x7f09, 0x7f62, 0x7fa7, 0x7fd8, 0x7ff6,
 161             0x7fff, 0x7ff6, 0x7fd8, 0x7fa7, 0x7f62, 0x7f09, 0x7e9d, 0x7e1d,
 162             0x7d8a, 0x7ce3, 0x7c29, 0x7b5d, 0x7a7d, 0x798a, 0x7884, 0x776c,
 163             0x7641, 0x7504, 0x73b5, 0x7255, 0x70e2, 0x6f5f, 0x6dca, 0x6c24,
 164             0x6a6d, 0x68a6, 0x66cf, 0x64e8, 0x62f2, 0x60ec, 0x5ed7, 0x5cb4,
 165             0x5a82, 0x5842, 0x55f5, 0x539b, 0x5133, 0x4ebf, 0x4c3f, 0x49b4,
 166             0x471c, 0x447a, 0x41ce, 0x3f17, 0x3c56, 0x398c, 0x36ba, 0x33de,
 167             0x30fb, 0x2e11, 0x2b1f, 0x2826, 0x2528, 0x2223, 0x1f19, 0x1c0b,
 168             0x18f8, 0x15e2, 0x12c8, 0x0fab, 0x0c8b, 0x096a, 0x0647, 0x0324,
 169             0x0000, 0xfcdc, 0xf9b9, 0xf696, 0xf375, 0xf055, 0xed38, 0xea1e,
 170             0xe708, 0xe3f5, 0xe0e7, 0xdddd, 0xdad8, 0xd7da, 0xd4e1, 0xd1ef,
 171             0xcf05, 0xcc22, 0xc946, 0xc674, 0xc3aa, 0xc0e9, 0xbe32, 0xbb86,
 172             0xb8e4, 0xb64c, 0xb3c1, 0xb141, 0xaecd, 0xac65, 0xaa0b, 0xa7be,
 173             0xa57e, 0xa34c, 0xa129, 0x9f14, 0x9d0e, 0x9b18, 0x9931, 0x975a,
 174             0x9593, 0x93dc, 0x9236, 0x90a1, 0x8f1e, 0x8dab, 0x8c4b, 0x8afc,
 175             0x89bf, 0x8894, 0x877c, 0x8676, 0x8583, 0x84a3, 0x83d7, 0x831d,
 176             0x8276, 0x81e3, 0x8163, 0x80f7, 0x809e, 0x8059, 0x8028, 0x800a,
 177             0x8000, 0x800a, 0x8028, 0x8059, 0x809e, 0x80f7, 0x8163, 0x81e3,
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/05/2020 06:56:11 PAGE 4   

 178             0x8276, 0x831d, 0x83d7, 0x84a3, 0x8583, 0x8676, 0x877c, 0x8894,
 179             0x89bf, 0x8afc, 0x8c4b, 0x8dab, 0x8f1e, 0x90a1, 0x9236, 0x93dc,
 180             0x9593, 0x975a, 0x9931, 0x9b18, 0x9d0e, 0x9f14, 0xa129, 0xa34c,
 181             0xa57e, 0xa7be, 0xaa0b, 0xac65, 0xaecd, 0xb141, 0xb3c1, 0xb64c,
 182             0xb8e4, 0xbb86, 0xbe32, 0xc0e9, 0xc3aa, 0xc674, 0xc946, 0xcc22,
 183             0xcf05, 0xd1ef, 0xd4e1, 0xd7da, 0xdad8, 0xdddd, 0xe0e7, 0xe3f5,
 184             0xe708, 0xea1e, 0xed38, 0xf055, 0xf375, 0xf696, 0xf9b9, 0xfcdc,
 185          };
 186          
 187          // Similar to STARTUP.A51 for Keil, this function stub for SDCC allows us to
 188          // disable the WDT before memory is initialized.
 189          #if defined SDCC
              void _sdcc_external_startup (void);
              
              void _sdcc_external_startup (void)
              {
                 WDTCN = 0xDE;                       // Disable watchdog timer
                 WDTCN = 0xAD;
              }
              #endif // defined SDCC
 198          
 199          //-----------------------------------------------------------------------------
 200          // MAIN Routine
 201          //-----------------------------------------------------------------------------
 202          
 203          void main (void)
 204          {
 205   1         //-----------------------------------------------------------------------------
 206   1         // FIR VARIABLES
 207   1         //-----------------------------------------------------------------------------
 208   1         static unsigned char delay_index = 0;
 209   1         SI_SEGMENT_VARIABLE(coeff_index, unsigned char, xdata);
 210   1         SI_SEGMENT_VARIABLE(sample_index, unsigned char, xdata);
 211   1         SI_SEGMENT_VARIABLE(opposite_sample_index, unsigned char, xdata);
 212   1         SI_SEGMENT_VARIABLE(i, int, xdata);
 213   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 214   1         SI_SEGMENT_VARIABLE(hi, uint8_t, xdata);
 215   1         SI_SEGMENT_VARIABLE(lo, uint8_t, xdata);
 216   1         unsigned int RMS_Value = 0;
 217   1        //------------------------------------------------------------------------------
 218   1         void (*init_func_pointer)(void) = init_after_flash_reload;
 219   1         //-----------------------------------------------------------------------------
 220   1         WDTCN = 0xDE;                       // Disable watchdog timer
 221   1         WDTCN = 0xAD;
 222   1      
 223   1         SYSCLK_Init ();                     // Initialize oscillator
 224   1         PORT_Init ();                       // Initialize crossbar and GPIO
 225   1         UART0_Init ();                      // Initialize UART0
 226   1         Timer0_Init ();
 227   1        
 228   1         // Initialize Timer3 to overflow at the ADC sample rate
 229   1         Timer3_Init (SYSCLK/SAMPLE_RATE);
 230   1        
 231   1         // Initialize Timer4 to overflow at the DAC sample rate
 232   1         Timer4_Init (SYSCLK/OUTPUT_RATE_DAC);  
 233   1        
 234   1         DAC0_Init ();                       // Initialize the DAC0
 235   1         DAC1_Init ();                       // Initialize the DAC1
 236   1         ADC0_Init ();                       // Initialize the ADC  
 237   1        
 238   1         SFRPAGE = ADC0_PAGE;
 239   1      
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/05/2020 06:56:11 PAGE 5   

 240   1         AD0EN = 1;                          // Enable ADC
 241   1      
 242   1         SFRPAGE = MAC0_PAGE;
 243   1      
 244   1         MAC0CF = 0x06;                      // Fractional mode; Saturate
 245   1                                             // enabled
 246   1         data_for_filter_counter = 0;
 247   1         
 248   1         //
 249   1         freq_number = 0;
 250   1         
 251   1         frequency = START_FREQUENCY;
 252   1         
 253   1         isNeedGetADCValuesFlag = 0;
 254   1         
 255   1         EA = 1;
 256   1        
 257   1         modbus_init_from_flash(init_func_pointer);
 258   1         
 259   1      //-----------------------------------------------------------------------------  
 260   1         while (1) {
 261   2            //-----------------------------------------------------------------------
 262   2            SFRPAGE_SAVE = SFRPAGE;
 263   2            SFRPAGE = CONFIG_PAGE;
 264   2            if (DC24INPUT == 0) {
 265   3              setDC24InputRegister(1);
 266   3            } else {
 267   3              setDC24InputRegister(0);
 268   3            }
 269   2            SFRPAGE = SFRPAGE_SAVE;
 270   2            //------------------------------------------------------------------------
 271   2            if (data_for_filter_counter == N) {
 272   3               for (freq_number=0; freq_number<12; freq_number++) {
 273   4                  delay_index = delay_index_arr [freq_number];
 274   4                  // Initialize the delay line for the FIR filter
 275   4                  for (i = 0; i < FILTER_MAX_ORDER; i++)
 276   4                  {
 277   5                     x[i].s16 = 0;
 278   5                  }
 279   4                  // Initialize the sample array
 280   4                  for (i = 0; i < N; i ++)
 281   4                  {
 282   5                     filtered_samples[i] = 0;
 283   5                     //-----------------------------------------------------------------------------------------------
             ----
 284   5                     if (isNeedGetADCValuesFlag != 0) {
 285   6                       SFRPAGE_SAVE = SFRPAGE;
 286   6                       SFRPAGE = UART0_PAGE;
 287   6                       if(i == 0) {
 288   7                         modbus_push_transmit_buffer(0xAA);
 289   7                         modbus_push_transmit_buffer(0xAA);
 290   7                       }
 291   6                       hi = ((data_for_filter [i].u16 >> 8) & 0x00FF);
 292   6                       lo = (data_for_filter [i].u16 & 0x00FF);
 293   6                       modbus_push_transmit_buffer(hi);
 294   6                       modbus_push_transmit_buffer(lo);                
 295   6                       if ((i + 1) % 128 == 0) {
 296   7                         TI0 = 1;
 297   7                         delay(100);
 298   7                       }
 299   6                       if (i == N - 1) {
 300   7                         modbus_push_transmit_buffer(0xBB);
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/05/2020 06:56:11 PAGE 6   

 301   7                         modbus_push_transmit_buffer(0xBB);
 302   7                         isNeedGetADCValuesFlag = 0;
 303   7                         TI0 = 1;
 304   7                         delay(100);
 305   7                       }
 306   6                       SFRPAGE = SFRPAGE_SAVE;
 307   6                     }
 308   5                     //------------------------------------------------------------------------------------------------
             ---
 309   5                  }
 310   4                  //--------------------------------------------------------------------------------------------------
 311   4                  TAPS = populateFirCoefficients(B_FIR, freq_number);
 312   4                  if (TAPS != 61) {
 313   5                     NOP();
 314   5                  }
 315   4                  if (TAPS == 61) {
 316   5                    for (i=0; i<N; i++) {         
 317   6                       // Store ADC result in the delay line
 318   6                       x[delay_index].u16 = data_for_filter[i].u16;
 319   6                       // Sample_index points to newest data
 320   6                       sample_index = delay_index;         
 321   6                       // Update delay index
 322   6                       if (delay_index == (TAPS - 1))
 323   6                       {
 324   7                          delay_index = 0;
 325   7                       }
 326   6                       else
 327   6                       {
 328   7                          delay_index++;
 329   7                       }
 330   6      
 331   6                       MAC0CF |= 0x08;                  // Clear accumulator
 332   6                  
 333   6                       // Mirror algorithm
 334   6                       if (sample_index == TAPS - 1)
 335   6                       {
 336   7                          opposite_sample_index = 0;
 337   7                       }
 338   6                       else
 339   6                       {
 340   7                          opposite_sample_index = sample_index + 1;
 341   7                       }
 342   6                       for (coeff_index = 0; coeff_index < (TAPS / 2); coeff_index++)
 343   6                       {
 344   7                          FIR_TAP_MIRROR (B_FIR[coeff_index].u16, x[sample_index],
 345   7                          x[opposite_sample_index]);
 346   7                         
 347   7                          if (sample_index == 0)
 348   7                          {
 349   8                             sample_index = TAPS - 1;
 350   8                          }
 351   7                          else
 352   7                          {
 353   8                             sample_index--;
 354   8                          }
 355   7      
 356   7                          if (opposite_sample_index == TAPS - 1)
 357   7                          {
 358   8                             opposite_sample_index = 0;
 359   8                          }
 360   7                          else
 361   7                          {
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/05/2020 06:56:11 PAGE 7   

 362   8                             opposite_sample_index++;
 363   8                          }
 364   7                       }
 365   6                       if ((TAPS % 2) == 1)             // Handle middle tap of odd order filter
 366   6                       {
 367   7                          FIR_TAP (B_FIR[coeff_index].u16, x[sample_index]);
 368   7                          NOP ();
 369   7                          NOP ();
 370   7                          NOP ();
 371   7                       }
 372   6                       Sample.u16 = MAC0RND;
 373   6                       filtered_samples[i] = Sample.u16;
 374   6                    }
 375   5                    RMS_Value = RMS_Calc(filtered_samples, N, TAPS);
 376   5                    putRms2Modbus(RMS_Value, freq_number);
 377   5                    delay_index_arr [freq_number] = delay_index;
 378   5                  }
 379   4               }
 380   3               LED = !LED;
 381   3               data_for_filter_counter = 0;
 382   3            }
 383   2         }
 384   1      //-----------------------------------------------------------------------------  
 385   1      }
 386          
 387          //-----------------------------------------------------------------------------
 388          // Initialization Subroutines
 389          //-----------------------------------------------------------------------------
 390          
 391          //-----------------------------------------------------------------------------
 392          // SYSCLK_Init
 393          //-----------------------------------------------------------------------------
 394          //
 395          // Return Value:  None
 396          // Parameters:    None
 397          //
 398          // This routine initializes the system clock to use the internal 24.5MHz*4
 399          // oscillator as its clock source.
 400          //
 401          //-----------------------------------------------------------------------------
 402          void SYSCLK_Init (void)
 403          {
 404   1         SI_SEGMENT_VARIABLE(i, char, xdata);
 405   1        
 406   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 407   1        
 408   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 409   1      
 410   1         SFRPAGE = CONFIG_PAGE;              // Switch to the necessary SFRPAGE
 411   1      
 412   1         OSCICN = 0x83;
 413   1      
 414   1         // Step 2. Set the PLLSRC bit (PLL0CN.2) to select the desired
 415   1         // clock source for the PLL.
 416   1         PLL0CN &= ~0x04;                    // Internal oscillator
 417   1      
 418   1         // Step 3. Program the Flash read timing bits, FLRT (FLSCL.5-4) to the
 419   1         // appropriate value for the new clock rate (see Section 15. Flash Memory
 420   1         // on page 199).
 421   1         SFRPAGE = LEGACY_PAGE;
 422   1         FLSCL |= 0x30;                      // >= 100 MHz
 423   1         SFRPAGE = CONFIG_PAGE;
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/05/2020 06:56:11 PAGE 8   

 424   1      
 425   1         // Step 4. Enable power to the PLL by setting PLLPWR (PLL0CN.0) to ‘1’.
 426   1         PLL0CN |= 0x01;
 427   1      
 428   1         // Step 5. Program the PLL0DIV register to produce the divided reference
 429   1         // frequency to the PLL.
 430   1         PLL0DIV = 0x01;
 431   1      
 432   1         // Step 6. Program the PLLLP3-0 bits (PLL0FLT.3-0) to the appropriate
 433   1         // range for the divided reference frequency.
 434   1         PLL0FLT |= 0x01;
 435   1      
 436   1         // Step 7. Program the PLLICO1-0 bits (PLL0FLT.5-4) to the appropriate
 437   1         // range for the PLL output frequency.
 438   1         PLL0FLT &= ~0x30;
 439   1      
 440   1         // Step 8. Program the PLL0MUL register to the desired clock multiplication
 441   1         // factor.
 442   1         PLL0MUL = 0x04;
 443   1      
 444   1         // Step 9. Wait at least 5 µs, to provide a fast frequency lock.
 445   1         for (i = 100; i > 0; i--);
 446   1      
 447   1         // Step 10. Enable the PLL by setting PLLEN (PLL0CN.1) to ‘1’.
 448   1         PLL0CN |= 0x02;
 449   1      
 450   1         // Step 11. Poll PLLLCK (PLL0CN.4) until it changes from ‘0’ to ‘1’.
 451   1         while ((PLL0CN & 0x10) != 0x10);
 452   1      
 453   1         // Step 12. Switch the System Clock source to the PLL using the CLKSEL
 454   1         // register.
 455   1         CLKSEL = 0x02;
 456   1      
 457   1         SFRPAGE = SFRPAGE_SAVE;             // Restore the SFRPAGE
 458   1      }
 459          
 460          //-----------------------------------------------------------------------------
 461          // PORT_Init
 462          //-----------------------------------------------------------------------------
 463          //
 464          // Return Value:  None
 465          // Parameters:    None
 466          //
 467          // Configure the Crossbar and GPIO ports.
 468          //
 469          // Pinout:
 470          //
 471          // P0.0 - UART TX1 (push-pull)
 472          // P0.1 - UART RX1
 473          //
 474          // P1.6 - LED (push-pull)
 475          //
 476          // DAC0 - DAC0 output
 477          //
 478          // AIN0.0 - ADC0 analog input
 479          //
 480          // Note: DAC0 and AIN0.0 must be tied together.
 481          //
 482          //-----------------------------------------------------------------------------
 483          void PORT_Init (void)
 484          {
 485   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata);
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/05/2020 06:56:11 PAGE 9   

 486   1         SFRPAGE_save = SFRPAGE;             // Save the current SFRPAGE
 487   1      
 488   1         SFRPAGE = CONFIG_PAGE;              // Switch to the necessary SFRPAGE
 489   1      
 490   1         XBR0     = 0x04;
 491   1         XBR1     = 0x00;
 492   1         XBR2     = 0x40;                    // Enable crossbar and weak pull-up
 493   1                                             // Enable UART0
 494   1      
 495   1         P0MDOUT |= 0x01;                    // Set TX1 pin to push-pull
 496   1         P1MDOUT |= 0x40;                    // Set P1.6(LED) to push-pull
 497   1         
 498   1         P4MDOUT |= 0x04;                    // Set P4.2 to push-pull
 499   1         P4MDOUT |= 0x10;                    // Set P4.4 to push-pull
 500   1         P4MDOUT &= ~0x08;                   // Set P4.3 to input
 501   1        
 502   1         P5MDOUT |= 0xFF;
 503   1         P6MDOUT |= 0xFF;
 504   1         P7MDOUT |= 0xFF;
 505   1         P5 =  0x00;
 506   1         P6 |= 0x0F;
 507   1         P7 =  0xFF;
 508   1         DC24OUTPUT = 1;
 509   1         DC24INPUT = 1;
 510   1         SELECT485 = 0;                      // to receive
 511   1         
 512   1         SFRPAGE = SFRPAGE_save;             // Restore the SFRPAGE
 513   1      }
 514          
 515          //-----------------------------------------------------------------------------
 516          // UART0_Init
 517          //-----------------------------------------------------------------------------
 518          void Timer0_Init(void)
 519          {
 520   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata);
 521   1        SFRPAGE_save = SFRPAGE;
 522   1        
 523   1        SFRPAGE = TIMER01_PAGE;
 524   1        
 525   1        TMOD   &= 0xFD;
 526   1        TMOD   |= 0x01;
 527   1        TH0     = 0x00;
 528   1        TL0     = 0x00;
 529   1        ET0     = 1;
 530   1        TR0     = 1;
 531   1        CKCON  |= 0x08;
 532   1        SFRPAGE = SFRPAGE_save;
 533   1      }
 534          //-----------------------------------------------------------------------------
 535          // UART0_Init
 536          //-----------------------------------------------------------------------------
 537          //
 538          // Return Value:  None
 539          // Parameters:    None
 540          //
 541          // Configure the UART0 using Timer1, for <BAUDRATE> and 8-N-1.
 542          //
 543          //-----------------------------------------------------------------------------
 544          void UART0_Init (void)
 545          {
 546   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata); 
 547   1         SFRPAGE_save = SFRPAGE; // Save the current SFRPAGE
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/05/2020 06:56:11 PAGE 10  

 548   1      
 549   1         SFRPAGE = UART0_PAGE;               // Switch to the necessary SFRPAGE
 550   1          
 551   1         SCON0  = 0x70;
 552   1         TMOD   = 0x20;
 553   1         TH1    = 0x5D;///0xE5;///0x5D;////0xE5;// - 115200;
 554   1         TR1    = 1;
 555   1         CKCON |= 0x10;
 556   1         PCON  |= 0x80;//SMOD0 = 1 
 557   1        
 558   1         TI0    = 0;                         // Indicate TX0 ready
 559   1         
 560   1         PS0    = 1;
 561   1        
 562   1         ES0    = 1; 
 563   1        
 564   1         SFRPAGE = SFRPAGE_save;             // Restore the SFRPAGE
 565   1      }
 566          //-----------------------------------------------------------------------------
 567          // DAC0_Init
 568          //-----------------------------------------------------------------------------
 569          //
 570          // Return Value:  None
 571          // Parameters:    None
 572          //
 573          // Configure DAC1 to update on Timer4 overflows.  VREF is already enabled by
 574          // the ADC initialization code.
 575          //
 576          //-----------------------------------------------------------------------------
 577          void DAC0_Init(void){
 578   1      
 579   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 580   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 581   1      
 582   1         SFRPAGE = DAC0_PAGE;
 583   1      
 584   1         DAC0CN = 0x94;                      // Enable DAC0 in left-justified mode
 585   1                                             // managed by Timer4 overflows
 586   1      
 587   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 588   1      }
 589          
 590          //-----------------------------------------------------------------------------
 591          // DAC1_Init
 592          //-----------------------------------------------------------------------------
 593          //
 594          // Return Value:  None
 595          // Parameters:    None
 596          //
 597          // Configure DAC1 to update on write to DAC1H.  VREF is already enabled by
 598          // the ADC initialization code.
 599          //
 600          //-----------------------------------------------------------------------------
 601          void DAC1_Init(void){
 602   1      
 603   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 604   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 605   1      
 606   1         SFRPAGE = DAC1_PAGE;
 607   1      
 608   1         DAC1CN = 0x84;                      // Enable DAC1 in left-justified mode
 609   1                                             // managed by write data to DAC1H
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/05/2020 06:56:11 PAGE 11  

 610   1         
 611   1         DAC1 = DAC1_VALUE;                  // Write to DAC1
 612   1      
 613   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 614   1      }
 615          
 616          //-----------------------------------------------------------------------------
 617          // ADC0_Init
 618          //-----------------------------------------------------------------------------
 619          //
 620          // Return Value:  None
 621          // Parameters:    None
 622          //
 623          // Configures ADC0 to make single-ended analog measurements on pin AIN0.0 for
 624          // the FIR filter.  Timer3 overflows are the conversion source and the data is
 625          // left-justified.  This function also enables the ADC end-of-conversion
 626          // interrupt and leaves the ADC disabled.
 627          //
 628          //-----------------------------------------------------------------------------
 629          void ADC0_Init (void)
 630          {
 631   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 632   1        
 633   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 634   1      
 635   1         SFRPAGE = ADC0_PAGE;
 636   1      
 637   1         ADC0CN = 0x05;                      // ADC0 disabled; normal tracking
 638   1                                             // mode; ADC0 conversions are initiated
 639   1                                             // on overflow of Timer3; ADC0 data is
 640   1                                             // left-justified
 641   1      
 642   1         REF0CN = 0x03;                      // Enable on-chip VREF and VREF output
 643   1                                             // buffer
 644   1      #ifndef BIPOLIAR_ADC
 645   1         AMX0SL = 0x00;                      // Select AIN0.0 as ADC mux input
 646   1      #else 
                 AMX0CF = 0x01;
                 AMX0SL = 0x00;
              #endif
 650   1        
 651   1         ADC0CF = (SYSCLK/2500000) << 3;     // ADC conversion clock = 2.5MHz
 652   1      
 653   1         EIE2 |= 0x02;                       // Enable ADC interrupts
 654   1      
 655   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 656   1      }
 657          
 658          //-----------------------------------------------------------------------------
 659          // Timer3_Init
 660          //-----------------------------------------------------------------------------
 661          //
 662          // Return Value:  None
 663          // Parameters:    None
 664          //
 665          // Configure Timer3 to auto-reload at interval specified by <counts> (no
 666          // interrupt generated) using SYSCLK as its time base.
 667          //
 668          // Timer 3 overflow automatically triggers ADC0 conversion.
 669          //
 670          //-----------------------------------------------------------------------------
 671          void Timer3_Init (int counts)
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/05/2020 06:56:11 PAGE 12  

 672          {
 673   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 674   1        
 675   1         SFRPAGE_SAVE = SFRPAGE;             // Save Current SFR page
 676   1      
 677   1         SFRPAGE = TMR3_PAGE;
 678   1      
 679   1         TMR3CN = 0x00;                      // Stop Timer3; Clear TF3;
 680   1         TMR3CF = 0x08;                      // use SYSCLK as timebase
 681   1      
 682   1         RCAP3   = -counts;                  // Init reload values
 683   1         TMR3    = RCAP3;                    // set to reload immediately
 684   1         EIE2   &= ~0x01;                    // Disable Timer3 interrupts
 685   1         TR3 = 1;                            // Start Timer3
 686   1      
 687   1         SFRPAGE = SFRPAGE_SAVE;             // Restore SFR page
 688   1      }
 689          //-----------------------------------------------------------------------------
 690          // Timer4_Init
 691          //-----------------------------------------------------------------------------
 692          //
 693          // Return Value:  None
 694          // Parameters:
 695          //   1) counts - the number of timer clocks to count before a timer interrupt
 696          //           should occur
 697          //
 698          // Configure Timer4 to auto-reload mode and to generate interrupts
 699          // at intervals specified in <counts> using SYSCLK as its time base.
 700          //
 701          // Timer 4 overflow controls the DAC update rate.
 702          //
 703          //-----------------------------------------------------------------------------
 704          void Timer4_Init (int counts)
 705          {
 706   1         SI_SEGMENT_VARIABLE(SFRPAGE_SAVE, char, xdata);
 707   1        
 708   1         SFRPAGE_SAVE = SFRPAGE;          // Save Current SFR page
 709   1      
 710   1         SFRPAGE = TMR4_PAGE;
 711   1      
 712   1         TMR4CN = 0x00;                   // Stop Timer4; Clear overflow flag (TF4);
 713   1                                          // Set to Auto-Reload Mode
 714   1      
 715   1         TMR4CF = 0x08;                   // Configure Timer4 to increment;
 716   1                                          // Timer4 counts SYSCLKs
 717   1      
 718   1         RCAP4 = -counts;                 // Set reload value
 719   1         TMR4 = RCAP4;                    // Initialzie Timer4 to reload value
 720   1        
 721   1         EIE2 |= 0x04;                    // Enable Timer4 interrupts
 722   1         TR4 = 1;                         // Start Timer4
 723   1      
 724   1         SFRPAGE = SFRPAGE_SAVE;          // Restore SFR page
 725   1      }
 726          //-----------------------------------------------------------------------------
 727          // ADC0_ISR
 728          //-----------------------------------------------------------------------------
 729          //
 730          // ADC0 end-of-conversion ISR
 731          //
 732          // This interrupt service routine is called on ADC0 conversion complete.
 733          // The ADC result is converted to signed and stored in the FIR delay line.
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/05/2020 06:56:11 PAGE 13  

 734          //
 735          // If the global <FIR_On> bit is set to a '1', then the FIR output is computed
 736          // and stored in the global variable 'Sample'.  The 'Sample_Ready' indicator
 737          // bit is set to indicate the value is ready.
 738          //
 739          // If <FIR_On> is set to '0', then the ADC sample is copied to the global
 740          // 'Sample' variable.  The 'Sample_Ready' indicator bit is set to indicate
 741          // that the value is ready.
 742          //
 743          //-----------------------------------------------------------------------------
 744          //void ADC0_ISR (void) interrupt 15
 745          #pragma NOAREGS
 746          SI_INTERRUPT(ADC0_ISR, INTERRUPT_ADC0_EOC)
 747          {
 748   1         volatile SI_UU16_t input;
 749   1        
 750   1         AD0INT = 0;                         // Clear ADC conversion complete
 751   1                                             // indicator
 752   1      
 753   1         input.s16 = ADC0^0x8000;            // Convert to bipolar value
 754   1         
 755   1         
 756   1         if (data_for_filter_counter < N) {
 757   2            data_for_filter [data_for_filter_counter++].u16 = input.u16;
 758   2         }
 759   1      }
 760          
 761          #pragma NOAREGS
 762          SI_INTERRUPT(TIMER0_ISR, INTERRUPT_TIMER0)
 763          {
 764   1        unsigned char SFRPAGE_save = SFRPAGE;
 765   1        SFRPAGE = TIMER01_PAGE;
 766   1        TH0     = 0x00;
 767   1        TL0     = 0x00;
 768   1        TF0     = 0;
 769   1        SFRPAGE = SFRPAGE_save;
 770   1        if(modbus_was_sendind_received()) {
 771   2          modbus_command_received();
 772   2          SFRPAGE = CONFIG_PAGE;
 773   2          LED485  = !LED485;
 774   2        }
 775   1        SFRPAGE = CONFIG_PAGE;
 776   1        if (DC24OUTPUT == 0) {
 777   2          if (TimerForDC24Output++ % DividerForDC24Output == 0) {
 778   3            DC24OUTPUT = 1;
 779   3          }
 780   2        }
 781   1        TIMER++;
 782   1        SFRPAGE = SFRPAGE_save;
 783   1      }
 784          
 785          #pragma NOAREGS
 786          SI_INTERRUPT(UART0_ISR, INTERRUPT_UART0)
 787          {
 788   1        unsigned char SFRPAGE_save = SFRPAGE; // Save the current SFRPAGE
 789   1        SFRPAGE = UART0_PAGE;
 790   1        if(RI0 == 1) {
 791   2          modbus_byte_receive(SBUF0);
 792   2          RI0 = 0;
 793   2        }
 794   1        if(TI0 == 1) {
 795   2          TI0 = 0;
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/05/2020 06:56:11 PAGE 14  

 796   2          toTransmit485();
 797   2          if (modbus_transmit_buffer_is_empty()) {
 798   3            toReceive485();
 799   3          }
 800   2          else {
 801   3            modbus_transmit_byte();
 802   3          }
 803   2        }
 804   1        SFRPAGE = SFRPAGE_save;               // Restore the SFRPAGE  
 805   1      }
 806          //-----------------------------------------------------------------------------
 807          // Timer4_ISR
 808          //-----------------------------------------------------------------------------
 809          //
 810          // This ISR is called on Timer4 overflows.  Timer4 is set to auto-reload mode
 811          // and is used to schedule the DAC output sample rate in this example.
 812          // Note that the value that is written to DAC1 during this ISR call is
 813          // actually transferred to DAC1 at the next Timer4 overflow.
 814          //
 815          //-----------------------------------------------------------------------------
 816          //void Timer4_ISR (void) interrupt 16
 817          #pragma NOAREGS
 818          SI_INTERRUPT(Timer4_ISR, INTERRUPT_TIMER4)
 819          { 
 820   1         char number = 0;
 821   1         int temp1 = 0;                      // The temporary value that passes
 822   1                                             // through 3 stages before being written
 823   1                                             // to the IDAC
 824   1         TMR3CN &= ~0x80;                    // Clear Timer3 overflow flag
 825   1        
 826   1         for (number=0; number<12; number++) {
 827   2            if (freq_dac_flags [number] == 1) {
 828   3              phase_acc[number].u16 += Phase_Add [number];
 829   3              temp1 += (SINE_TABLE[phase_acc[number].u8[MSB]] / freq_divider);
 830   3            }
 831   2         }
 832   1           
 833   1         SFRPAGE = DAC0_PAGE;
 834   1      
 835   1         // Add a DC bias to make the rails 0 to 65535
 836   1         // Note: the XOR with 0x8000 translates the bipolar quantity into
 837   1         // a unipolar quantity.
 838   1      
 839   1         DAC0 = 0x8000 ^ temp1;              // Write to DAC0
 840   1      }
 841          
 842          #pragma NOAREGS
 843          void init_after_flash_reload() {
 844   1         //-----------------------------------------------------------------------
 845   1         SI_SEGMENT_VARIABLE(i, uint8_t, xdata);
 846   1         SI_SEGMENT_VARIABLE(d, uint8_t, xdata);
 847   1         SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 848   1         //-----------------------------------------------------------------------
 849   1         SFRPAGE_save = SFRPAGE;
 850   1         d = 0;
 851   1         //----------------------- FREQ DIVIDER INIT -----------------------------
 852   1         freq_divider = modbus_get_freq_divider();
 853   1         if (freq_divider == 0) {
 854   2            freq_divider = 1;
 855   2         }
 856   1         //--------------------------- FREQ INIT ---------------------------------
 857   1         modbus_init_freqs(FREQS);
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/05/2020 06:56:11 PAGE 15  

 858   1         for (i=0; i<12; i++) {
 859   2            Phase_Add [i] = (unsigned int)((unsigned long)((FREQS [i] *
 860   2                      PHASE_PRECISION) / OUTPUT_RATE_DAC));
 861   2            if (getFreqFromModbusForDAC(i) != 0) {
 862   3               freq_dac_flags [i] = 1;
 863   3               if (i < 8) {
 864   4                  d = bit_set(d, i);
 865   4               }
 866   3            } else {
 867   3               freq_dac_flags [i] = 0;
 868   3            }
 869   2         }
 870   1         SFRPAGE = CONFIG_PAGE;
 871   1         //-----------------------------------------------------------------------
 872   1         // CLEAR - INVERSE LOGIC
 873   1         P7 =  0xFF;
 874   1         if ((d & CMD_1) == (uint8_t)CMD_1) {
 875   2            bit_clear_P7(0);
 876   2         }
 877   1         if ((d & CMD_2) == CMD_2) {
 878   2            bit_clear_P7(1);
 879   2         }
 880   1         if ((d & CMD_3) == CMD_3) {
 881   2            bit_clear_P7(2);
 882   2         }
 883   1         if ((d & CMD_4) == CMD_4) {
 884   2            bit_clear_P7(3);
 885   2         }
 886   1         if ((d & CMD_5) == CMD_5) {
 887   2            bit_clear_P7(4);
 888   2         }
 889   1         if ((d & CMD_6) == CMD_6) {
 890   2            bit_clear_P7(5);
 891   2         }
 892   1         //--------------------------------------------------------------------------
 893   1         d = getDC24DurationTimeIfEnabed();
 894   1         if (d != 0) {
 895   2           DC24OUTPUT = 0;
 896   2           DividerForDC24Output = d * SECOND_INTERVAL;
 897   2           TimerForDC24Output = 1;
 898   2         }
 899   1         //--------------------------------------------------------------------------
 900   1         if (isNeedGetADCValues() == 1) {
 901   2           isNeedGetADCValuesFlag = 1;
 902   2         }
 903   1         SFRPAGE = SFRPAGE_save;
 904   1         //--------------------------------------------------------------------------
 905   1      }
 906          //-----------------------------------------------------------------------------
 907          // delay
 908          void delay(unsigned short timer) {
 909   1        TIMER = 0;
 910   1        while(TIMER < timer); 
 911   1      }
 912          //-----------------------------------------------------------------------------
 913          // transmit 485
 914          void toTransmit485() {
 915   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 916   1        SFRPAGE_save = SFRPAGE;
 917   1        SFRPAGE = CONFIG_PAGE;
 918   1        SELECT485 = 1;
 919   1        SFRPAGE = SFRPAGE_save;
C51 COMPILER V9.53.0.0   C8051F12X_FIR_DEMO                                                06/05/2020 06:56:11 PAGE 16  

 920   1      }
 921          //-----------------------------------------------------------------------------
 922          // receive 485
 923          void toReceive485() {
 924   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, uint8_t, xdata);
 925   1        SFRPAGE_save = SFRPAGE;
 926   1        SFRPAGE = CONFIG_PAGE;
 927   1        SELECT485 = 0;
 928   1        SFRPAGE = SFRPAGE_save;
 929   1      }
 930          //-----------------------------------------------------------------------------
 931          // putchar
 932          //-----------------------------------------------------------------------------
 933          //
 934          // Return Value:
 935          //   1) char c - returns the char c that was passed as a parameter
 936          // Parameters:
 937          //   1) char c - the character to be printed
 938          //
 939          // Print the character <c> using UART0 at <BAUDRATE>.
 940          //
 941          //-----------------------------------------------------------------------------
 942          #if defined __C51__
 943          char putchar (char c)
 944          #elif defined SDCC
              void putchar (char c)
              #endif
 947          {
 948   1         modbus_push_transmit_buffer(c);
 949   1      #if defined __C51__
 950   1         return c;                           // Print the character
 951   1      #endif
 952   1      }
 953          //-----------------------------------------------------------------------------
 954          // End Of File
 955          //-----------------------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2284    ----
   CONSTANT SIZE    =    512    ----
   XDATA SIZE       =   2383      23
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
