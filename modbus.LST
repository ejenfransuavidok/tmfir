C51 COMPILER V9.53.0.0   MODBUS                                                            08/15/2020 09:58:28 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MODBUS
OBJECT MODULE PLACED IN modbus.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE modbus.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <stdio.h>
   2          #include "si_toolchain.h"
   3          #include "C8051F120_defs.h"
   4          
   5          #include "modbus.h"
   6          #include "F120_FlashUtils.h"
   7          
   8          int modbus_receiver_pointer = 0;
   9          int modbus_transmitter_pointer_right = 0;
  10          int modbus_transmitter_pointer_left = 0;
  11          int sender_pause_timer = 0;
  12          
  13          SI_SEGMENT_VARIABLE(modbus_command_receiver[MODBUS_RECEIVER_LENGTH], uint8_t, xdata);
  14          SI_SEGMENT_VARIABLE(modbus_command_transmitter[MODBUS_TRANSMITTER_LENGTH], uint8_t, xdata);
  15          SI_SEGMENT_VARIABLE(modbus_buffer_data[MODBUS_DATA_LENGTH], uint8_t, xdata);
  16          SI_SEGMENT_VARIABLE(modbus_error_response[5], uint8_t, xdata);
  17          SI_SEGMENT_VARIABLE(modbus_16_post_func_invoke_flag, extern uint8_t, xdata);
  18          
  19          void (*init_after_flash_reload_func_pointer)(void);
  20          
  21          #pragma NOAREGS
  22          uint8_t * getModbusBufferData() {
  23   1        return modbus_buffer_data;
  24   1      }
  25          
  26          #pragma NOAREGS
  27          void modbus_init_from_flash(void (*init_after_flash_reload)(void)) {
  28   1        FLASH_Read (modbus_buffer_data, MODBUS_FLASH_ADDRESS, 3000, 0);
  29   1        init_after_flash_reload_func_pointer = init_after_flash_reload;
  30   1        init_after_flash_reload_func_pointer();
  31   1      }
  32          
  33          #pragma NOAREGS
  34          void resetFlashUpdate() {
  35   1        modbus_buffer_data [MODBUS_REFRESH_FLASH_MEMORY_ADDRESS_0] = 0;
  36   1        modbus_buffer_data [MODBUS_REFRESH_FLASH_MEMORY_ADDRESS_1] = 0; 
  37   1        modbus_buffer_data [MODBUS_REFRESH_FLASH_MEMORY_ADDRESS_2] = 0;
  38   1        modbus_buffer_data [MODBUS_REFRESH_FLASH_MEMORY_ADDRESS_3] = 0; 
  39   1      }
  40          
  41          #pragma NOAREGS
  42          bool isNeedFlashUpdate() {
  43   1        return
  44   1        modbus_buffer_data [MODBUS_REFRESH_FLASH_MEMORY_ADDRESS_0] == 0x11 &&
  45   1        modbus_buffer_data [MODBUS_REFRESH_FLASH_MEMORY_ADDRESS_1] == 0x11 &&
  46   1        modbus_buffer_data [MODBUS_REFRESH_FLASH_MEMORY_ADDRESS_2] == 0x22 &&
  47   1        modbus_buffer_data [MODBUS_REFRESH_FLASH_MEMORY_ADDRESS_3] == 0x22;
  48   1      }
  49          
  50          #pragma NOAREGS
  51          uint16_t crc16_update(uint16_t crc, uint8_t a) {
  52   1        SI_SEGMENT_VARIABLE(i, int, xdata);
  53   1        crc ^= (uint16_t)a;
  54   1        for (i = 0; i < 8; ++i) {
  55   2          if (crc & 1)
C51 COMPILER V9.53.0.0   MODBUS                                                            08/15/2020 09:58:28 PAGE 2   

  56   2            crc = (crc >> 1) ^ 0xA001;
  57   2          else
  58   2            crc = (crc >> 1);
  59   2        }
  60   1        return crc;
  61   1      }
  62          
  63          #pragma NOAREGS
  64          uint16_t calc_crc(uint8_t * command, int size_command) {
  65   1        SI_SEGMENT_VARIABLE(crc, uint16_t, xdata);
  66   1        SI_SEGMENT_VARIABLE(i, int, xdata);
  67   1        crc = 0xFFFF;
  68   1        i = 0;
  69   1        for(i=0; i<size_command; i++) {
  70   2          crc = crc16_update(crc, (uint8_t) command [i]);
  71   2        }
  72   1        return crc;
  73   1      }
  74          
  75          #pragma NOAREGS
  76          bool modbus_check_crc(uint8_t * command_receiver, int receiver_pointer) {
  77   1        if(receiver_pointer > 2) {
  78   2          uint16_t crc_calc = calc_crc(command_receiver, receiver_pointer - 2);
  79   2          uint16_t crc = command_receiver [receiver_pointer - 1];
  80   2          crc = (crc << 8) + command_receiver [receiver_pointer - 2];
  81   2          return crc_calc == crc;
  82   2        }
  83   1        return false;
  84   1      }
  85          
  86          #pragma NOAREGS
  87          uint8_t modbus_get_address() {
  88   1        return modbus_buffer_data [MODBUS_ADDRESS_IN_MEMORY];
  89   1      }
  90          
  91          #pragma NOAREGS
  92          bool modbus_check_address() {
  93   1        return modbus_get_address() == modbus_command_receiver [MODBUS_ADDRESS]
  94   1          || modbus_command_receiver [MODBUS_ADDRESS] == MODBUS_BROADCAST_ADDRESS;
  95   1      }
  96          
  97          #pragma NOAREGS
  98          uint8_t modbus_get_function() {
  99   1        return modbus_command_receiver [MODBUS_FUNCTION];
 100   1      }
 101          
 102          #pragma NOAREGS
 103          void modbus_response_error(uint8_t error) {
 104   1        SI_SEGMENT_VARIABLE(crc, uint16_t, xdata);
 105   1        SI_SEGMENT_VARIABLE(i, int, xdata);
 106   1        crc = 0xFFFF;
 107   1        i = 0;
 108   1        modbus_error_response [MODBUS_ADDRESS] = modbus_get_address();
 109   1        modbus_error_response [MODBUS_ERROR] = MODBUS_ERROR_CODE;
 110   1        modbus_error_response [MODBUS_EXCEPTION] = error;
 111   1        crc = calc_crc(modbus_error_response, 3);
 112   1        modbus_error_response [3] = (uint8_t)(crc >> 8);
 113   1        modbus_error_response [4] = (uint8_t)(crc);
 114   1        for(i = 0; i<5; i++) {
 115   2          modbus_push_transmit_buffer(modbus_error_response [i]);
 116   2        }
 117   1      }
C51 COMPILER V9.53.0.0   MODBUS                                                            08/15/2020 09:58:28 PAGE 3   

 118          
 119          #pragma NOAREGS
 120          int modbus_process_function_3() {
 121   1        SI_SEGMENT_VARIABLE(crc, uint16_t, xdata);
 122   1        SI_SEGMENT_VARIABLE(i, uint16_t, xdata);
 123   1        SI_SEGMENT_VARIABLE(register_hi, uint16_t, xdata);
 124   1        SI_SEGMENT_VARIABLE(register_lo, uint16_t, xdata);
 125   1        SI_SEGMENT_VARIABLE(modbus_data, uint8_t, xdata);
 126   1        SI_SEGMENT_VARIABLE(address_hi, uint16_t, xdata);
 127   1        SI_SEGMENT_VARIABLE(address_lo, uint16_t, xdata);
 128   1        SI_SEGMENT_VARIABLE(address, uint16_t, xdata);
 129   1        SI_SEGMENT_VARIABLE(registers_hi, uint16_t, xdata);
 130   1        SI_SEGMENT_VARIABLE(registers_lo, uint16_t, xdata);
 131   1        SI_SEGMENT_VARIABLE(registers, uint16_t, xdata);
 132   1        SI_SEGMENT_VARIABLE(number, uint8_t, xdata);
 133   1        crc = 0xFFFF;
 134   1      
 135   1        address_hi = modbus_command_receiver [MODBUS_FIRST_REGISTER_HI];
 136   1        address_lo = modbus_command_receiver [MODBUS_FIRST_REGISTER_LO];
 137   1        address = (address_hi << 8) + address_lo;
 138   1        registers_hi = modbus_command_receiver [MODBUS_NUMBER_OF_REGISTER_TO_READ_HI];
 139   1        registers_lo = modbus_command_receiver [MODBUS_NUMBER_OF_REGISTER_TO_READ_LO];
 140   1        registers = (registers_hi << 8) + registers_lo;
 141   1        number = registers << 1;
 142   1        if((address << 1) + number >= MODBUS_DATA_LENGTH) {
 143   2          modbus_response_error(MODBUS_ERROR_ILLEGAL_DATA_ADDRESS);
 144   2          return MODBUS_FAIL;
 145   2        }
 146   1        else {
 147   2          modbus_data = modbus_get_address();
 148   2          crc = crc16_update(crc, modbus_data);
 149   2          modbus_push_transmit_buffer(modbus_data);
 150   2          
 151   2          modbus_data = 3;
 152   2          crc = crc16_update(crc, modbus_data);
 153   2          modbus_push_transmit_buffer(modbus_data);
 154   2          
 155   2          modbus_data = number;
 156   2          crc = crc16_update(crc, modbus_data);
 157   2          modbus_push_transmit_buffer(modbus_data);
 158   2          
 159   2          for(i=0; i<registers; i++) {
 160   3            register_lo = modbus_buffer_data [(address << 1) + (i << 1)];
 161   3            register_hi = modbus_buffer_data [(address << 1) + (i << 1) + 1];
 162   3            modbus_data = register_lo;
 163   3            crc = crc16_update(crc, modbus_data);
 164   3            modbus_push_transmit_buffer(modbus_data);
 165   3            modbus_data = register_hi;
 166   3            crc = crc16_update(crc, modbus_data);
 167   3            modbus_push_transmit_buffer(modbus_data);
 168   3          }
 169   2          modbus_push_transmit_buffer((uint8_t)(crc));
 170   2          modbus_push_transmit_buffer((uint8_t)(crc >> 8));
 171   2          TI0 = 1;
 172   2          return MODBUS_GOOD;
 173   2        }
 174   1      }
 175          
 176          #pragma NOAREGS
 177          bool modbus_check_size_of_func16(int registers_num) {
 178   1        return modbus_receiver_pointer == (MODBUS_FUNCTION_16_BASE_LENGTH + (registers_num << 1));
 179   1      }
C51 COMPILER V9.53.0.0   MODBUS                                                            08/15/2020 09:58:28 PAGE 4   

 180          
 181          #pragma NOAREGS
 182          int modbus_process_function_16() {
 183   1        SI_SEGMENT_VARIABLE(crc, uint16_t, xdata);
 184   1        SI_SEGMENT_VARIABLE(i, uint16_t, xdata);
 185   1        SI_SEGMENT_VARIABLE(p, uint16_t, xdata);
 186   1        SI_SEGMENT_VARIABLE(register_hi, uint16_t, xdata);
 187   1        SI_SEGMENT_VARIABLE(register_lo, uint16_t, xdata);
 188   1        SI_SEGMENT_VARIABLE(register_in_hi, uint8_t, xdata);
 189   1        SI_SEGMENT_VARIABLE(register_in_lo, uint8_t, xdata);
 190   1        SI_SEGMENT_VARIABLE(modbus_data, uint8_t, xdata);
 191   1        SI_SEGMENT_VARIABLE(address_hi, uint8_t, xdata);
 192   1        SI_SEGMENT_VARIABLE(address_lo, uint8_t, xdata);
 193   1        SI_SEGMENT_VARIABLE(address, uint16_t, xdata);
 194   1        SI_SEGMENT_VARIABLE(registers_hi, uint8_t, xdata);
 195   1        SI_SEGMENT_VARIABLE(registers_lo, uint8_t, xdata);
 196   1        SI_SEGMENT_VARIABLE(registers, uint16_t, xdata);
 197   1        SI_SEGMENT_VARIABLE(number, uint16_t, xdata);
 198   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata);
 199   1        
 200   1        SFRPAGE_save = SFRPAGE;
 201   1        crc = 0xFFFF;
 202   1        
 203   1        address_hi = modbus_command_receiver [MODBUS_FIRST_REGISTER_HI];
 204   1        address_lo = modbus_command_receiver [MODBUS_FIRST_REGISTER_LO];
 205   1        address = (address_hi << 8) + address_lo;
 206   1        registers_hi = modbus_command_receiver [MODBUS_NUMBER_OF_REGISTER_TO_WRITE_HI];
 207   1        registers_lo = modbus_command_receiver [MODBUS_NUMBER_OF_REGISTER_TO_WRITE_LO];
 208   1        registers = (registers_hi << 8) + registers_lo;
 209   1        number = registers << 1;
 210   1        if(((address << 1) + number >= MODBUS_DATA_LENGTH) || !modbus_check_size_of_func16(registers)) {
 211   2          modbus_response_error(MODBUS_ERROR_ILLEGAL_DATA_ADDRESS);
 212   2          return MODBUS_FAIL;
 213   2        }
 214   1        else {
 215   2          resetFlashUpdate();
 216   2          for(i=0; i<registers; i++) {
 217   3            register_in_hi = modbus_command_receiver [(i << 1) + MODBUS_WRITE_REGISTER_OFFSET];
 218   3            register_in_lo = modbus_command_receiver [(i << 1) + 1 + MODBUS_WRITE_REGISTER_OFFSET];
 219   3            register_hi = (address << 1) + (i << 1);
 220   3            register_lo = (address << 1) + (i << 1) + 1;
 221   3            modbus_buffer_data [register_lo] = register_in_lo;
 222   3            modbus_buffer_data [register_hi] = register_in_hi;
 223   3          }
 224   2          modbus_data = modbus_get_address();
 225   2          crc = crc16_update(crc, modbus_data);
 226   2          modbus_push_transmit_buffer(modbus_data);
 227   2          
 228   2          modbus_data = 16;
 229   2          crc = crc16_update(crc, modbus_data);
 230   2          modbus_push_transmit_buffer(modbus_data);
 231   2          
 232   2          modbus_data = address_hi;
 233   2          crc = crc16_update(crc, modbus_data);
 234   2          modbus_push_transmit_buffer(modbus_data);
 235   2          
 236   2          modbus_data = address_lo;
 237   2          crc = crc16_update(crc, modbus_data);
 238   2          modbus_push_transmit_buffer(modbus_data);
 239   2          
 240   2          modbus_data = registers_hi;
 241   2          crc = crc16_update(crc, modbus_data);
C51 COMPILER V9.53.0.0   MODBUS                                                            08/15/2020 09:58:28 PAGE 5   

 242   2          modbus_push_transmit_buffer(modbus_data);
 243   2          
 244   2          modbus_data = registers_lo;
 245   2          crc = crc16_update(crc, modbus_data);
 246   2          modbus_push_transmit_buffer(modbus_data);
 247   2          
 248   2          modbus_push_transmit_buffer((uint8_t)(crc));
 249   2          modbus_push_transmit_buffer((uint8_t)(crc >> 8));
 250   2          
 251   2          if (isNeedFlashUpdate()) {
 252   3            for (p=0; p<4; p++) {
 253   4              // 4 - pages (one page size is 1024)
 254   4              FLASH_Update(MODBUS_FLASH_ADDRESS + p * 1024, modbus_buffer_data + p * 1024, 1024, 0);
 255   4            }
 256   3          }
 257   2          modbus_16_post_func_invoke_flag = TRUE;
 258   2          TI0 = 1;
 259   2          return MODBUS_GOOD;
 260   2        }
 261   1      }
 262          
 263          #pragma NOAREGS
 264          void modbus_command_received() {
 265   1        SI_SEGMENT_VARIABLE(modbus_result, char, xdata);
 266   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata);
 267   1        
 268   1        modbus_result = MODBUS_FAIL;
 269   1        SFRPAGE_save = SFRPAGE;
 270   1        
 271   1        if(modbus_check_crc(modbus_command_receiver, modbus_receiver_pointer) && modbus_check_address()) {
 272   2          uint8_t function = modbus_get_function();
 273   2          if(function == 3 || function == 16) {
 274   3            if(function ==3) {
 275   4              modbus_result = modbus_process_function_3();
 276   4            }
 277   3            else {
 278   4              modbus_result = modbus_process_function_16();
 279   4            }
 280   3          }
 281   2          else {
 282   3            modbus_response_error(MODBUS_ERROR_ILLEGAL_FUNCTION_CODE);
 283   3          }
 284   2        }
 285   1        sender_pause_timer = 0;
 286   1        modbus_receiver_pointer = 0;
 287   1      }
 288          
 289          #pragma NOAREGS
 290          uint8_t isNeedGetADCValues() {
 291   1        SI_SEGMENT_VARIABLE(temp, uint16_t, xdata);   
 292   1        temp = MODBUS_NEED_GET_ADC_VALUES_FLAG_REGISTER_ADDRESS;
 293   1        temp = temp << 1;
 294   1        if(modbus_buffer_data [temp + 1] == 1) {
 295   2          modbus_buffer_data [temp] = 0;
 296   2          modbus_buffer_data [temp + 1] = 0;
 297   2          return 1;
 298   2        }
 299   1        return 0;
 300   1      }
 301          
 302          #pragma NOAREGS
 303          uint8_t getDC24DurationTimeIfEnabed() {
C51 COMPILER V9.53.0.0   MODBUS                                                            08/15/2020 09:58:28 PAGE 6   

 304   1        SI_SEGMENT_VARIABLE(temp, uint16_t, xdata);   
 305   1        temp = MODBUS_DC24_ENABLED_REGISTER_ADDRESS;
 306   1        temp = temp << 1;
 307   1        // low byte
 308   1        if (modbus_buffer_data [temp + 1] == 1) {
 309   2          modbus_buffer_data [temp] = 0;
 310   2          modbus_buffer_data [temp + 1] = 0;
 311   2          temp = MODBUS_DC24_OUTPUT_DURATION_REGISTER_ADDRESS;
 312   2          temp = temp << 1;
 313   2          // Default = 10 ms
 314   2          if (modbus_buffer_data [temp + 1] == 0) {
 315   3            return 1;
 316   3          } else {
 317   3            return modbus_buffer_data [temp + 1];
 318   3          }
 319   2        }
 320   1        else {
 321   2          return 0;
 322   2        }
 323   1      }
 324          
 325          #pragma NOAREGS
 326          void setDC24InputRegister(uint8_t value) {
 327   1        SI_SEGMENT_VARIABLE(temp, uint16_t, xdata);   
 328   1        temp = MODBUS_DC24_INPUT_ENABLED_REGISTER_ADDRESS;
 329   1        temp = temp << 1;
 330   1        modbus_buffer_data [temp] = 0;
 331   1        modbus_buffer_data [temp + 1] = value;
 332   1      }
 333          
 334          #pragma NOAREGS
 335          int get_modbus_receiver_counter() {
 336   1        return sender_pause_timer;
 337   1      }
 338          
 339          #pragma NOAREGS
 340          void set_modbus_receiver_counter(int mrc) {
 341   1        sender_pause_timer = mrc;
 342   1      }
 343          
 344          #pragma NOAREGS
 345          void inc_modbus_receiver_counter() {
 346   1        sender_pause_timer++;
 347   1      }
 348          
 349          #pragma NOAREGS
 350          void modbus_byte_receive(uint8_t input) {
 351   1        sender_pause_timer = 0;
 352   1        modbus_command_receiver [modbus_receiver_pointer++] = input;
 353   1        if(modbus_receiver_pointer == MODBUS_RECEIVER_LENGTH) {
 354   2          modbus_receiver_pointer = 0;
 355   2        }
 356   1      }
 357          
 358          #pragma NOAREGS
 359          void modbus_transmit_byte() {
 360   1        if(modbus_transmitter_pointer_right > 0) {
 361   2          SBUF0 = modbus_command_transmitter [modbus_transmitter_pointer_left++];
 362   2          if (modbus_transmitter_pointer_left == MODBUS_TRANSMITTER_LENGTH) {
 363   3            modbus_transmitter_pointer_left = 0;
 364   3          }
 365   2        }
C51 COMPILER V9.53.0.0   MODBUS                                                            08/15/2020 09:58:28 PAGE 7   

 366   1        if(modbus_transmitter_pointer_right == modbus_transmitter_pointer_left) {
 367   2          modbus_transmitter_pointer_right = 0;
 368   2          modbus_transmitter_pointer_left = 0;
 369   2        }
 370   1      }
 371          
 372          #pragma NOAREGS
 373          void modbus_push_transmit_buffer(uint8_t output) {
 374   1         /*
 375   1         if(output == '\n') {
 376   1           modbus_command_transmitter[modbus_transmitter_pointer_right++] = 0x0d;
 377   1         }
 378   1         else {
 379   1           modbus_command_transmitter[modbus_transmitter_pointer_right++] = output;
 380   1         }
 381   1         */
 382   1         modbus_command_transmitter[modbus_transmitter_pointer_right++] = output;
 383   1         if(modbus_transmitter_pointer_right == MODBUS_TRANSMITTER_LENGTH) {
 384   2              modbus_transmitter_pointer_right = 0;
 385   2         }
 386   1      }
 387          
 388          #pragma NOAREGS
 389          bool modbus_was_sendind_received() {
 390   1        sender_pause_timer++;
 391   1        return (sender_pause_timer > 6 && modbus_receiver_pointer > 0);
 392   1      }
 393          
 394          #pragma NOAREGS
 395          bool modbus_transmit_buffer_is_empty() {
 396   1        return modbus_transmitter_pointer_right == 0;
 397   1      }
 398          
 399          #pragma NOAREGS
 400          unsigned char modbus_get_freq_divider() {
 401   1        return modbus_buffer_data [MODBUS_FREQ_DIVIDER_ADDRESS];
 402   1      }
 403          
 404          #pragma NOAREGS
 405          void modbus_init_freqs(unsigned long * freqs) {
 406   1         SI_SEGMENT_VARIABLE(i, char, xdata);
 407   1         SI_SEGMENT_VARIABLE(hi, uint8_t, xdata);
 408   1         SI_SEGMENT_VARIABLE(lo, uint8_t, xdata);
 409   1         SI_SEGMENT_VARIABLE(address, unsigned short int, xdata);
 410   1         address = MODBUS_FREQ_VALUES_START_ADDRESS;
 411   1         for (i=0; i<12; i++) {
 412   2            hi = modbus_buffer_data [address];
 413   2            lo = modbus_buffer_data [address + 1];
 414   2            freqs [i] = (hi << 8) + lo;
 415   2            address += 2;
 416   2         }
 417   1      }
 418          
 419          #pragma NOAREGS
 420          void modbus_write_register(unsigned int address, uint8_t value) {
 421   1         address = address << 1;
 422   1         modbus_buffer_data [address + 1] = value;
 423   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2287    ----
C51 COMPILER V9.53.0.0   MODBUS                                                            08/15/2020 09:58:28 PAGE 8   

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   5053      69
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11      21
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
