C51 COMPILER V9.53.0.0   MODBUS                                                            07/02/2020 01:35:01 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MODBUS
OBJECT MODULE PLACED IN modbus.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE modbus.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <stdio.h>
   2          #include "si_toolchain.h"
   3          #include "C8051F120_defs.h"
   4          
   5          #include "modbus.h"
   6          #include "F120_FlashUtils.h"
   7          
   8          int modbus_receiver_pointer = 0;
   9          int modbus_transmitter_pointer_right = 0;
  10          int modbus_transmitter_pointer_left = 0;
  11          int sender_pause_timer = 0;
  12          
  13          SI_SEGMENT_VARIABLE(modbus_command_receiver[MODBUS_RECEIVER_LENGTH], uint8_t, xdata);
  14          SI_SEGMENT_VARIABLE(modbus_command_transmitter[MODBUS_TRANSMITTER_LENGTH], uint8_t, xdata);
  15          SI_SEGMENT_VARIABLE(modbus_buffer_data[MODBUS_DATA_LENGTH], uint8_t, xdata);
  16          SI_SEGMENT_VARIABLE(modbus_error_response[5], uint8_t, xdata);
  17          SI_SEGMENT_VARIABLE(reset_registers_on_read_table[RESET_REGISTERS_ON_READ_TABLE_SIZE], unsigned int, xdata
             -) = {
  18            1274, 1278, 1279, 1280, 1281, 1282, 1283
  19          };
  20          SI_SEGMENT_VARIABLE(modbus_16_post_func_invoke_flag, extern uint8_t, xdata);
  21          
  22          void (*init_after_flash_reload_func_pointer)(void);
  23          
  24          #pragma NOAREGS
  25          void reset_register_on_read(uint16_t address) {
  26   1         SI_SEGMENT_VARIABLE(i, uint8_t, xdata);
  27   1         for (i=0; i<RESET_REGISTERS_ON_READ_TABLE_SIZE; i++) {
  28   2           if (reset_registers_on_read_table [i] == address) {
  29   3             modbus_buffer_data [address << 1] = 0;
  30   3             modbus_buffer_data [(address << 1) + 1] = 0;
  31   3           }
  32   2         }
  33   1      }
  34          
  35          #pragma NOAREGS
  36          uint8_t * getModbusBufferData() {
  37   1        return modbus_buffer_data;
  38   1      }
  39          
  40          #pragma NOAREGS
  41          void modbus_init_from_flash(void (*init_after_flash_reload)(void)) {
  42   1        FLASH_Read (modbus_buffer_data, MODBUS_FLASH_ADDRESS, 3000, 0);
  43   1        init_after_flash_reload_func_pointer = init_after_flash_reload;
  44   1        init_after_flash_reload_func_pointer();
  45   1      }
  46          
  47          #pragma NOAREGS
  48          void resetFlashUpdate() {
  49   1        modbus_buffer_data [MODBUS_REFRESH_FLASH_MEMORY_ADDRESS_0] = 0;
  50   1        modbus_buffer_data [MODBUS_REFRESH_FLASH_MEMORY_ADDRESS_1] = 0; 
  51   1        modbus_buffer_data [MODBUS_REFRESH_FLASH_MEMORY_ADDRESS_2] = 0;
  52   1        modbus_buffer_data [MODBUS_REFRESH_FLASH_MEMORY_ADDRESS_3] = 0; 
  53   1      }
  54          
C51 COMPILER V9.53.0.0   MODBUS                                                            07/02/2020 01:35:01 PAGE 2   

  55          #pragma NOAREGS
  56          bool isNeedFlashUpdate() {
  57   1        return
  58   1        modbus_buffer_data [MODBUS_REFRESH_FLASH_MEMORY_ADDRESS_0] == 0x11 &&
  59   1        modbus_buffer_data [MODBUS_REFRESH_FLASH_MEMORY_ADDRESS_1] == 0x11 &&
  60   1        modbus_buffer_data [MODBUS_REFRESH_FLASH_MEMORY_ADDRESS_2] == 0x22 &&
  61   1        modbus_buffer_data [MODBUS_REFRESH_FLASH_MEMORY_ADDRESS_3] == 0x22;
  62   1      }
  63          
  64          #pragma NOAREGS
  65          uint16_t crc16_update(uint16_t crc, uint8_t a) {
  66   1        SI_SEGMENT_VARIABLE(i, int, xdata);
  67   1        crc ^= (uint16_t)a;
  68   1        for (i = 0; i < 8; ++i) {
  69   2          if (crc & 1)
  70   2            crc = (crc >> 1) ^ 0xA001;
  71   2          else
  72   2            crc = (crc >> 1);
  73   2        }
  74   1        return crc;
  75   1      }
  76          
  77          #pragma NOAREGS
  78          uint16_t calc_crc(uint8_t * command, int size_command) {
  79   1        SI_SEGMENT_VARIABLE(crc, uint16_t, xdata);
  80   1        SI_SEGMENT_VARIABLE(i, int, xdata);
  81   1        crc = 0xFFFF;
  82   1        i = 0;
  83   1        for(i=0; i<size_command; i++) {
  84   2          crc = crc16_update(crc, (uint8_t) command [i]);
  85   2        }
  86   1        return crc;
  87   1      }
  88          
  89          #pragma NOAREGS
  90          bool modbus_check_crc(uint8_t * command_receiver, int receiver_pointer) {
  91   1        if(receiver_pointer > 2) {
  92   2          uint16_t crc_calc = calc_crc(command_receiver, receiver_pointer - 2);
  93   2          uint16_t crc = command_receiver [receiver_pointer - 1];
  94   2          crc = (crc << 8) + command_receiver [receiver_pointer - 2];
  95   2          return crc_calc == crc;
  96   2        }
  97   1        return false;
  98   1      }
  99          
 100          #pragma NOAREGS
 101          uint8_t modbus_get_address() {
 102   1        return modbus_buffer_data [MODBUS_ADDRESS_IN_MEMORY];
 103   1      }
 104          
 105          #pragma NOAREGS
 106          bool modbus_check_address() {
 107   1        return modbus_get_address() == modbus_command_receiver [MODBUS_ADDRESS]
 108   1          || modbus_command_receiver [MODBUS_ADDRESS] == MODBUS_BROADCAST_ADDRESS;
 109   1      }
 110          
 111          #pragma NOAREGS
 112          uint8_t modbus_get_function() {
 113   1        return modbus_command_receiver [MODBUS_FUNCTION];
 114   1      }
 115          
 116          #pragma NOAREGS
C51 COMPILER V9.53.0.0   MODBUS                                                            07/02/2020 01:35:01 PAGE 3   

 117          void modbus_response_error(uint8_t error) {
 118   1        SI_SEGMENT_VARIABLE(crc, uint16_t, xdata);
 119   1        SI_SEGMENT_VARIABLE(i, int, xdata);
 120   1        crc = 0xFFFF;
 121   1        i = 0;
 122   1        modbus_error_response [MODBUS_ADDRESS] = modbus_get_address();
 123   1        modbus_error_response [MODBUS_ERROR] = MODBUS_ERROR_CODE;
 124   1        modbus_error_response [MODBUS_EXCEPTION] = error;
 125   1        crc = calc_crc(modbus_error_response, 3);
 126   1        modbus_error_response [3] = (uint8_t)(crc >> 8);
 127   1        modbus_error_response [4] = (uint8_t)(crc);
 128   1        for(i = 0; i<5; i++) {
 129   2          modbus_push_transmit_buffer(modbus_error_response [i]);
 130   2        }
 131   1      }
 132          
 133          #pragma NOAREGS
 134          int modbus_process_function_3() {
 135   1        SI_SEGMENT_VARIABLE(crc, uint16_t, xdata);
 136   1        SI_SEGMENT_VARIABLE(i, uint16_t, xdata);
 137   1        SI_SEGMENT_VARIABLE(register_hi, uint16_t, xdata);
 138   1        SI_SEGMENT_VARIABLE(register_lo, uint16_t, xdata);
 139   1        SI_SEGMENT_VARIABLE(modbus_data, uint8_t, xdata);
 140   1        SI_SEGMENT_VARIABLE(address_hi, uint16_t, xdata);
 141   1        SI_SEGMENT_VARIABLE(address_lo, uint16_t, xdata);
 142   1        SI_SEGMENT_VARIABLE(address, uint16_t, xdata);
 143   1        SI_SEGMENT_VARIABLE(registers_hi, uint16_t, xdata);
 144   1        SI_SEGMENT_VARIABLE(registers_lo, uint16_t, xdata);
 145   1        SI_SEGMENT_VARIABLE(registers, uint16_t, xdata);
 146   1        SI_SEGMENT_VARIABLE(number, uint8_t, xdata);
 147   1        crc = 0xFFFF;
 148   1      
 149   1        address_hi = modbus_command_receiver [MODBUS_FIRST_REGISTER_HI];
 150   1        address_lo = modbus_command_receiver [MODBUS_FIRST_REGISTER_LO];
 151   1        address = (address_hi << 8) + address_lo;
 152   1        registers_hi = modbus_command_receiver [MODBUS_NUMBER_OF_REGISTER_TO_READ_HI];
 153   1        registers_lo = modbus_command_receiver [MODBUS_NUMBER_OF_REGISTER_TO_READ_LO];
 154   1        registers = (registers_hi << 8) + registers_lo;
 155   1        number = registers << 1;
 156   1        if((address << 1) + number >= MODBUS_DATA_LENGTH) {
 157   2          modbus_response_error(MODBUS_ERROR_ILLEGAL_DATA_ADDRESS);
 158   2          return MODBUS_FAIL;
 159   2        }
 160   1        else {
 161   2          modbus_data = modbus_get_address();
 162   2          crc = crc16_update(crc, modbus_data);
 163   2          modbus_push_transmit_buffer(modbus_data);
 164   2          
 165   2          modbus_data = 3;
 166   2          crc = crc16_update(crc, modbus_data);
 167   2          modbus_push_transmit_buffer(modbus_data);
 168   2          
 169   2          modbus_data = number;
 170   2          crc = crc16_update(crc, modbus_data);
 171   2          modbus_push_transmit_buffer(modbus_data);
 172   2          
 173   2          for(i=0; i<registers; i++) {
 174   3            register_lo = modbus_buffer_data [(address << 1) + (i << 1)];
 175   3            register_hi = modbus_buffer_data [(address << 1) + (i << 1) + 1];
 176   3            modbus_data = register_lo;
 177   3            crc = crc16_update(crc, modbus_data);
 178   3            modbus_push_transmit_buffer(modbus_data);
C51 COMPILER V9.53.0.0   MODBUS                                                            07/02/2020 01:35:01 PAGE 4   

 179   3            modbus_data = register_hi;
 180   3            crc = crc16_update(crc, modbus_data);
 181   3            modbus_push_transmit_buffer(modbus_data);
 182   3            //--------------------------------------------------------------------------
 183   3            // reset -------------------------------------------------------------------
 184   3            reset_register_on_read (address + i);
 185   3            //--------------------------------------------------------------------------
 186   3          }
 187   2          modbus_push_transmit_buffer((uint8_t)(crc));
 188   2          modbus_push_transmit_buffer((uint8_t)(crc >> 8));
 189   2          TI0 = 1;
 190   2          return MODBUS_GOOD;
 191   2        }
 192   1      }
 193          
 194          #pragma NOAREGS
 195          bool modbus_check_size_of_func16(int registers_num) {
 196   1        return modbus_receiver_pointer == (MODBUS_FUNCTION_16_BASE_LENGTH + (registers_num << 1));
 197   1      }
 198          
 199          #pragma NOAREGS
 200          int modbus_process_function_16() {
 201   1        SI_SEGMENT_VARIABLE(crc, uint16_t, xdata);
 202   1        SI_SEGMENT_VARIABLE(i, uint16_t, xdata);
 203   1        SI_SEGMENT_VARIABLE(p, uint16_t, xdata);
 204   1        SI_SEGMENT_VARIABLE(register_hi, uint16_t, xdata);
 205   1        SI_SEGMENT_VARIABLE(register_lo, uint16_t, xdata);
 206   1        SI_SEGMENT_VARIABLE(register_in_hi, uint8_t, xdata);
 207   1        SI_SEGMENT_VARIABLE(register_in_lo, uint8_t, xdata);
 208   1        SI_SEGMENT_VARIABLE(modbus_data, uint8_t, xdata);
 209   1        SI_SEGMENT_VARIABLE(address_hi, uint8_t, xdata);
 210   1        SI_SEGMENT_VARIABLE(address_lo, uint8_t, xdata);
 211   1        SI_SEGMENT_VARIABLE(address, uint16_t, xdata);
 212   1        SI_SEGMENT_VARIABLE(registers_hi, uint8_t, xdata);
 213   1        SI_SEGMENT_VARIABLE(registers_lo, uint8_t, xdata);
 214   1        SI_SEGMENT_VARIABLE(registers, uint16_t, xdata);
 215   1        SI_SEGMENT_VARIABLE(number, uint16_t, xdata);
 216   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata);
 217   1        
 218   1        SFRPAGE_save = SFRPAGE;
 219   1        crc = 0xFFFF;
 220   1        
 221   1        address_hi = modbus_command_receiver [MODBUS_FIRST_REGISTER_HI];
 222   1        address_lo = modbus_command_receiver [MODBUS_FIRST_REGISTER_LO];
 223   1        address = (address_hi << 8) + address_lo;
 224   1        registers_hi = modbus_command_receiver [MODBUS_NUMBER_OF_REGISTER_TO_WRITE_HI];
 225   1        registers_lo = modbus_command_receiver [MODBUS_NUMBER_OF_REGISTER_TO_WRITE_LO];
 226   1        registers = (registers_hi << 8) + registers_lo;
 227   1        number = registers << 1;
 228   1        if(((address << 1) + number >= MODBUS_DATA_LENGTH) || !modbus_check_size_of_func16(registers)) {
 229   2          modbus_response_error(MODBUS_ERROR_ILLEGAL_DATA_ADDRESS);
 230   2          return MODBUS_FAIL;
 231   2        }
 232   1        else {
 233   2          resetFlashUpdate();
 234   2          for(i=0; i<registers; i++) {
 235   3            register_in_hi = modbus_command_receiver [(i << 1) + MODBUS_WRITE_REGISTER_OFFSET];
 236   3            register_in_lo = modbus_command_receiver [(i << 1) + 1 + MODBUS_WRITE_REGISTER_OFFSET];
 237   3            register_hi = (address << 1) + (i << 1);
 238   3            register_lo = (address << 1) + (i << 1) + 1;
 239   3            modbus_buffer_data [register_lo] = register_in_lo;
 240   3            modbus_buffer_data [register_hi] = register_in_hi;
C51 COMPILER V9.53.0.0   MODBUS                                                            07/02/2020 01:35:01 PAGE 5   

 241   3          }
 242   2          modbus_data = modbus_get_address();
 243   2          crc = crc16_update(crc, modbus_data);
 244   2          modbus_push_transmit_buffer(modbus_data);
 245   2          
 246   2          modbus_data = 16;
 247   2          crc = crc16_update(crc, modbus_data);
 248   2          modbus_push_transmit_buffer(modbus_data);
 249   2          
 250   2          modbus_data = address_hi;
 251   2          crc = crc16_update(crc, modbus_data);
 252   2          modbus_push_transmit_buffer(modbus_data);
 253   2          
 254   2          modbus_data = address_lo;
 255   2          crc = crc16_update(crc, modbus_data);
 256   2          modbus_push_transmit_buffer(modbus_data);
 257   2          
 258   2          modbus_data = registers_hi;
 259   2          crc = crc16_update(crc, modbus_data);
 260   2          modbus_push_transmit_buffer(modbus_data);
 261   2          
 262   2          modbus_data = registers_lo;
 263   2          crc = crc16_update(crc, modbus_data);
 264   2          modbus_push_transmit_buffer(modbus_data);
 265   2          
 266   2          modbus_push_transmit_buffer((uint8_t)(crc));
 267   2          modbus_push_transmit_buffer((uint8_t)(crc >> 8));
 268   2          
 269   2          if (isNeedFlashUpdate()) {
 270   3            for (p=0; p<4; p++) {
 271   4              // 4 - pages (one page size is 1024)
 272   4              FLASH_Update(MODBUS_FLASH_ADDRESS + p * 1024, modbus_buffer_data + p * 1024, 1024, 0);
 273   4            }
 274   3          }
 275   2          //EA = 0;
 276   2          //init_after_flash_reload_func_pointer();
 277   2          //EA = 1;
 278   2          modbus_16_post_func_invoke_flag = TRUE;
 279   2          TI0 = 1;
 280   2          return MODBUS_GOOD;
 281   2        }
 282   1      }
 283          
 284          #pragma NOAREGS
 285          void modbus_command_received() {
 286   1        SI_SEGMENT_VARIABLE(modbus_result, char, xdata);
 287   1        SI_SEGMENT_VARIABLE(SFRPAGE_save, unsigned char, xdata);
 288   1        
 289   1        modbus_result = MODBUS_FAIL;
 290   1        SFRPAGE_save = SFRPAGE;
 291   1        
 292   1        if(modbus_check_crc(modbus_command_receiver, modbus_receiver_pointer) && modbus_check_address()) {
 293   2          uint8_t function = modbus_get_function();
 294   2          if(function == 3 || function == 16) {
 295   3            if(function ==3) {
 296   4              modbus_result = modbus_process_function_3();
 297   4            }
 298   3            else {
 299   4              modbus_result = modbus_process_function_16();
 300   4            }
 301   3          }
 302   2          else {
C51 COMPILER V9.53.0.0   MODBUS                                                            07/02/2020 01:35:01 PAGE 6   

 303   3            modbus_response_error(MODBUS_ERROR_ILLEGAL_FUNCTION_CODE);
 304   3          }
 305   2        }
 306   1        sender_pause_timer = 0;
 307   1        modbus_receiver_pointer = 0;
 308   1      }
 309          
 310          #pragma NOAREGS
 311          uint8_t isNeedGetADCValues() {
 312   1        SI_SEGMENT_VARIABLE(temp, uint16_t, xdata);   
 313   1        temp = MODBUS_NEED_GET_ADC_VALUES_FLAG_REGISTER_ADDRESS;
 314   1        temp = temp << 1;
 315   1        if(modbus_buffer_data [temp + 1] == 1) {
 316   2          modbus_buffer_data [temp] = 0;
 317   2          modbus_buffer_data [temp + 1] = 0;
 318   2          return 1;
 319   2        }
 320   1        return 0;
 321   1      }
 322          
 323          #pragma NOAREGS
 324          uint8_t getDC24DurationTimeIfEnabed() {
 325   1        SI_SEGMENT_VARIABLE(temp, uint16_t, xdata);   
 326   1        temp = MODBUS_DC24_ENABLED_REGISTER_ADDRESS;
 327   1        temp = temp << 1;
 328   1        // low byte
 329   1        if (modbus_buffer_data [temp + 1] == 1) {
 330   2          modbus_buffer_data [temp] = 0;
 331   2          modbus_buffer_data [temp + 1] = 0;
 332   2          temp = MODBUS_DC24_OUTPUT_DURATION_REGISTER_ADDRESS;
 333   2          temp = temp << 1;
 334   2          // Default = 10 ms
 335   2          if (modbus_buffer_data [temp + 1] == 0) {
 336   3            return 1;
 337   3          } else {
 338   3            return modbus_buffer_data [temp + 1];
 339   3          }
 340   2        }
 341   1        else {
 342   2          return 0;
 343   2        }
 344   1      }
 345          
 346          #pragma NOAREGS
 347          void setDC24InputRegister(uint8_t value) {
 348   1        SI_SEGMENT_VARIABLE(temp, uint16_t, xdata);   
 349   1        temp = MODBUS_DC24_INPUT_ENABLED_REGISTER_ADDRESS;
 350   1        temp = temp << 1;
 351   1        modbus_buffer_data [temp] = 0;
 352   1        modbus_buffer_data [temp + 1] = value;
 353   1      }
 354          
 355          #pragma NOAREGS
 356          int get_modbus_receiver_counter() {
 357   1        return sender_pause_timer;
 358   1      }
 359          
 360          #pragma NOAREGS
 361          void set_modbus_receiver_counter(int mrc) {
 362   1        sender_pause_timer = mrc;
 363   1      }
 364          
C51 COMPILER V9.53.0.0   MODBUS                                                            07/02/2020 01:35:01 PAGE 7   

 365          #pragma NOAREGS
 366          void inc_modbus_receiver_counter() {
 367   1        sender_pause_timer++;
 368   1      }
 369          
 370          #pragma NOAREGS
 371          void modbus_byte_receive(uint8_t input) {
 372   1        sender_pause_timer = 0;
 373   1        modbus_command_receiver [modbus_receiver_pointer++] = input;
 374   1        if(modbus_receiver_pointer == MODBUS_RECEIVER_LENGTH) {
 375   2          modbus_receiver_pointer = 0;
 376   2        }
 377   1      }
 378          
 379          #pragma NOAREGS
 380          void modbus_transmit_byte() {
 381   1        if(modbus_transmitter_pointer_right > 0) {
 382   2          SBUF0 = modbus_command_transmitter [modbus_transmitter_pointer_left++];
 383   2          if (modbus_transmitter_pointer_left == MODBUS_TRANSMITTER_LENGTH) {
 384   3            modbus_transmitter_pointer_left = 0;
 385   3          }
 386   2        }
 387   1        if(modbus_transmitter_pointer_right == modbus_transmitter_pointer_left) {
 388   2          modbus_transmitter_pointer_right = 0;
 389   2          modbus_transmitter_pointer_left = 0;
 390   2        }
 391   1      }
 392          
 393          #pragma NOAREGS
 394          void modbus_push_transmit_buffer(uint8_t output) {
 395   1         /*
 396   1         if(output == '\n') {
 397   1           modbus_command_transmitter[modbus_transmitter_pointer_right++] = 0x0d;
 398   1         }
 399   1         else {
 400   1           modbus_command_transmitter[modbus_transmitter_pointer_right++] = output;
 401   1         }
 402   1         */
 403   1         modbus_command_transmitter[modbus_transmitter_pointer_right++] = output;
 404   1         if(modbus_transmitter_pointer_right == MODBUS_TRANSMITTER_LENGTH) {
 405   2              modbus_transmitter_pointer_right = 0;
 406   2         }
 407   1      }
 408          
 409          #pragma NOAREGS
 410          bool modbus_was_sendind_received() {
 411   1        sender_pause_timer++;
 412   1        return (sender_pause_timer > 6 && modbus_receiver_pointer > 0);
 413   1      }
 414          
 415          #pragma NOAREGS
 416          bool modbus_transmit_buffer_is_empty() {
 417   1        return modbus_transmitter_pointer_right == 0;
 418   1      }
 419          
 420          #pragma NOAREGS
 421          unsigned char modbus_get_freq_divider() {
 422   1        return modbus_buffer_data [MODBUS_FREQ_DIVIDER_ADDRESS];
 423   1      }
 424          
 425          #pragma NOAREGS
 426          void modbus_init_freqs(unsigned long * freqs) {
C51 COMPILER V9.53.0.0   MODBUS                                                            07/02/2020 01:35:01 PAGE 8   

 427   1         SI_SEGMENT_VARIABLE(i, char, xdata);
 428   1         SI_SEGMENT_VARIABLE(hi, uint8_t, xdata);
 429   1         SI_SEGMENT_VARIABLE(lo, uint8_t, xdata);
 430   1         SI_SEGMENT_VARIABLE(address, unsigned short int, xdata);
 431   1         address = MODBUS_FREQ_VALUES_START_ADDRESS;
 432   1         for (i=0; i<12; i++) {
 433   2            hi = modbus_buffer_data [address];
 434   2            lo = modbus_buffer_data [address + 1];
 435   2            freqs [i] = (hi << 8) + lo;
 436   2            address += 2;
 437   2         }
 438   1      }
 439          
 440          #pragma NOAREGS
 441          void modbus_write_register(unsigned int address, uint8_t value) {
 442   1         address = address << 1;
 443   1         modbus_buffer_data [address + 1] = value;
 444   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2394    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   5067      70
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11      21
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
