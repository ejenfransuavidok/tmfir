C51 COMPILER V9.53.0.0   FIR                                                               05/04/2020 02:22:25 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE FIR
OBJECT MODULE PLACED IN fir.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE fir.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include "fir.h"
   2          /*
   3          #define BIGINT_SIZE 16
   4          
   5          typedef struct {
   6            unsigned char d [16];
   7          } BIGINT;
   8          
   9          void bigintSummator(BIGINT *accumulator, BIGINT *argument) {
  10            SI_SEGMENT_VARIABLE(i, unsigned char, xdata);
  11            SI_SEGMENT_VARIABLE(p, unsigned char, xdata);
  12            p = 0;
  13            for (i=0; i<BIGINT_SIZE; i++) {
  14              if (((*accumulator).d [i] + (*argument).d [i]) > 0xFF) {
  15                p = 1;
  16              } else {
  17                p = 0;
  18              }
  19              (*accumulator).d [i] = (*accumulator).d [i] + (*argument).d [i] + p;
  20            }
  21          }
  22          */
  23          int getFreqFromModbusForDAC(int number) {
  24   1        uint8_t hi;
  25   1        uint8_t lo;
  26   1        uint8_t * modbus_buffer_data;
  27   1        
  28   1        modbus_buffer_data = getModbusBufferData();
  29   1        
  30   1        hi = modbus_buffer_data[((MODBUS_OUTPUT_FREQ_FLAG_REGISTER_OFFSET + number) << 1)];
  31   1        lo = modbus_buffer_data[(((MODBUS_OUTPUT_FREQ_FLAG_REGISTER_OFFSET + number) << 1) + 1)];
  32   1        
  33   1        return ((hi << 8) + lo);
  34   1      }
  35          
  36          int populateFirCoefficients(SI_UU16_t * coefficients, int number) {
  37   1        SI_SEGMENT_VARIABLE(i, int, xdata);
  38   1        SI_SEGMENT_VARIABLE(order, int, xdata);
  39   1        SI_SEGMENT_VARIABLE(temp, int, xdata);
  40   1        SI_SEGMENT_VARIABLE(coefficientIndex, int, xdata);
  41   1        SI_SEGMENT_VARIABLE(hi, uint8_t, xdata);
  42   1        SI_SEGMENT_VARIABLE(lo, uint8_t, xdata);
  43   1        
  44   1        uint8_t * modbus_buffer_data;
  45   1        if (number > 11 || number < 0) {
  46   2          return 0;
  47   2        }
  48   1        coefficientIndex = MODBUS_FILTER_COEFFICIENT_START_REGISTER + FILTER_MAX_ORDER_IN_MODBUS * number;
  49   1        modbus_buffer_data = getModbusBufferData();
  50   1        order = MODBUS_FILTER_ORDER_START_REGISTER;
  51   1        order = order + number;
  52   1        // reg number to byte number
  53   1        order = order << 1;
  54   1        // get filter order
  55   1        order = modbus_buffer_data [order + 1];
C51 COMPILER V9.53.0.0   FIR                                                               05/04/2020 02:22:25 PAGE 2   

  56   1        if (order > FILTER_MAX_ORDER) {
  57   2          order = FILTER_MAX_ORDER;
  58   2        }
  59   1        for (i = 0; i<order && i<FILTER_MAX_ORDER; i++) {
  60   2          temp = coefficientIndex + i;
  61   2          hi = modbus_buffer_data [temp << 1];
  62   2          lo = modbus_buffer_data [(temp << 1) + 1];
  63   2          coefficients [i].u16 = (hi << 8) + lo;
  64   2        }
  65   1        return order;
  66   1      }
  67          
  68          void putRms2Modbus(int value, int number) {
  69   1        uint8_t * modbus_buffer_data;
  70   1        SI_SEGMENT_VARIABLE(hi, uint8_t, xdata);
  71   1        SI_SEGMENT_VARIABLE(lo, uint8_t, xdata);
  72   1        SI_SEGMENT_VARIABLE(address, int, xdata);
  73   1        SI_SEGMENT_VARIABLE(amplitude_reference, int, xdata);
  74   1        SI_SEGMENT_VARIABLE(flag, uint8_t, xdata);
  75   1        
  76   1        if (number > 11 || number < 0) {
  77   2          return;
  78   2        }
  79   1        //---------------------- PUT FIR RESULT TO MODBUS ----------------------
  80   1        address = MODBUS_FREQUENCY_AMPLITUDES_VALUE_START + number;
  81   1        address = address << 1;
  82   1        hi = (value >> 8);
  83   1        lo = (value & 0xFF);
  84   1        modbus_buffer_data = getModbusBufferData();
  85   1        modbus_buffer_data [address] = hi;
  86   1        modbus_buffer_data [address + 1] = lo;
  87   1        //---------------------- READ REFERENCE FROM MODBUS ----------------------
  88   1        address = MODBUS_AMPLITUDES_THREASHOLS_VALUE_START + number;
  89   1        address = address << 1;
  90   1        hi = modbus_buffer_data [address];
  91   1        lo = modbus_buffer_data [address + 1];
  92   1        amplitude_reference = (hi << 8) + lo;
  93   1        //---------------------- COMPARE FIR RESULT AND REFEREBCE ----------------------
  94   1        if (value > amplitude_reference) {
  95   2           flag = 1;
  96   2        } else {
  97   2           flag = 0;
  98   2        }
  99   1        //---------------------- PUT COMPARATIVE TO MODBUS LIKE A FLAG ----------------------
 100   1        address = MODBUS_FREQUENCY_VALUE_START + number;
 101   1        address = address << 1;
 102   1        modbus_buffer_data [address] = 0;
 103   1        modbus_buffer_data [address + 1] = flag;
 104   1      }
 105          
 106          /*-----------------------------------------------------------------------------
 107          // RMS_Calc
 108          //-----------------------------------------------------------------------------
 109          //
 110          // Return Value : None
 111          // Parameters   :
 112          //   1) input_samples - pointer to an array of the data to be used for the RMS
 113          //                        Value calculations
 114          //   2) num_samples - the number of data elements in the <input_samples> array
 115          //
 116          // This routine takes a pointer to an array and a number of samples and first
 117          // computes the average value of the data.  Then, it uses this average to
C51 COMPILER V9.53.0.0   FIR                                                               05/04/2020 02:22:25 PAGE 3   

 118          // calculate the RMS Value by using the following equation:
 119          //
 120          //                 N
 121          //                 __
 122          //                 \
 123          //                 /_  (x-x_avg)^2
 124          //                 n=10
 125          // RMS_Value^2 =  -----------------
 126          //                       N-10
 127          //
 128          //
 129          // The above routine skips the first <TAPS> samples where the filter hasn't quite
 130          // settled.
 131          //---------------------------------------------------------------------------*/
 132          /*
 133          int RMS_Calc (int *input_samples, int num_samples, int TAPS)
 134          {
 135             int count = 0;
 136             float average = 0;
 137             float RMS_summation = 0;
 138             float RMS_Value;
 139             float temp;
 140            
 141             //EA = 0;
 142             // Calculate the average value (x_avg) of the <input_samples> array
 143             average = 0.0;
 144          
 145             for (count = TAPS; count < num_samples; count++)
 146             {
 147                average += (float) input_samples[count];
 148             }
 149             average = (float)(average / (num_samples-TAPS));
 150          
 151             // Calculate the RMS Value using the average computed above
 152             // Calculate the sum from 1 to N of (x-x_avg)^2
 153             for (count = TAPS; count < num_samples; count++)
 154             {
 155                // calculate difference from mean
 156                temp = input_samples[count] - average;
 157                // square it
 158                temp *= temp;
 159                // and add it to sum
 160                RMS_summation += temp;
 161             }
 162             // Calculate sum from above / N
 163             RMS_summation = (float)RMS_summation / (num_samples-TAPS);
 164             RMS_Value = RMS_summation / 20000;
 165             //EA = 1;
 166             return (int)RMS_Value;
 167          }
 168          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    663    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      17
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      17
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.53.0.0   FIR                                                               05/04/2020 02:22:25 PAGE 4   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
